<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WgCg Blog</title>
  
  <subtitle>Keep Learning and Never Give Up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-28T08:57:29.347Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cong.Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序之webview常见问题</title>
    <link href="http://yoursite.com/2019/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwebview%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2019/08/28/微信小程序之webview常见问题.html</id>
    <published>2019-08-28T08:55:48.000Z</published>
    <updated>2019-08-28T08:57:29.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官方汇总链接 <a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;lang=zh_CN&amp;token=585555149&amp;docid=ebfd9e5ec9986b4f23c41f8d8bbf2730" target="_blank" rel="noopener">https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;lang=zh_CN&amp;token=585555149&amp;docid=ebfd9e5ec9986b4f23c41f8d8bbf2730</a></p><p>微信小程序内嵌网页的一些（最佳）实践 <a href="https://zhuanlan.zhihu.com/p/33985049" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33985049</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>web-view 不支持推送服务通知（或称模板消息)</li><li>webview 里面的网页不能调用JSSDK进行微信支付，需要小程序原生页面通过小程序的支付api进行支付</li><li>web-view 跟小程序是独立的两个环境，数据完全不通，包括 cookie、session、localStorage 等等；</li><li>但小程序内嵌 web-view 跟微信内置浏览器是一套环境，也就是说你在 web-view 里面留下的以上痕迹，到微信里内置浏览器打开也有；</li><li>在两种环境下，不太容易区分到底是什么环境，小程序官方给的判断方法是 window.__wxjs_environment === ‘miniprogram’，但是在 web-view 进入第二页时候，安卓机下这个变量就 undefined 了。</li></ol><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ol><li>打开的域名没有在小程序管理后台设置业务域名(注意是业务域名，不是服务器域名)；</li><li>打开的页面 302 过去的地址也必须设置过业务域名；</li><li>页面可以包含 iframe，但是 iframe 的地址必须为业务域名；</li><li>打开的页面必须为 https 服务；</li><li>开发者自己检查自己的 https 服务是否正常，测试方法：普通浏览器打开对应的地址；</li><li>iOS上传图片问题 iOS小程序webview内input选择文件崩溃</li><li>webview postmessage 给小程序，data对应的值必须是个对象，不能是字符串<a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0000429a4004205ecf96ea80c51004&amp;highline=web-view&amp;comment_lvl=1，如下图" target="_blank" rel="noopener">https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0000429a4004205ecf96ea80c51004&amp;highline=web-view&amp;comment_lvl=1，如下图</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;官方汇总链接 &lt;a href=&quot;https://developers.weixin.qq.com/blogdetail?ac
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="常见问题" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>H5上传图片</title>
    <link href="http://yoursite.com/2019/08/28/H5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.html"/>
    <id>http://yoursite.com/2019/08/28/H5上传图片.html</id>
    <published>2019-08-28T08:36:26.000Z</published>
    <updated>2019-08-28T09:11:59.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img width="500" src="/assets/mobile/solution/h5上传图片.png"></p><h2 id="问题-amp-解决方案"><a href="#问题-amp-解决方案" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h2><h3 id="如何区分环境"><a href="#如何区分环境" class="headerlink" title="如何区分环境"></a>如何区分环境</h3><p>通过 User Agent 来区分。 UA 中含有 MicroMessage 表明为微信环境。<br>UA 中或者 cookie 中含有 cdvsupport 表明为 APP 环境。<br>UA 匹配/(i[^;]+;( U;)? CPU.+Mac OS X/ 表明是 IOS 环境。</p><h3 id="在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法"><a href="#在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法" class="headerlink" title="在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法"></a>在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法</h3><p>File 对象 h5 文件上传后的对象， 也是作为最终通过 FormData 上传的对象。<br>HTMLImageElement 通过 new Image 创建， 可以获取上传图片的宽高。</p><p>HTMLCanvasElemen 对象 用于图片压缩，通过 toBlob 获取 blob 对象 和 canvas.toDataURL 方法获取 dataurl</p><h3 id="图片如何实现压缩的"><a href="#图片如何实现压缩的" class="headerlink" title="图片如何实现压缩的"></a>图片如何实现压缩的</h3><p>将图片转化成 canvas 对象，利用 canvas.toBlob 和 canvas.toDataURL 的压缩参数来进行压缩。 因而上传的图片需要先转化成 canvas。</p><h3 id="在微信内部调用-h5-方法需要哪些提前的准备工作和注意事项"><a href="#在微信内部调用-h5-方法需要哪些提前的准备工作和注意事项" class="headerlink" title="在微信内部调用 h5 方法需要哪些提前的准备工作和注意事项"></a>在微信内部调用 h5 方法需要哪些提前的准备工作和注意事项</h3><p>微信分享<br>微信公众号开发相关</p><h3 id="在这个过程中运用了哪些第三方库，是干什么用的"><a href="#在这个过程中运用了哪些第三方库，是干什么用的" class="headerlink" title="在这个过程中运用了哪些第三方库，是干什么用的"></a>在这个过程中运用了哪些第三方库，是干什么用的</h3><ol><li>exifjs <a href="http://code.ciaoca.com/javascript/exif-js" target="_blank" rel="noopener">http://code.ciaoca.com/javascript/exif-js</a> 获取图片的 Orientation 属性（拍摄方向） Tip: exif 的获取 Orientation 的渊源</li><li>swiper <a href="https://www.swiper.com.cn/usage/index.html" target="_blank" rel="noopener">https://www.swiper.com.cn/usage/index.html</a> 图片预览</li><li>touch.js <a href="https://allcky.github.io/touchjs/" target="_blank" rel="noopener">https://allcky.github.io/touchjs/</a> 在裁剪图片时，支持用户缩放，移动图片</li><li>toBlob.js <a href="https://github.com/eligrey/canvas-toBlob.js/" target="_blank" rel="noopener">https://github.com/eligrey/canvas-toBlob.js/</a> 解决 canvas.toBlob 的浏览器支持问题</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>小程序内嵌 h5 页面，如果使用原生 input 上传，在 IOS10 及以下会奔溃。因而，需要在微信小程序环境下，调用微信提供的原生 API。</li><li>在 APP 中，使用原生的 input 在安卓设备下无法调起摄像头。可以考虑原生 APP 提供的拍照和相册功能。</li></ol><h2 id="input-的-capture-amp-multiple-属性"><a href="#input-的-capture-amp-multiple-属性" class="headerlink" title="input 的 capture&amp;multiple 属性"></a>input 的 capture&amp;multiple 属性</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 无capture,无multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 无capture,有multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">multiple</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// capture="camera",无multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">capture</span>=<span class="string">"camera"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// capture="camera",有multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">capture</span>=<span class="string">"camera"</span> <span class="attr">multiple</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分别在 IOS 微信，IOS 非微信（Safari、QQ 浏览器）、Android 微信、Android 非微信（UC、原生）下进行实验</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th>无 capture,无 multiple</th><th>capture=”camera”,无 multiple</th><th>无 capture,有 multiple</th><th>capture=”camera”,有 multiple</th></tr></thead><tbody><tr><td>Android 微信</td><td>正常（单选）</td><td>仅相机</td><td>仅文件</td><td>正常</td></tr><tr><td>Android 非微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（单选）</td><td>仅相机</td></tr><tr><td>IOS 微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（多选）</td><td>仅相机</td></tr><tr><td>IOS 非微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（多选）</td><td>仅相机</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>input[type=”file”]在不同环境下的表现形式不仅和 capture 属性有关，还和 multiple 有关</li><li>安卓系统下，无论是否加 multiple 属性，只能单选图片</li><li>无 capture、无 multiple 属性时，各种环境下表现正常且一致。因此若需求不要求多选图片，则可放心使用 &lt;input type=”file” accept=”image/*“&gt;</li><li>在进行开发时，大家要根据具体需求选择不同的兼容方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h2&gt;&lt;p&gt;&lt;img width=&quot;500&quot; src=&quot;/assets/mobile/solution/h5上传图片.png&quot;&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="解决方案" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>页面返回刷新方案</title>
    <link href="http://yoursite.com/2019/08/28/%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html"/>
    <id>http://yoursite.com/2019/08/28/页面返回刷新方案.html</id>
    <published>2019-08-28T08:16:54.000Z</published>
    <updated>2019-08-28T08:27:33.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需求中经常会遇到需要两个页面之间做联动的情况，比如：</p><p>一、从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列表页时，因为通用地址做了更改，需要列表页进行刷新重新获取列表项的操作；</p><p>二、从订单详情页点击评价进入到评价页面，当评价页面提交评价成功后，需要跳回到订单详情页，这时需要订单详情页展示评价的内容；</p><p>如果不用单页应用的方式实现，而只用两个不同页面 A 和 B 实现的话，以目前的方法，无论采取哪种，都会造成体验上的缺失：</p><p>A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，再通过 a 标签或 location.href 的方式打开一个新的 A 页面。这种情况会在 history 存在 3 个记录，用户从新的 A 页面点击返回按钮时，会从新的 A 页面 →B 页面 → 旧的 A 页面；<br>A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：history 会存在 2 个记录，用户从新的 A 页面点击返回时，会从新的 A 页面 → 旧的 A 页面，虽然看不到 B 页面（地址选择页、评价输入页等），但还是会返回到旧的 A 页面，也会造成用户的困惑；而且在 android 到家 webview 中，replace 仍然会保留之前页面的 history；<br>A 页面直接通过 location.replace 打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：虽然只有一条记录，在新的 A 页面可以直接返回 A 页面的来源页，但由于 B 页面是 replace A 页面的，当用户不想操作 B 页面而只想返回到 A 页面时，A 页面已经丢失了，会返回到 A 页面的来源页；且同样存在 android 到家 webview 中 replace 的问题；<br>更好的方法是（如果不用单页面应用），从 A 页面正常打开 B 页面（a 标签或 location.href），当在 B 页面操作成功后，直接返回到 A 页面(histroty.back()/history.go(-1)/点击回退按钮)。但这时往往由于浏览器强大的缓存能力，展现的是缓存的旧的 A 页面，与我们预想的展示新的 A 页面不符。</p><p>这时我们想到的，就是让 A 页面在监听到 B 页面的返回时，可以进行刷新操作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>用以下三个方法的结合，可以解决大部分机型缓存页面的问题。</p><h3 id="pageshow"><a href="#pageshow" class="headerlink" title="pageshow"></a>pageshow</h3><p>在 A 页面用监听 pageshow 事件，当浏览器从 B 页面返回时，会执行 pageshow 的回调，我们在事件中使用 location.reload()方法刷新 A 页面。网上的方案还会加上 pagehide 方法，以防 pageshow 不成功的情况，但在调研时发现只要支持 pagehide 的浏览器都支持会支持 pageshow，所以暂时用 pageshow 就可以搞定了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt.persisted) &#123;</span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：微信、safari、Chrome、Firefox、Yandex</p><p>Android：QQ 浏览器、Firefox、UC、手机百度</p><p>这些浏览器中的 A 页面会完全地缓存下来，时刻监听 pageshow/pagehide，当从 B 返回到 A 页面时，不会重新请求 html 文档，也不会重新执行 js。（参见 bfcache）</p><h3 id="借助前页面重新执行-js-的方法对比-html-文档版本号"><a href="#借助前页面重新执行-js-的方法对比-html-文档版本号" class="headerlink" title="借助前页面重新执行 js 的方法对比 html 文档版本号"></a>借助前页面重新执行 js 的方法对比 html 文档版本号</h3><p>有些浏览器不支持 pageshow/pagehide，但这些浏览器大部分都会在 A 页面重新被展示时，虽然不会拉取 html 文档，但是会重新执行一遍 A 页面的 js。这时我们可以借助重新执行 js 的机会，比较文档版本号（我们自己定义的），然后在判断是否是旧的 A 页面时，reload 页面。</p><p>具体操作：</p><ol><li>给每个需要后退刷新的页面上加一个 hidden input，存储页面在服务端的生成时间【需要后端支持】，作为页面的服务端版本号。</li><li>并附加一段 JS 读取读取页面的版本号，同时也记录在浏览器/webview 本地（cookie/localStorage/sessionStorage）进行存储，作为本地版本号。</li><li>JS 检查页面的服务端版本号和本地存储中的版本号，如果服务端版本号大于本地存储中版本号，说明页面是从服务端重新生成的；否则页面就是本地缓存的，即发生了后退行为。</li><li>JS 在监测到后退时，强制页面重新从服务端获取。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SERVER_TIME = <span class="built_in">document</span>.getElementById(<span class="string">'SERVER_TIME'</span>)</span><br><span class="line"><span class="keyword">var</span> REMOTE_VER = SERVER_TIME &amp;&amp; SERVER_TIME.value</span><br><span class="line"><span class="keyword">if</span> (REMOTE_VER) &#123;</span><br><span class="line">    <span class="keyword">var</span> LOCAL_VER = sessionStorage &amp;&amp; sessionStorage.PAGEVERSION</span><br><span class="line">    <span class="keyword">if</span> (LOCAL_VER &amp;&amp; <span class="built_in">parseInt</span>(LOCAL_VER) &gt;= <span class="built_in">parseInt</span>(REMOTE_VER)) &#123;</span><br><span class="line">        <span class="comment">//说明html是从本地缓存中读取的</span></span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//说明html是从server端重新生成的，更新LOCAL_VER</span></span><br><span class="line">        sessionStorage.PAGEVERSION = REMOTE_VER</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：UC、手机百度</p><p>Android：微信、Chrome、Yandex</p><h3 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h3><p>通过以上两种方法的结合，可以覆盖到大部分浏览器。但有一些浏览器在 A 页面打开 B 页面的过程中，像是开了一个新的 Webview 来展示 B 页面的（小米自带浏览器尤其明显，虽然用户看到的还是同一个 Tab），不会触发方法一和方法二。这时可以借助与浏览器 Tab 相关的 Page Visibility API，含义大概为当用户最小化页面或者切换到另一个 Tab 时，将触发 visibilitychange 方法，并可以通过判断此时页面展示相关的属性（document.hidden 、document.visibilityState）来确定页面的显示状态。</p><p>于是当浏览器疑似用新开 Webview 的方式做页面 A 到页面 B 的转跳时（再次强调，用户看到的还是同一个 Tab），页面 A 可以通过对 visibilitychange 事件，实现对返回的监听。</p><p>注：由于 visibilitychange 事件监听的是 Tab 之间的切换，所以当用户的浏览器打开了其它的 Tab，并与页面 A 所处的 Tab 间来回切换时，或者切换到其它的 APP 又回到浏览器时，同理也会触发我们的监听事件。这时如果不做特殊处理，也会导致页面 A 的刷新。（可以在页面 A 转跳到页面 B 时记录一个字段在本地存储，并在 visibilitychange 中通过此字段判断是否是 AB 之间的转跳）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        <span class="comment">// tab hidden</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// tab show</span></span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, handleVisibilityChange, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：QQ 浏览器</p><p>Android：小米自带浏览器</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在调研的过程中，通过以上三个方法的结合，可以解决所有 Android&amp;iOS 浏览器。可能还有没试到的浏览器会有不支持的情况，发现后会及时更新。</p><p>以上为页面返回刷新方案的调研结果，有了对页面返回动作的监听，除了单纯地对缓存页面进行刷新，也可以结合需求做其它的操作。</p><p>三种方法的浏览器兼容情况：</p><table><thead><tr><th>方案</th><th>IOS</th><th>Android</th><th>说明</th></tr></thead><tbody><tr><td>pageshow/pagehide</td><td>微信、safari、Chrome、Firefox、Yandex</td><td>QQ 浏览器、Firefox、UC、手机百度</td><td>回退后不重新请求 html，不重新执行 js</td></tr><tr><td>重新执行 js 对比 Html 文档版本号</td><td>UC、手机百度</td><td>微信、Chrome、Yandex</td><td>回退后不重新请求 html，重新执行 js</td></tr><tr><td>Page Visibility API</td><td>QQ 浏览器</td><td>小米自带浏览器</td><td>回退后不重新请求 html，不重新执行 js</td></tr><tr><td>三种方法都不支持的情况</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>调研使用手机：</p><p>iOS: iPhone 7 Plus</p><p>Android: 红米 4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;需求中经常会遇到需要两个页面之间做联动的情况，比如：&lt;/p&gt;
&lt;p&gt;一、从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序之清除webview缓存</title>
    <link href="http://yoursite.com/2019/08/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%B8%85%E9%99%A4webview%E7%BC%93%E5%AD%98.html"/>
    <id>http://yoursite.com/2019/08/27/微信小程序之清除webview缓存.html</id>
    <published>2019-08-27T10:48:57.000Z</published>
    <updated>2019-08-28T08:17:05.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ol><li>微信-清理微信存储空间方法（iOS）<br>依次打开微信：我－设置 -  通用－存储空间 －清理微信缓存，就可以清理掉 webview 的缓存（实践表明：这种方法清理效果不好，经常清不掉）</li><li>Android清理方法<br> 在任意聊天窗口发送： <a href="http://debugx5.qq.com" target="_blank" rel="noopener">http://debugx5.qq.com</a> （必须手机端微信窗口访问），打开这个网址，找到清理缓存，点击即可（当然还有其他功能可以使用哦）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序&quot;&gt;&lt;a href=&quot;#小程序&quot; class=&quot;headerlink&quot; title=&quot;小程序&quot;&gt;&lt;/a&gt;小程序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;微信-清理微信存储空间方法（iOS）&lt;br&gt;依次打开微信：我－设置 -  通用－存储空间 －清理微信缓存，就可以清理掉 
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="常见问题" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序之文档笔记</title>
    <link href="http://yoursite.com/2019/07/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/07/29/微信小程序之文档笔记.html</id>
    <published>2019-07-29T09:31:42.000Z</published>
    <updated>2019-08-27T10:48:12.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h2><h3 id="小程序的由来"><a href="#小程序的由来" class="headerlink" title="小程序的由来"></a>小程序的由来</h3><p>Web 应用存在的问题：</p><ol><li>即使<strong>微信 Web 资源离线存储</strong>技术能够解决一些问题，但对于一些复杂的页面仍有白屏问题，例如页面加载了大量的<code>js</code>和<code>css</code>文件</li><li>页面切换的生硬和点击的迟滞感</li></ol><p>​ 微信面临的问题是如何设计一个比较好的系统，使得所有开发者在微信中都能获得比较好的体验。这个问题是之前的 JS-SDK 所处理不了的，需要一个全新的系统来完成，它需要使得所有的开发者都能做到：</p><ol><li>快速的加载</li><li>更强大的能力</li><li>原生的体验</li><li>易用且安全的微信数据开发</li><li>高效和简单的开发</li></ol><h3 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h3><ol><li>web 中渲染线程和脚本线程是互斥的，而小程序采用的双线程</li><li>小程序中不能使用<code>DOM API</code>和<code>BOM API</code></li><li><p>不用面对各式各样的浏览器，只需要面对 ios、android 的微信客户端，以及用于辅助开发的小程序开发者工具</p><p> | 运行环境 | 逻辑层 | 渲染层 |<br> | IOS | JavaScriptCore | WKWebview |<br> | Android | V8 | chromium 定制内核 |<br> |开发者工具| NWJS | Chrome Webview |</p></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="WXSS选择器"><a href="#WXSS选择器" class="headerlink" title="WXSS选择器"></a>WXSS选择器</h3><ol><li>组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。</li><li>组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。</li><li>子元素选择器（.a&gt;.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。</li><li>继承样式，如 font 、 color ，会从组件外继承到组件内。</li><li>除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序简介&quot;&gt;&lt;a href=&quot;#小程序简介&quot; class=&quot;headerlink&quot; title=&quot;小程序简介&quot;&gt;&lt;/a&gt;小程序简介&lt;/h2&gt;&lt;h3 id=&quot;小程序的由来&quot;&gt;&lt;a href=&quot;#小程序的由来&quot; class=&quot;headerlink&quot; title=&quot;小
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="文档笔记" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之生成二维码</title>
    <link href="http://yoursite.com/2019/07/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html"/>
    <id>http://yoursite.com/2019/07/08/微信小程序之生成二维码.html</id>
    <published>2019-07-08T08:22:50.000Z</published>
    <updated>2019-07-09T08:56:04.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微信小程序根据url生成一个带logo的二维码</p><h2 id="weapp-qrcode"><a href="#weapp-qrcode" class="headerlink" title="weapp-qrcode"></a>weapp-qrcode</h2><p>使用<a href="https://github.com/yingye/weapp-qrcode" target="_blank" rel="noopener">weapp-qrcode</a>lib生成二维码</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><code>drawQrcode</code>方法要求传入<code>px</code>，如果页面布局使用的是<code>rpx</code>，需要动态进行转换</li><li>绘制二维码时使用到了<code>canvas</code>标签，而<code>canvas</code>标签是原生组件，层级高于普通标签，导致toast提示弹窗被<code>canvas</code>遮挡，于是把<code>canvas</code>隐藏到屏幕外，使用<code>image</code>标签配合<code>wx.canvasToTempFilePath</code>方法实现</li><li>要在二维码中绘制图片，使用的是<code>CanvasContext.drawImage</code>方法，但是此方法的图片来源必须是本地图片，所以需要先调用<code>wx.getImageInfo</code>或<code>wx.downloadFile</code>把图片下载到本地，然后用本地图片的路径进行绘制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;微信小程序根据url生成一个带logo的二维码&lt;/p&gt;
&lt;h2 id=&quot;weapp-qrcode&quot;&gt;&lt;a href=&quot;#weapp-qrco
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="生成二维码" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="http://yoursite.com/2019/06/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html"/>
    <id>http://yoursite.com/2019/06/25/字符串的扩展.html</id>
    <published>2019-06-25T03:30:32.000Z</published>
    <updated>2019-06-25T12:40:29.449Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>解构赋值</title>
    <link href="http://yoursite.com/2019/06/24/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html"/>
    <id>http://yoursite.com/2019/06/24/解构赋值.html</id>
    <published>2019-06-24T13:03:32.000Z</published>
    <updated>2019-06-25T03:30:15.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><ol><li>如果等号的右边（或隐式转为对象后）不是可遍历的解构（Iterator），那么将会报错。</li><li>只有当一个数组成员严格等于（===）<code>undefined</code>时，默认值才会生效。</li></ol><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ol><li>对象的解构赋值可以取到继承的属性。</li><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</li><li>如果等号右边是字符串、数字、布尔值，则会隐式的转为对象。因为<code>undefined</code>和<code>null</code>无法转为对象，所以会报错。</li><li>不能使用圆括号的情况<ul><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式</li></ul></li><li>能使用圆括号的情况<ul><li>赋值语句的非模式部分</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果等号的右边（或隐式转为对象后）不是可遍历的解构（Iterator），那么将会报错。&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>let和const命令</title>
    <link href="http://yoursite.com/2019/06/24/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4.html"/>
    <id>http://yoursite.com/2019/06/24/let和const命令.html</id>
    <published>2019-06-24T12:01:17.000Z</published>
    <updated>2019-06-24T13:04:02.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ol><li>只在块级作用域内有效。</li><li>不存在变量提升。</li><li>暂时性死区，只要块级作用域内存在<code>let</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错（无论父级作用域是否定义了这些变量），这意味着<code>typeof</code>不再是一个百分百的安全操作。</li><li>不允许重复声明同一个变量。</li><li><code>for</code>循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li></ol><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><ol><li>ES5 规定函数只能在顶层作用域和函数作用域进行声明，不能再块级作用域中进行声明，但是浏览器为了兼容以前的旧代码，并没有遵守这个规范。 ES6 明确规定允许在块级作用域中声明函数。</li><li>ES5 中，函数的整条声明语句会被提升到函数头部或顶级作用域头部</li><li>ES6 的浏览器函数声明的限制（其他环境的实现不用遵守，还是将块级作用域中的函数声明当作<code>let</code>处理）：<ul><li>允许在块级作用域内声明函数</li><li>函数声明类似于<code>var</code>，会提升到全局作用域或函数作用域的头部</li><li>同时，函数声明还会提升到块级作用域的头部</li></ul></li><li>考虑到环境的行为差异太大，不建议在块级作用域内进行函数声明，如果要使用，最好使用函数表达式。</li><li>ES6 的块级作用域必须有大括号，如果没有大括号，<code>JS</code>引擎就认为不存在块级作用域。</li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li><code>const</code>声明一个常量，一旦声明，常量的值不允许改变。单对于复合类型数据（例如对象，数组），其只能保证指向内存地址的指针不改变，无法保证其数据结构不变。可以使用<code>Object.freeze</code>进行冻结（只能冻结改对象的属性，如果其属性是一个对象，只能保证指针不变，无法保证子对象的属性不变）。</li><li>必须立即初始化。</li><li>只在块级作用域内有效。</li><li>不存在变量提升。</li><li>暂时性死区。</li><li>不允许重复声明。</li></ol><h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><ol><li>var</li><li>function</li><li>let</li><li>const</li><li>import</li><li>class</li></ol><h3 id="顶层对象属性"><a href="#顶层对象属性" class="headerlink" title="顶层对象属性"></a>顶层对象属性</h3><ol><li><code>var</code>和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性。</li><li><code>let</code>、<code>const</code>、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</li></ol><h3 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h3><ol><li>不同环境中指向顶层对象的变量不同<ul><li>浏览器：self 和 this</li><li>Web Worker：self</li><li>Node: global</li></ul></li><li>全局环境中，<code>this</code>返回的是顶层对象。但是，在<code>ES6</code>模块和<code>Node</code>模块中，<code>this</code>返回的是当前模块。</li><li>函数里面的 this，如果函数不是作为对象的方法允许，而是单纯作为函数允许，<code>this</code>会指向顶层对象。但是，在严格模式下，<code>this</code>会返回<code>undefined</code>。</li><li>不管是在严格模式还是普通模式，<code>new Function(&#39;return this&#39;)()</code>总是返回全局对象。但是，如果浏览器使用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>，<code>new Function</code>这些方法可能无法使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;只在块级作用域内有效。&lt;/li&gt;
&lt;li&gt;不存在变量提升。&lt;/li&gt;
&lt;li&gt;暂时性死区，只要块级作用域内存在&lt;code
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>面试之Web其它</title>
    <link href="http://yoursite.com/2019/05/06/%E9%9D%A2%E8%AF%95%E4%B9%8BWeb%E5%85%B6%E5%AE%83.html"/>
    <id>http://yoursite.com/2019/05/06/面试之Web其它.html</id>
    <published>2019-05-06T14:44:43.000Z</published>
    <updated>2019-05-06T15:39:19.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><h3 id="什么是SEO"><a href="#什么是SEO" class="headerlink" title="什么是SEO"></a>什么是SEO</h3><p>SEO（Search Engine Optimization），中文译为“搜索引擎优化”，是一种透过了解搜索引擎的运作规则来调整网站，以提高目的网站在有关搜索引擎内的自然排名的方式。</p><h3 id="SEO的分类"><a href="#SEO的分类" class="headerlink" title="SEO的分类"></a>SEO的分类</h3><ol><li>白帽SEO：改良和规范网页的设计，使其对搜索引擎和用户更加友好，是一种搜索引擎推荐的做法。</li><li>黑帽SEO：利用或者放大搜索引擎的缺陷，使用不正当的手段提高目的网站在搜索引擎的排名。</li></ol><h3 id="SEO的主要方面"><a href="#SEO的主要方面" class="headerlink" title="SEO的主要方面"></a>SEO的主要方面</h3><p>白帽SEO：</p><ol><li>合理的<code>title</code>、<code>keywords</code>、<code>description</code></li><li>语义化的HTML</li><li>重要的HTML尽量放在前面。搜索引擎抓取HTML的顺序是从上到下的，有些搜索引擎的抓取长度有限，保证重要内容一定会被抓取</li><li>重要的内容不要用<code>js</code>输出：搜索引擎不会执行<code>js</code>获取内容</li><li>减少<code>iframe</code>的使用：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性的图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li><li>增加与网页内容相关的外链引用</li></ol><p>黑帽SEO：</p><ol><li>垃圾索引：透过欺骗技术和滥用搜索算法来推销毫不相关、主要以商业为着眼的网页。</li><li>斗篷法：用了两版不同的网页来达到最优化的效果。</li><li>关键字隐密字：通常是指设置关键字的颜色和网页背景颜色一样，或透过 css hidden attribute （隐密特性） 来达到优化效果。</li><li>桥页：通常是用软件自动生成大量包含关键词的网页，然后从这些网页做自动转向到主页。</li><li>付费链接：是利用支付费用方式要求其他网站提供链接至自身网站，借此伪装高信任网站来欺骗搜索引擎。</li><li>链接农场：是故意在一些低质量，内容跟自己内容无关的网站上获取大量链接，藉以提高排名。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="noopener">维基百科</a></li><li><a href="https://segmentfault.com/a/1190000002994538" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002994538</a></li></ol><h2 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h2><h3 id="什么是会话跟踪"><a href="#什么是会话跟踪" class="headerlink" title="什么是会话跟踪"></a>什么是会话跟踪</h3><p>会话跟踪技术是用于维持客户端和服务器端通信信息的技术</p><h3 id="引入会话跟踪的原因"><a href="#引入会话跟踪的原因" class="headerlink" title="引入会话跟踪的原因"></a>引入会话跟踪的原因</h3><p>HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户以及维持客户的上下文信息，会话跟踪技术就可以解决这个问题。</p><h3 id="Web中会话跟踪的方法有哪些"><a href="#Web中会话跟踪的方法有哪些" class="headerlink" title="Web中会话跟踪的方法有哪些"></a>Web中会话跟踪的方法有哪些</h3><ol><li>cookie</li><li>session</li><li>url重写：动态生成<code>sessionID</code>拼接在<code>url</code>上</li><li>隐藏的表单域</li><li>ip地址</li></ol><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://blog.csdn.net/qq_38363396/article/details/78289344" target="_blank" rel="noopener">https://blog.csdn.net/qq_38363396/article/details/78289344</a></li><li><a href="https://blog.csdn.net/qfs_v/article/details/2652119" target="_blank" rel="noopener">https://blog.csdn.net/qfs_v/article/details/2652119</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SEO&quot;&gt;&lt;a href=&quot;#SEO&quot; class=&quot;headerlink&quot; title=&quot;SEO&quot;&gt;&lt;/a&gt;SEO&lt;/h2&gt;&lt;h3 id=&quot;什么是SEO&quot;&gt;&lt;a href=&quot;#什么是SEO&quot; class=&quot;headerlink&quot; title=&quot;什么是SEO&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试之HTTP</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BHTTP.html"/>
    <id>http://yoursite.com/2019/05/05/面试之HTTP.html</id>
    <published>2019-05-05T14:28:49.000Z</published>
    <updated>2019-07-09T11:48:05.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h3><ol><li>一台服务器要与<code>HTTP 1.1</code>兼容、只要为资源实现<code>GET</code>和<code>HEAD</code>方法即可</li><li><code>GET</code>是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong></li><li><code>HEAD</code>与<code>GET</code>类似，但<strong>服务器在响应中只返回首部，不返回实体的主体部分</strong></li><li><code>PUT</code>让服务器<code>用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用这个主体替代它</code></li><li><code>POST</code>起初是用来向服务器输入数据的。实际上，通常会用它来支持<code>HTML</code>的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方</li><li><code>TRACE</code>会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个<code>TRACE</code>响应并在响应主体中携带它收到的原始请求报文。<code>TRACE</code>方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链</li><li><code>DELETE</code>请求服务器删除请求URL指定的资源</li></ol><h3 id="从浏览器地址输入URL到显示页面的步骤"><a href="#从浏览器地址输入URL到显示页面的步骤" class="headerlink" title="从浏览器地址输入URL到显示页面的步骤"></a>从浏览器地址输入URL到显示页面的步骤</h3><ol><li>在浏览器地址中输入URL</li><li>浏览器查看<code>缓存</code>，如果请求资源在缓存中并且没有过期，跳转到15<ol><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验是否过期，没有过期直接提供给客户端，否则与服务器进行验证。</li><li>检验资源是否过期通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ol><li><code>HTTP1.0</code>提供<code>Expires</code>，值为一个绝对时间表示缓存过期日期</li><li><code>HTTP1.1</code>增加了<code>Cache-Control: max-age=</code>，值为以秒为单位的最大过期时间</li></ol></li></ol></li><li>浏览器<strong>解析URL</strong>获取协议、主机、端口、path</li><li>浏览器<strong>组装一个HTTP请求报文</strong></li><li>浏览器<strong>获取主机ip地址</strong>，过程如下：<ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><strong>打开一个socket与目标IP地址、端口建立TCP连接</strong>，三次握手如下：<ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器返回<strong>SYN=1，ACK=X+1,Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1，Seq=Z</strong></li></ol></li><li>TCP连接建立后<strong>发送HTTP请求</strong></li><li>服务器接收请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li><li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>，如果验证缓存没过期，返回<code>304</code>等对应状态码</li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li><li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li><li>浏览器接收HTTP响应后，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong><ol><li>主动方发送<strong>Fin=1，Ack=Z，Seq=X</strong>报文</li><li>被动方发送<strong>ACK=X+1，Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1，ACK=X，Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y，Seq=X</strong>报文</li></ol></li><li>浏览器检查响应状态码：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应进行解码（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li><strong>解析HTML，构建DOM树，下载资源，构建CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li><li><strong>构建DOM树</strong><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li><li>构建<strong>CSSOM树</strong><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><strong>根据DOM树和CSSOM树构建渲染树</strong><ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见的节点包括<ol><li><code>script、meta</code>这样本身不可见的标签</li><li>被CSS隐藏的节点，如<code>display: none</code></li></ol></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><strong>js解析如下</strong><ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册时间处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到了设置<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readyState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档中出现的顺序执行</strong>，延迟脚本<strong>能访问完整DOM树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li></ol></li><li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;h3 id=&quot;HTTP-Method&quot;&gt;&lt;a href=&quot;#HTTP-Method&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>面试之Web安全</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BWeb%E5%AE%89%E5%85%A8.html"/>
    <id>http://yoursite.com/2019/05/05/面试之Web安全.html</id>
    <published>2019-05-05T14:28:31.000Z</published>
    <updated>2019-05-05T14:28:31.334Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之Web性能</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BWeb%E6%80%A7%E8%83%BD.html"/>
    <id>http://yoursite.com/2019/05/05/面试之Web性能.html</id>
    <published>2019-05-05T14:28:15.000Z</published>
    <updated>2019-05-05T14:28:15.672Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之Webpack</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BWebpack.html"/>
    <id>http://yoursite.com/2019/05/05/面试之Webpack.html</id>
    <published>2019-05-05T14:28:00.000Z</published>
    <updated>2019-05-05T14:28:00.846Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之Vue</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BVue.html"/>
    <id>http://yoursite.com/2019/05/05/面试之Vue.html</id>
    <published>2019-05-05T14:27:49.000Z</published>
    <updated>2019-06-18T13:32:21.128Z</updated>
    
    <content type="html"><![CDATA[<ol><li>定义Vue组件的方式<ol><li>单文件组件（Single File Component）</li><li>字符串模板（String Template）</li><li>渲染函数（Render Function）</li><li>JSX</li><li>vue-class-component</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;定义Vue组件的方式&lt;ol&gt;
&lt;li&gt;单文件组件（Single File Component）&lt;/li&gt;
&lt;li&gt;字符串模板（String Template）&lt;/li&gt;
&lt;li&gt;渲染函数（Render Function）&lt;/li&gt;
&lt;li&gt;JSX&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之HTML</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BHTML.html"/>
    <id>http://yoursite.com/2019/05/05/面试之HTML.html</id>
    <published>2019-05-05T14:27:30.000Z</published>
    <updated>2019-07-03T01:04:51.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web语义化"><a href="#Web语义化" class="headerlink" title="Web语义化"></a>Web语义化</h2><h3 id="什么是Web语义化"><a href="#什么是Web语义化" class="headerlink" title="什么是Web语义化"></a>什么是Web语义化</h3><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。</p><p>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</p><p>css命名的语义化是指：为html标签添加有意义的class，id，补充未表达的语义</p><h3 id="Web语义化的好处"><a href="#Web语义化的好处" class="headerlink" title="Web语义化的好处"></a>Web语义化的好处</h3><ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便于团队项目的可持续运作及维护</li></ul><h2 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h2><h3 id="doctype是什么"><a href="#doctype是什么" class="headerlink" title="doctype是什么"></a>doctype是什么</h3><p>文档类型说明，现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型</p><h3 id="doctype的特点"><a href="#doctype的特点" class="headerlink" title="doctype的特点"></a>doctype的特点</h3><ol><li><code>&lt;!doctype&gt;</code>声明不是一个<code>HTML</code>标签，是一个用于告诉浏览器当前<code>HTML</code>版本的指令</li><li><code>&lt;!doctype&gt;</code>声明必须处<code>于HTML</code>文档的头部，在<code>&lt;html&gt;</code>标签之前，<code>HTML5</code>中不区分大小写</li><li>在<code>HTML4.01</code>中<code>&lt;!doctype&gt;</code>声明指向一个<code>DTD</code>(Document Type Definition，文档类型定义)，由于<code>HTML4.01</code>基于<code>SGML</code>(Standard Generalized Markup Language，标准通用标记语言)，所以<code>DTD</code>指定了标记规则以保证浏览器正确渲染内容</li><li><code>HTML5</code>不基于<code>SGML</code>，所以不用指定<code>DTD</code></li></ol><h3 id="常见的doctype"><a href="#常见的doctype" class="headerlink" title="常见的doctype"></a>常见的doctype</h3><ol><li>HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></li><li>HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></li><li>HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “<a href="http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</a></li><li>XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></li><li>XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></li><li>XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</a></li><li>HTML 5: &lt;!doctype html&gt;</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">DTD</a></li><li><a href="https://zh.wikipedia.org/wiki/SGML" target="_blank" rel="noopener">SGML</a></li></ol><h2 id="HTML全局属性有哪些"><a href="#HTML全局属性有哪些" class="headerlink" title="HTML全局属性有哪些"></a>HTML全局属性有哪些</h2><ul><li>accesskey:设置快捷键，提供快速访问元素如<code>&lt;a href=&quot;#&quot; accesskey=&quot;a&quot;</code>在windows下的firefox中按alt + shift + a可激活元素</li><li>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li><li>contenteditable: 指定元素内容是否可编辑</li><li>contextmenu: 自定义鼠标右键弹出菜单内容</li><li>data-*: 为元素增加自定义属性</li><li>dir: 设置元素文本方向</li><li>draggable: 设置元素是否可拖拽</li><li>dropzone: 设置元素拖放类型： copy, move, link</li><li>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li><li>id: 元素id，文档内唯一</li><li>lang: 元素内容的的语言</li><li>spellcheck: 是否启动拼写和语法检查</li><li>style: 行内css样式</li><li>tabindex: 设置元素可以获得焦点，通过tab可以导航</li><li>title: 元素相关的建议信息</li><li>translate: 元素和子孙节点内容是否需要本地化</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">MDN</a></li></ol><h2 id="lt-img-gt-的title和alt有什么区别"><a href="#lt-img-gt-的title和alt有什么区别" class="headerlink" title="&lt;img&gt;的title和alt有什么区别"></a>&lt;img&gt;的title和alt有什么区别</h2><ol><li><code>title</code>是<code>global attributes</code>之一，用于为元素提供附加的<code>advisory information</code>。当鼠标滑动到元素上的时候显示。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ol><h2 id="什么是渐进增强"><a href="#什么是渐进增强" class="headerlink" title="什么是渐进增强"></a>什么是渐进增强</h2><p>渐进增强是指在<code>Web</code>设计时强调可访问性、语义化<code>HTML</code>标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高宽带用户提供更好的用户体验。核心原则如下：</p><ol><li>所有浏览器都必须能访问基本内容</li><li>所有浏览器都必须能使用基本功能</li><li>所有内容都包含在语义化的标签中</li><li>通过外部<code>CSS</code>提供增强的布局</li><li>通过非侵入式、外部<code>javascript</code>提供增强功能</li><li>end-user web browser preferences are respected</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web语义化&quot;&gt;&lt;a href=&quot;#Web语义化&quot; class=&quot;headerlink&quot; title=&quot;Web语义化&quot;&gt;&lt;/a&gt;Web语义化&lt;/h2&gt;&lt;h3 id=&quot;什么是Web语义化&quot;&gt;&lt;a href=&quot;#什么是Web语义化&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>面试之CSS</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BCSS.html"/>
    <id>http://yoursite.com/2019/05/05/面试之CSS.html</id>
    <published>2019-05-05T14:27:17.000Z</published>
    <updated>2019-05-05T14:27:17.667Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之JavaScript</title>
    <link href="http://yoursite.com/2019/05/05/%E9%9D%A2%E8%AF%95%E4%B9%8BJavaScript.html"/>
    <id>http://yoursite.com/2019/05/05/面试之JavaScript.html</id>
    <published>2019-05-05T14:27:07.000Z</published>
    <updated>2019-05-06T14:45:04.922Z</updated>
    
    <content type="html"><![CDATA[<p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;

      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>webpack加载动态图片</title>
    <link href="http://yoursite.com/2019/04/22/webpack%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%9B%BE%E7%89%87.html"/>
    <id>http://yoursite.com/2019/04/22/webpack加载动态图片.html</id>
    <published>2019-04-22T08:29:06.000Z</published>
    <updated>2019-04-22T09:26:36.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在基于Webpack的项目中，我们加载图片有以下三种方式：</p><ol><li>使用<code>img</code>标签的<code>src</code>属性</li><li>使用<code>css</code>的<code>background-image</code></li><li>使用<code>require</code>或者<code>import</code>导入图片模块</li></ol><p>以上3中方式配合<code>url-loader</code>和<code>file-loader</code>我们可以很轻易对图片进行处理，例如：</p><ol><li>为图片增加<code>hash</code></li><li>处理图片<code>url</code>，为其增加<code>assetsPublicPath</code>，把相对路径转化为绝对路径</li></ol><p>然而在一些情况下，我们无可避免的需要利用<code>js</code>来控制加载图片，例如：我们要加载<code>list-1、list-2、...list-10</code> 10张图片，有可能你会这么做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 在vue中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-for</span>=<span class="string">"index in 10"</span> <span class="attr">:src</span>=<span class="string">"`../assets/imgs/list-$&#123; index + 1 &#125;.png`"</span> <span class="attr">:key</span>=<span class="string">"index"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但这么做是存在问题的，<code>webpack</code>构建时采用的是静态分析，它不会导入包含变量的文件并对其进行解析，上面代码将导致如下结果：</p><ol><li>打包出来的图片目录根本没有<code>list</code>图片，因为<code>webpack</code>会认为你没有导入这些文件，就不会将其输出到打包目录中</li><li>图片链接没有进行<code>hash</code>、<code>assetsPublicPath</code>处理</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对如上问题，我们有两种解决方案：</p><ol><li>将图片放到<code>static</code>目录，不经过<code>webpack</code>处理，采用绝对路径引入，但是这样就无法进行<code>hash</code>处理了，而且对于<code>html</code>放在后端的应用而言，图片的<code>host</code>还需要进行额外处理</li><li><p>动态加载图片，如下：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="built_in">require</span>(<span class="string">`../assets/imgs/list-<span class="subst">$&#123; i &#125;</span>.png`</span>)</span><br><span class="line">    imgList.push(img)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里要注意几个问题，<code>require</code>的参数不能完全为一个变量，需要将其定位到某一个目录内，例如，如下方式都将导致<code>can&#39;t find module</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1 fail</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveUrl</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'../assets/imgs/'</span> + filename</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'list-1.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2 fail</span></span><br><span class="line"><span class="keyword">const</span> imgUrl = <span class="string">'../assets/imgs/list-1.png'</span></span><br><span class="line"><span class="built_in">require</span>(imgUrl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3 fail</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">'../assets/imgs/'</span></span><br><span class="line"><span class="built_in">require</span>(path + <span class="string">'list-1.png'</span>)</span><br></pre></td></tr></table></figure><p>必须在字符串中将其定义到某个具体目录，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// success</span></span><br><span class="line"><span class="keyword">const</span> imgName = <span class="string">'imgs/list-1.png'</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'../assets/'</span> + imgName)</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/webpack/webpack/issues/6680" target="_blank" rel="noopener">https://github.com/webpack/webpack/issues/6680</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在基于Webpack的项目中，我们加载图片有以下三种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;img&lt;/code&gt;标签的&lt;code&gt;
      
    
    </summary>
    
      <category term="打包工具" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="loading images" scheme="http://yoursite.com/tags/loading-images/"/>
    
  </entry>
  
  <entry>
    <title>渲染函数的观察者与进阶的数据响应系统</title>
    <link href="http://yoursite.com/2019/04/15/%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E4%B8%8E%E8%BF%9B%E9%98%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://yoursite.com/2019/04/15/渲染函数的观察者与进阶的数据响应系统.html</id>
    <published>2019-04-15T14:41:37.000Z</published>
    <updated>2019-05-05T07:14:33.298Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要以<code>Vue.prototype._init</code>函数为切入点来详细的讲解<code>Dep</code>和<code>Watcher</code>的作用。我们在上一节<a href="/2019/04/05/揭开数据响应系统的面纱.html">揭开数据响应系统的面纱</a>中只是假设的认为<code>dep.depend()</code>收集了依赖，<code>dep.notify()</code>触发了依赖，并没有讲解其具体的实现。除此之外，正是因为<code>Watcher</code>对所观察字段的求值才触发了字段的<code>get</code>，从而才有收集到该观察者的机会。</p><h2 id="mount-挂载函数"><a href="#mount-挂载函数" class="headerlink" title="\$mount 挂载函数"></a>\$mount 挂载函数</h2><p>打开<code>src/core/instance/init.js</code>文件，并找到<code>Vue.prototype._init</code>函数，如下所示：</p><figure class="highlight javascript"><figcaption><span>Vue.prototype._init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的最后一句，调用<code>vm.$mount</code>方法将组件挂载到固定的元素，而<code>vm.$mount</code>方法分别在两处进行了定义：</p><ol><li><p><code>platforms/web/runtime/index.js</code>，即运行时版<code>Vue</code>的入口文件：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果<code>el</code>选项存在且当前处于浏览器环境中，则调用<code>query</code>方法获取<code>el</code>选项对应的<code>DOM</code>元素，如果不存在则手动创建一个<code>div</code>，然后返回<code>DOM</code>元素复写<code>el</code>变量，最后调用<code>mountComponent</code>进行真正的挂载操作</p></li><li><p><code>src/platforms/web/entry-runtime-with-compiler.js</code>，即完整版<code>Vue</code>的入口文件：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(<span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">    <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.template</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">                    template = idToTemplate(template)</span><br><span class="line">                    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">                    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        warn(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="keyword">this</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">                template = template.innerHTML</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                    warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = getOuterHTML(el)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">                mark(<span class="string">'compile'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">                template,</span><br><span class="line">                &#123;</span><br><span class="line">                    outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">                    shouldDecodeNewlines,</span><br><span class="line">                    shouldDecodeNewlinesForHref,</span><br><span class="line">                    delimiters: options.delimiters,</span><br><span class="line">                    comments: options.comments</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">            options.render = render</span><br><span class="line">            options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">                mark(<span class="string">'compile end'</span>)</span><br><span class="line">                measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 完整版的<code>Vue</code>只是在运行版的基础上增加了模板编译的能力（把<code>template</code>或者<code>el</code>选项对应的<code>html</code>模板编译成<strong>渲染函数</strong>），其主要逻辑为：</p><ol><li>如果<code>template</code>选项不存在，则使用<code>el</code>元素的<code>outerHTML</code>作为模板内容</li><li><p>如果<code>template</code>选项存在：</p><ul><li>且<code>template</code>的类型是字符串<ul><li>如果第一个字符是<code>#</code>，那么会把改字符作为<code>css</code>选择符去选中对应的元素，并把该元素的<code>innerHTML</code>作为模板</li><li>如果第一个字符不是<code>#</code>，那么什么都不做，就用<code>template</code>自身的字符串作为模板值</li></ul></li><li>且<code>template</code>的类型是元素节点（<code>template.nodeType</code>存在）<ul><li>则使用该元素的<code>innerHTML</code>作为模板</li></ul></li><li>若<code>template</code>既不是字符串又不是元素节点，那么在非生产环境会提示开发者传递的<code>template</code>选项无效</li></ul><p>然后对上述处理后的<code>template</code>选项进行了判断，如果不为空，调用<code>compileToFunctions</code>将字符串编译为渲染函数</p></li></ol></li></ol><h2 id="渲染函数的观察者"><a href="#渲染函数的观察者" class="headerlink" title="渲染函数的观察者"></a>渲染函数的观察者</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm: Component, el: ?Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    vm.$el = el</span><br><span class="line">    <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">        vm.$options.render = createEmptyVNode</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) || vm.$options.el || el) &#123;</span><br><span class="line">                warn(</span><br><span class="line">                    <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">                        <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">                        <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">                    vm</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                warn(<span class="string">'Failed to mount component: template or render function not defined.'</span>, vm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> updateComponent</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> name = vm._name</span><br><span class="line">            <span class="keyword">const</span> id = vm._uid</span><br><span class="line">            <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">            <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">            mark(startTag)</span><br><span class="line">            <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">            mark(endTag)</span><br><span class="line">            measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">            mark(startTag)</span><br><span class="line">            vm._update(vnode, hydrating)</span><br><span class="line">            mark(endTag)</span><br><span class="line">            measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            vm._update(vm._render(), hydrating)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">    <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">    <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        updateComponent,</span><br><span class="line">        noop,</span><br><span class="line">        &#123;</span><br><span class="line">            before() &#123;</span><br><span class="line">                <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">                    callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">    )</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">    <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        vm._isMounted = <span class="literal">true</span></span><br><span class="line">        callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先判断了<code>vm.$options.render</code>函数是否存在，如果不存在，则把<code>createEmptyVNode</code>函数赋给<code>vm.$options.render</code>，其作用是渲染一个空的<code>vnode</code>对象</li><li>触发<code>beforeMount</code>生命周期钩子</li><li>定义并初始化<code>updateComponent</code>函数，该函数的作用是以<code>vm._render()</code>的返回值作为一个参数调用<code>vm._update</code>函数，第二个参数<code>hydrating</code>是<code>patch</code>算法，这里可以简单的认为<code>vm._render</code>与<code>vm._update</code>的作用如下：<ul><li><code>vm._render</code>函数的作用是调用<code>vm.$options.render</code>函数并返回生成的虚拟节点（<code>vnode</code>）</li><li><code>vm_update</code>函数的作用是把<code>vm._render</code>函数生成的虚拟节点渲染成真实的<code>DOM</code></li></ul></li><li>实例化<code>Watcher</code>对象</li></ol><p>我们知道，正是因为<code>Watcher</code>对表达式的求值，触发了数据属性的<code>get</code>拦截器函数，从而收集到了依赖，当数据变化时能够触发收集的依赖。在上面的<code>Watcher</code>实例中，会对<code>updateComponent</code>函数进行求值，从而间接的触发渲染函数<code>vm.$options.render</code>的执行，而渲染函数的执行会触发数据属性的的<code>get</code>拦截器函数，从而将依赖（<code>观察者</code>）收集，当数据变化时将重新执行<code>updateComponent</code>函数，这就完成了重新渲染。同时我们把上面代码中实例化的观察者对象称为<code>渲染函数的观察者</code>。</p><h2 id="初识-Watcher"><a href="#初识-Watcher" class="headerlink" title="初识 Watcher"></a>初识 Watcher</h2><p>接下来我们就以渲染函数的观察者对象为例，顺着脉络了解<code>Watcher</code>类，<code>Watcher</code>类定义在<code>src/core/observer/watcher.js</code>中，如下是<code>Watcher</code>类的全部内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    vm: Component</span><br><span class="line">    expression: string</span><br><span class="line">    cb: <span class="built_in">Function</span></span><br><span class="line">    id: number</span><br><span class="line">    deep: boolean</span><br><span class="line">    user: boolean</span><br><span class="line">    lazy: boolean</span><br><span class="line">    sync: boolean</span><br><span class="line">    dirty: boolean</span><br><span class="line">    active: boolean</span><br><span class="line">    deps: <span class="built_in">Array</span>&lt;Dep&gt;</span><br><span class="line">    newDeps: <span class="built_in">Array</span>&lt;Dep&gt;</span><br><span class="line">    depIds: SimpleSet</span><br><span class="line">    newDepIds: SimpleSet</span><br><span class="line">    before: ?<span class="built_in">Function</span></span><br><span class="line">    getter: <span class="built_in">Function</span></span><br><span class="line">    value: any</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        <span class="comment">// 如果是渲染函数的观察者，这赋值给组件实例的_watcher属性，所有每个组件实例的_watcher属性指向的都是该实例的渲染函数的观察者</span></span><br><span class="line">        <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">            vm._watcher = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组件实例的_watchers属性包含了该组件实例的所有的观察者</span></span><br><span class="line">        vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// options</span></span><br><span class="line">        <span class="keyword">if</span> (options) &#123;</span><br><span class="line">            <span class="comment">// 用来告诉当前观察者实例对象是否是深度观测</span></span><br><span class="line">            <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">            <span class="comment">// 用来标识当前观察者实例对象是 开发者定义的 还是 内部定义的</span></span><br><span class="line">            <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">            <span class="comment">// 用来标识当前观察者实例对象是否是计算属性的观察者，惰性求值 === 计算属性的观察者</span></span><br><span class="line">            <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">            <span class="comment">// 用来告诉观察者当数据变化时是否同步求值并执行回调</span></span><br><span class="line">            <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">            <span class="comment">// 可以理解为 Watcher 实例的钩子，当数据变化之后，触发更新之前，调用在创建渲染函数的观察者实例对象时传递的 before 选项</span></span><br><span class="line">            <span class="keyword">this</span>.before = options.before</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">        <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">        <span class="keyword">this</span>.deps = []</span><br><span class="line">        <span class="keyword">this</span>.newDeps = []</span><br><span class="line">        <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span> ? expOrFn.toString() : <span class="string">''</span></span><br><span class="line">        <span class="comment">// parse expression for getter</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// this.$watch('b.a', function () &#123;&#125;) 此时 expOrFn = 'b.a'</span></span><br><span class="line">            <span class="comment">// 如果expOrFn 包含字母 . $之外的符号 则 parsePath 返回undefined 否则</span></span><br><span class="line">            <span class="comment">// 返回一个新函数 新函数接收一个obj参数 其作用是触发b.a的get拦截器函数 并返回b.a的值</span></span><br><span class="line">            <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getter = noop</span><br><span class="line">                process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">                    warn(<span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> + <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> + <span class="string">'For full control, use a function instead.'</span>, vm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.value 保存着被观察的目标的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集依赖&amp;求值</span></span><br><span class="line"><span class="comment">     * 触发访问器属性的 get 方法，返回被观察的目标的值</span></span><br><span class="line"><span class="comment">     * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="comment">// 设置 Dep.target 为当前观察者实例</span></span><br><span class="line">        pushTarget(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">let</span> value</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 触发过程 被观察目标的 get 拦截器函数 -&gt; dep.depend() -&gt; Dep.target.addDep(dep)</span></span><br><span class="line">            value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">                handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">            <span class="comment">// dependencies for deep watching</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">                traverse(value)</span><br><span class="line">            &#125;</span><br><span class="line">            popTarget()</span><br><span class="line">            <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addDep(dep: Dep) &#123;</span><br><span class="line">        <span class="keyword">const</span> id = dep.id</span><br><span class="line">        <span class="comment">// 避免在 一次求值过程中 重复收集依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">            <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">            <span class="comment">// 避免在 多次求值过程中 重复收集依赖</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">                <span class="comment">// 收集观察者 观察者被添加到 dep.subs 数组中</span></span><br><span class="line">                dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cleanupDeps() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">                <span class="comment">// 移除废弃的观察者</span></span><br><span class="line">                dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空 newDepIds 和 new Deps 并赋给 depIds 和 newDeps</span></span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">        <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">        <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">        <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">        tmp = <span class="keyword">this</span>.deps</span><br><span class="line">        <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">        <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">        <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发过程 被观察目标的 set 拦截器函数 -&gt; dep.notify() -&gt; 虚幻遍历 dep.subs数组 调用dep.subs[i].update</span></span><br><span class="line"><span class="comment">     * Subscriber interface.</span></span><br><span class="line"><span class="comment">     * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">            <span class="comment">// 同步执行</span></span><br><span class="line">            <span class="keyword">this</span>.run()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 放到异步队列执行</span></span><br><span class="line">            queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Scheduler job interface.</span></span><br><span class="line"><span class="comment">     * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">            <span class="comment">// 重新求值</span></span><br><span class="line">            <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                value !== <span class="keyword">this</span>.value ||</span><br><span class="line">                <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">                <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">                <span class="comment">// have mutated.</span></span><br><span class="line">                isObject(value) ||</span><br><span class="line">                <span class="keyword">this</span>.deep</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// set new value</span></span><br><span class="line">                <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">                <span class="keyword">this</span>.value = value</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">     * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    evaluate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    teardown() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">            <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">            <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">            <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">                remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">            <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">                <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>queueWatcher</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler's state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    index = queue.length = activatedChildren.length = <span class="number">0</span></span><br><span class="line">    has = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        circular = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async edge case #6566 requires saving the timestamp when event listeners are</span></span><br><span class="line"><span class="comment">// attached. However, calling performance.now() has a perf overhead especially</span></span><br><span class="line"><span class="comment">// if the page has thousands of event listeners. Instead, we take a timestamp</span></span><br><span class="line"><span class="comment">// every time the scheduler flushes and use that for all event listeners</span></span><br><span class="line"><span class="comment">// attached during that flush.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> currentFlushTimestamp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Async edge case fix requires storing an event listener's attach timestamp.</span></span><br><span class="line"><span class="keyword">let</span> getNow: <span class="function"><span class="params">()</span> =&gt;</span> number = <span class="built_in">Date</span>.now</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine what event timestamp the browser is using. Annoyingly, the</span></span><br><span class="line"><span class="comment">// timestamp can either be hi-res (relative to page load) or low-res</span></span><br><span class="line"><span class="comment">// (relative to UNIX epoch), so in order to compare time we have to use the</span></span><br><span class="line"><span class="comment">// same timestamp type when saving the flush timestamp.</span></span><br><span class="line"><span class="keyword">if</span> (inBrowser &amp;&amp; getNow() &gt; <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>).timeStamp) &#123;</span><br><span class="line">    <span class="comment">// if the low-res timestamp which is bigger than the event timestamp</span></span><br><span class="line">    <span class="comment">// (which is evaluated AFTER) it means the event is using a hi-res timestamp,</span></span><br><span class="line">    <span class="comment">// and we need to use the hi-res version for event listeners as well.</span></span><br><span class="line">    getNow = <span class="function"><span class="params">()</span> =&gt;</span> performance.now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    currentFlushTimestamp = getNow()</span><br><span class="line">    flushing = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort queue before flush.</span></span><br><span class="line">    <span class="comment">// This ensures that:</span></span><br><span class="line">    <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">    <span class="comment">//    created before the child)</span></span><br><span class="line">    <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">    <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">    <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">    <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">    queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">    <span class="comment">// as we run existing watchers</span></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">        watcher = queue[index]</span><br><span class="line">        <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">            watcher.before()</span><br><span class="line">        &#125;</span><br><span class="line">        id = watcher.id</span><br><span class="line">        has[id] = <span class="literal">null</span></span><br><span class="line">        watcher.run()</span><br><span class="line">        <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">            circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">                warn(<span class="string">'You may have an infinite update loop '</span> + (watcher.user ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span> : <span class="string">`in a component render function.`</span>), watcher.vm)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">    <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">    <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">    resetSchedulerState()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">    callActivatedHooks(activatedQueue)</span><br><span class="line">    callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// devtool hook</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">        devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span>(<span class="params">queue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = queue.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> watcher = queue[i]</span><br><span class="line">        <span class="keyword">const</span> vm = watcher.vm</span><br><span class="line">        <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">            callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue a kept-alive component that was activated during patch.</span></span><br><span class="line"><span class="comment"> * The queue will be processed after the entire tree has been patched.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueActivatedComponent</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// setting _inactive to false here so that a render function can</span></span><br><span class="line">    <span class="comment">// rely on checking whether it's in an inactive tree (e.g. router-view)</span></span><br><span class="line">    vm._inactive = <span class="literal">false</span></span><br><span class="line">    activatedChildren.push(vm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callActivatedHooks</span>(<span class="params">queue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">        queue[i]._inactive = <span class="literal">true</span></span><br><span class="line">        activateChildComponent(queue[i], <span class="literal">true</span> <span class="comment">/* true */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = watcher.id</span><br><span class="line">    <span class="comment">// 避免相同的观察者重复入队</span></span><br><span class="line">    <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">        has[id] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 判断队列中的事件是否处于执行中</span></span><br><span class="line">        <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">            <span class="comment">// 如果不处于执行中，将 观察者 添加到队列末尾</span></span><br><span class="line">            queue.push(watcher)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">            <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">            <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">            queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只能存在一个异步事件</span></span><br><span class="line">        <span class="comment">// queue the flush</span></span><br><span class="line">        <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">            waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">                flushSchedulerQueue()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            nextTick(flushSchedulerQueue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>nextTick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        p.then(flushCallbacks)</span><br><span class="line">        <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">        <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">        <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">        <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">        <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">        <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    !isIE &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">    (isNative(MutationObserver) ||</span><br><span class="line">        <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">        MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">    <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">        characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">    <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">    <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">    <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setImmediate(flushCallbacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.call(ctx)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">            _resolve(ctx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span></span><br><span class="line">        timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            _resolve = resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节主要以&lt;code&gt;Vue.prototype._init&lt;/code&gt;函数为切入点来详细的讲解&lt;code&gt;Dep&lt;/code&gt;和&lt;code&gt;Watcher&lt;/code&gt;的作用。我们在上一节&lt;a href=&quot;/2019/04/05/揭开数据响应系统的面纱.html&quot;&gt;揭开
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
</feed>
