<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WgCg Blog</title>
  
  <subtitle>Keep Learning and Never Give Up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-15T14:41:37.307Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cong.Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渲染函数的观察者与进阶的数据响应系统</title>
    <link href="http://yoursite.com/2019/04/15/%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E4%B8%8E%E8%BF%9B%E9%98%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://yoursite.com/2019/04/15/渲染函数的观察者与进阶的数据响应系统.html</id>
    <published>2019-04-15T14:41:37.000Z</published>
    <updated>2019-04-15T14:41:37.307Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>揭开数据响应系统的面纱</title>
    <link href="http://yoursite.com/2019/04/05/%E6%8F%AD%E5%BC%80%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9D%A2%E7%BA%B1.html"/>
    <id>http://yoursite.com/2019/04/05/揭开数据响应系统的面纱.html</id>
    <published>2019-04-05T09:01:48.000Z</published>
    <updated>2019-04-15T14:42:25.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li>优先级关系：props &gt; data &gt; methods：即已经在<code>props</code>中定义的<code>key</code>不允许出现在<code>data</code>与<code>methods</code>中，已经在<code>data</code>中定义的<code>key</code>不允许出现在<code>methods</code>中</li><li><code>vm</code>代理了<code>vm._data</code>对象，<code>vm._data</code>对象是通过<code>vm.$options.data()</code>得到的，即访问<code>vm.a</code>等于访问<code>vm._data.a</code>，对应到源码中<code>src/core/instance/state.js</code>中的<code>proxy</code>方法</li></ol><h2 id="响应式数据处理"><a href="#响应式数据处理" class="headerlink" title="响应式数据处理"></a>响应式数据处理</h2><p>本节主要针对<code>src/core/instance/state.js</code>中的<code>initData</code>方法最后一句<code>observe(data, true)</code>的执行逻辑进行说明</p><p><code>observe</code>方法具体的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">    <span class="comment">// 如果value上有__ob__属性且是Observer实例，说明该对象已经被观测</span></span><br><span class="line">    <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">        ob = value.__ob__</span><br><span class="line">    <span class="comment">// shouldObserve控制是否允许观测的开关</span></span><br><span class="line">    <span class="comment">// isServerRendering 判断是否是服务端渲染</span></span><br><span class="line">    <span class="comment">// Array.isArray(value) || isPlainObject(value) 判断是否是数组或纯对象</span></span><br><span class="line">    <span class="comment">// Object.isExtensible(value) 判断是否是可扩展的</span></span><br><span class="line">    <span class="comment">// !value._isVue 判断是否是Vue实例</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        shouldObserve &amp;&amp;</span><br><span class="line">        !isServerRendering() &amp;&amp;</span><br><span class="line">        (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">        <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">        !value._isVue</span><br><span class="line">    ) &#123;</span><br><span class="line">        ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">        ob.vmCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Observer</code>（观察者类）定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    value: any   <span class="comment">// 要观察的对象本身的引用</span></span><br><span class="line">    dep: Dep <span class="comment">// 依赖实例，用于收集依赖，为了使Vue.set和Vue.delete能够监听对象和数组属性的添加和删除等</span></span><br><span class="line">    vmCount: number <span class="comment">// 除非是根数据，即vm.data，其值大于0，否则等于0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">        <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">        def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">                protoAugment(value, arrayMethods)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj, keys[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>constructor</code>做的事情：</p><ol><li>初始化数据：<code>value</code>引用数据对象本身、<code>dep</code>为<code>Dep</code>类的实例（用于<code>Vue.set &amp; Vue.delete</code>实现对象或数组的添加、删除操作）、初始化<code>vmCount</code>的值为0（如果是根数据在<code>observe</code>函数中对<code>vmCount</code>进行了自加1，说明只有根数据即<code>vm.data</code>本身的<code>vmCount</code>会大于0）</li><li>往数据对象上添加了<code>__ob__</code>属性，其值为当前<code>Observer</code>实例</li><li><p>判断数据对象是否是数组</p><p>如果是数组，判断浏览器是否支持<code>__proto__</code>属性</p><ul><li><p>如果支持，利用原型链，使<code>value.__proto__</code>属性指向<code>arrMethods</code>，<code>arrMethods</code>是用以<code>Array.prototype</code>为原型创建的对象，其对数组的变异方法（即能修改自身值得方法）进行了重写，这样当使用数组的变异方法时，就会查找原型链，查找到<code>arrMethods</code>对象上定义的方法，在这些方法中我们就能进行<strong>依赖收集</strong>与<strong>事件发布</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line">protoAugment(value, arrayMethods)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">    target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/array.js</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">    <span class="string">'push'</span>,</span><br><span class="line">    <span class="string">'pop'</span>,</span><br><span class="line">    <span class="string">'shift'</span>,</span><br><span class="line">    <span class="string">'unshift'</span>,</span><br><span class="line">    <span class="string">'splice'</span>,</span><br><span class="line">    <span class="string">'sort'</span>,</span><br><span class="line">    <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cache original method</span></span><br><span class="line">    <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">        <span class="keyword">let</span> inserted</span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">                inserted = args</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">                inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// inserted的值为往数组中添加的元素，其作用是用于确定当前数组的操作为添加操作，当添加一个新的元素后，要确保对新的元素进行了观测，所以当存在inserted时，调用当前数组的`__ob__`对象的observeArray方法</span></span><br><span class="line">        <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">        <span class="comment">// notify change</span></span><br><span class="line">        ob.dep.notify()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// src/core/observer/index.js Observer.observeArray：该方法的作用是循环数组，对数组中的每一项进行观测</span></span><br><span class="line">    observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果不支持<code>__proto__</code>方法，则直接把重写的<strong>变异数组</strong>方法添加到数据对象本身上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class="line"></span><br><span class="line">copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        def(target, key, src[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是数组（即对象），则调用<code>Observer</code>的<code>walk</code>方法，遍历对象上的属性，调用<code>defineReactive</code>方法，对每一个属性进行观测</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defineReactive</code>定义在<code>src/core/observer/index.js</code>中</p><figure class="highlight javascript"><figcaption><span>defineReactive</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性的描述信息</span></span><br><span class="line">    <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">    <span class="comment">// 如果该属性是不可配置的，则没必要也无法进行观测，因为要实现观测必须修改属性的`get`和`set`方法</span></span><br><span class="line">    <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存原来的geeter和setter</span></span><br><span class="line">    <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">    <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先要明确的一点是，如果if中的代码不执行，那么val的值有可能为undefined，则这时候下方的深度观测语句`let childOb = !shallow &amp;&amp; observe(val)`中的val为undefined，即不会进行深度观测</span></span><br><span class="line">    <span class="comment">// !getter &amp;&amp; arguments.length == 2：如果属性本身存在着`getter`函数，在这里是不希望触发用户所写的`getter`函数的，所以当属性本身不存在`getter`函数时，再获取其值，而付出的代价是如果存在`getters`函数不会进行深度观测</span></span><br><span class="line">    <span class="comment">// !getter || setter：如果不加setter的判断，当第一次观测之后且是深度观测之后，属性上有了下方代码添加的`getter`函数，这时候将属性值赋予一个新的对象，则时候对象上有`getter`函数，造成的结果就是不会进行深度观测，这跟之前的深度观测是相违背的，所以加上setter是否存在的判断</span></span><br><span class="line">    <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">        val = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行深度观测，可以把shallow看做一个控制深度观测的开关</span></span><br><span class="line">    <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖收集&amp;事件发布</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 利用闭包，保留对getter的引用，如果存在getter，则调用getter获取其值，否则为val</span></span><br><span class="line">            <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">            <span class="comment">// Dep.target为要收集的依赖</span></span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                <span class="comment">// 收集依赖</span></span><br><span class="line">                dep.depend()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果子对象也是观测对象</span></span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    <span class="comment">// 收集依赖，因为当一个事件依赖一个对象后，则相当于这个事件也依赖于其子对象，因为修改了子对象，其父对象也变了，这样当修改子对象是，才能正确的发布事件</span></span><br><span class="line">                    childOb.dep.depend()</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                        <span class="comment">// 如果是数组，则递归调用dependArray进行依赖收集</span></span><br><span class="line">                        dependArray(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">            <span class="comment">// 如果数据没有发生改变，或者之前为NaN改变之后也为NaN（我们都知道NaN !== NaN），则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// customSetter：允许在非生产环境进行监听时提供一个函数为参数作为拦截，例如不允许修改内置的属性时会提示错误信息</span></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">                customSetter()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">            <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果本身存在setter，则调用本身提供的setter进行赋值</span></span><br><span class="line">            <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">                setter.call(obj, newVal)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 深度观测</span></span><br><span class="line">            childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 事件发布</span></span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">        e = value[i]</span><br><span class="line">        e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">            dependArray(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>下一章：<a href="/2019/04/15/渲染函数的观察者与进阶的数据响应系统.html">渲染函数的观察者与进阶的数据响应系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;优先级关系：props &amp;gt; data &amp;gt; methods：即已经在&lt;code&gt;props&lt;/code&gt;中定义的&lt;co
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue的初始化之开篇</title>
    <link href="http://yoursite.com/2019/03/28/Vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%BC%80%E7%AF%87.html"/>
    <id>http://yoursite.com/2019/03/28/Vue的初始化之开篇.html</id>
    <published>2019-03-28T05:40:28.000Z</published>
    <updated>2019-04-15T09:10:42.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用于初始化的最终选项-options"><a href="#用于初始化的最终选项-options" class="headerlink" title="用于初始化的最终选项\$options"></a>用于初始化的最终选项\$options</h1><p>在<a href="/2019/03/21/以一个例子为线索">以一个例子为线索</a>一节中，我们写了一个很简单的例子，这个例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们以这个例子为线索开始了对<code>Vue</code>代码的讲解，我们知道了在实例化<code>Vue</code>实例的时候，<code>Vue.prototype._init</code>方法被第一个执行，这个方法定义在<code>src/core/instance/init.js</code>文件中，在分析<code>_init</code>方法的时候我们遇到了下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm)</span><br></pre></td></tr></table></figure><p>正式因为上面的代码，使得我们花了大篇章来讲其内部实现和运作，也就是<a href="/2019/03/26/Vue选项的规范化">Vue 选项的规范化</a>和<a href="/2019/03/27/Vue选项的合并">Vue 选项的合并</a>这两节所介绍的内容。现在我们已经知道了<code>mergeOptions</code>函数是如何对父子选项进行合并处理的，也知道了它的作用。</p><p>我们打开<code>core/util/options.js</code>文件，找到<code>mergeOptions</code>函数，看其最后一句代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure><p>这说明<code>mergeOptions</code>函数最终将合并处理后的选项返回，并以该返回值作为<code>vm.$options</code>的值。<code>vm.$options</code>在<code>Vue</code>的官方文档中是可以找到的，它作为实例属性暴露给开发者，那么现在你应该知道<code>vm.$options</code>到底是什么了。并且看文档的时候你应该更能够理解其作用，比如官方文档是这样介绍<code>$options</code>实例属性的：</p><blockquote><p>用于当前<code>Vue</code>实例的初始化选项。需要在选项中包含自定义属性时会有用处</p></blockquote><p>并且给了一个例子，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    customOptions: <span class="string">'foo'</span>,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的例子中，在创建<code>Vue实例</code>的时候传递了一个自定义选项：<code>customOption</code>,在之后的代码中我们可以通过<code>this.$options.customOption</code>进行访问。原理其实就是使用<code>mergeOptions</code>函数对自定义选项进行合并处理，由于没有指定<code>customOption</code>选项的合并策略，所以将会使用默认的策略函数<code>defaultStrat</code>。最终效果就是你初始化的值是什么，得到的就是什么。</p><p>另外，<code>Vue</code>也提供了<code>Vue.config.optionMergeStrategies</code>全局配置，用来指定某一个选项的合并策略，常用于指定自定义选项的合并策略，具体请查看<a href="https://cn.vuejs.org/v2/api/index.html#optionMergeStrategies" target="_blank" rel="noopener">optionMergeStrategies 用法</a></p><p>现在我们回到正题上，还是拿我们的例子，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个时候<code>mergeOptions</code>函数将会把<code>Vue.options</code>作为父选项，把我们传递的实例选项作为子选项进行合并，合并的结果我们可以通过打印<code>$options</code>属性得知。其实我们前面已经分析过了，<code>el</code>选项将使用默认合并策略合并，最终的值就是字符串<code>#app</code>，而<code>data</code>选项将变成一个函数，且这个函数的执行结果就是合并后的数据，即：<code>{test: 1}</code>。</p><p>下面是<code>vm.$options</code>的截图：</p><p><img width="500" src="/assets/vue/theory/vm-$options.jpg" title="vm.$options"></p><p>我们发现<code>el</code>确实还是原来的值，而<code>data</code>也确实变成了一个函数，并且这个函数就是我们之前遇到过的<code>mergedInstanceDataFn</code>，除此之外我们还能看到其他合并后的选项，其中<code>components</code>、<code>directives</code>、<code>filters</code>以及<code>_base</code>是存在于<code>Vue.options</code>中的，这些是我们所知道的，至于<code>render</code>赫尔<code>staticRenderFns</code>这两个选项是在将模板编译成渲染函数时添加上去的，我们后面会遇到。另外<code>_parentElm</code>和<code>_refElm</code>这两个选项是在为虚拟 DOM 创建组件实例时添加的，我们后面也会降到，这里大家不需要关心，免得失去重点。</p><h1 id="渲染函数的作用域代理"><a href="#渲染函数的作用域代理" class="headerlink" title="渲染函数的作用域代理"></a>渲染函数的作用域代理</h1><p><code>_init</code>方法中，经过<code>mergeOptions</code>合并处理选项之后，要执行的是下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的目的是在<code>vm</code>上添加<code>_renderProxy</code>属性，在非生产环境下调用<code>initProxy</code>方法添加，而在生产环境下直接赋值为<code>vm</code></p><p>接下来我们来看<code>initProxy</code>中的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initProxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 中间代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasProxy = <span class="keyword">typeof</span> <span class="built_in">Proxy</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Proxy</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasHandler = &#123;</span><br><span class="line">        has(target, key) &#123;</span><br><span class="line">            <span class="keyword">const</span> has = key <span class="keyword">in</span> target</span><br><span class="line">            <span class="keyword">const</span> isAllowed = allowedGlobals(key) || (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">'_'</span> &amp;&amp; !(key <span class="keyword">in</span> target.$data))</span><br><span class="line">            <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key)</span><br><span class="line">                <span class="keyword">else</span> warnNonPresent(target, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> has || !isAllowed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getHandler = &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; !(key <span class="keyword">in</span> target)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key)</span><br><span class="line">                <span class="keyword">else</span> warnNonPresent(target, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasProxy) &#123;</span><br><span class="line">            <span class="comment">// determine which proxy handler to use</span></span><br><span class="line">            <span class="keyword">const</span> options = vm.$options</span><br><span class="line">            <span class="keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler</span><br><span class="line">            vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vm._renderProxy = vm</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initProxy方法的主要逻辑是：</p><ol><li><p>如果宿主环境支持<code>Proxy</code>方法，使用<code>Proxy</code>方法对<code>vm</code>进行代理，并赋值给<code>vm._renderProxy</code></p><ol><li><p>如果不满足<code>options.render &amp;&amp; options.render._withStripped</code>条件时，拦截器对象为<code>hasHandler</code></p><p>  <code>has</code>可以拦截的操作有：</p><ul><li>属性查询：foo in proxy</li><li>继承属性查询：foo in Object.create(proxy)</li><li>with检查：with(proxy) { (foo); }</li><li><p>Reflect.has()</p><p>其中关键点就在于<code>has</code>操作可以拦截<code>with</code>操作，在<code>src/core/instance/render.js</code>文件中，找到<code>Vue.prototype._render</code>方法，里面有这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure><p>在调用<code>render</code>函数的时候，指定了其执行环境为<code>vm._renderProxy</code>，那么<code>render</code>函数长什么样呢？还是以上面的例子为例，我们可以通过打印<code>vm.$options.render</code>查看，它长成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$options.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// render 函数的 this 指向实例的 _renderProxy</span></span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>, [_v(_s(a))])   <span class="comment">// 在这里访问 a，相当于访问 vm._renderProxy.a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道<code>with</code>中的<code>this</code>被指定为了<code>vm._renderProxy</code>，所以当我们访问<code>a</code>变量时，就相当于访问<code>vm._renderProxy.a</code>，也正是因为如此，当我们在<code>with</code>语句块中调用一些内置的全局对象是，是不希望被代理到<code>vm._renderProxy</code>，这就是为什么<code>hasHandler</code>中有下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> has = key <span class="keyword">in</span> target</span><br><span class="line"><span class="keyword">const</span> isAllowed = allowedGlobals(key) || (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">'_'</span> &amp;&amp; !(key <span class="keyword">in</span> target.$data))</span><br><span class="line"><span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key)</span><br><span class="line">    <span class="keyword">else</span> warnNonPresent(target, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的意思是：如果访问的属性不存在于<code>target</code>(也就是<code>vm</code>)且不是全局对象或者以<code>_</code>开头且不在<code>target.$data</code>上时，是允许被访问的，否则不允许被访问，并给予警告</p></li></ul></li><li><p>如果满足时，拦截器对象为<code>getHandler</code></p><p>  当<code>render</code>方法存在，即我们构造实例的时候是通过<code>render</code>方法进行模板渲染的时候，且<code>render</code>方法的<code>_withStripped</code>属性为<code>true</code>的时候会使用<code>getHandler</code>，<code>vue-loader</code>提供的单文件组件的能力，其实最终就是把<code>template</code>编译成<code>render</code>方法，并且设置<code>render._withStripped</code>为<code>true</code>，在不使用<code>with</code>语句的<code>render</code>方法中，模板内的变量都是通过属性访问操作<code>vm.a</code>的形式访问的，从前文中我们了解到<code>Proxy</code>的<code>has</code>无法拦截属性访问操作，所以这里需要使用<code>Proxy</code>中可以拦截到属性访问的<code>get</code>，同时也省去了<code>has</code>中的全局变量检查（因为全局变量的访问不会被<code>get</code>拦截）</p></li></ol></li><li><p>如果宿主环境不支持<code>Proxy</code>方法，则和生成环境一样，<code>vm._renderProxy</code>的值被设置为<code>vm</code></p></li></ol><h1 id="初始化之initLifecycle"><a href="#初始化之initLifecycle" class="headerlink" title="初始化之initLifecycle"></a>初始化之initLifecycle</h1><p><code>_init</code>函数在执行完<code>initProxy</code>之后，执行的就是<code>initLifecycle</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm)</span><br></pre></td></tr></table></figure><p>在<code>initLifecycle</code>函数执行之前，执行了<code>vm.self = vm</code>语句，这句话在<code>Vue</code>实例对象<code>vm</code>上添加了<code>_self</code>属性，指向真实的实例本身。注意<code>vm._self</code>和<code>vm._renderProxy</code>不同，首先在用途上来说寓意是不同的，另外<code>vm._renderProxy</code>有可能是一个代理对象，即<code>Proxy</code>实例。</p><figure class="highlight javascript"><figcaption><span>initLifecycle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 options，它是 vm.$options 的引用，后面的代码使用的都是 options 常量</span></span><br><span class="line">    <span class="keyword">const</span> options = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// locate first non-abstract parent (查找第一个非抽象的父组件)</span></span><br><span class="line">    <span class="comment">// 定义 parent，它引用当前实例的父实例</span></span><br><span class="line">    <span class="keyword">let</span> parent = options.parent</span><br><span class="line">    <span class="comment">// 如果当前实例有父组件，且当前实例不是抽象的</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">        <span class="comment">// 使用 while 循环查找第一个非抽象的父组件</span></span><br><span class="line">        <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">            parent = parent.$parent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span></span><br><span class="line">        parent.$children.push(vm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前实例的 $parent 属性，指向父级</span></span><br><span class="line">    vm.$parent = parent</span><br><span class="line">    <span class="comment">// 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身</span></span><br><span class="line">    vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">    vm.$children = []</span><br><span class="line">    vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    vm._watcher = <span class="literal">null</span></span><br><span class="line">    vm._inactive = <span class="literal">null</span></span><br><span class="line">    vm._directInactive = <span class="literal">false</span></span><br><span class="line">    vm._isMounted = <span class="literal">false</span></span><br><span class="line">    vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initLifecycle主要做了几件事：</p><ol><li>将当前实例添加到父实例（第一个非抽象组件）的<code>$children</code>属性里，并设置当前实例的<code>$parent</code>指向父实例<ol><li><code>options.parent</code>来源于<code>Vue</code>的自动侦测父级的功能，实际上，当我们构建Vue实例时传入的<code>components</code>选项，内部会先调用<code>Vue.extend</code>方法，创建compoents对应的子类，然后在实例化子类作为子组件，这是<code>options.parent</code>也就是<code>compoents</code>的<code>parent</code>属性会被初始化为当前构造的实例，这个过程都在虚拟DOM的<code>patch</code>算法中进行的，可以查看<code>src/core/vdom/create-component.js</code>中的<code>createComponentInstanceForVnode</code>方法，它在<code>src/core/vdom/create-component.js</code>文件内的<code>componentVNodeHooks</code>钩子对象的<code>init</code>钩子函数内被调用</li><li>抽象组件的特点是：一般不渲染真实DOM，例如<code>Vue</code>内置的组件<code>keep-alive</code>、<code>transition</code>等；不会出现在父子关系的路径上，创建组件实例时，通过设置<code>abstract</code>属性为<code>true</code>，可以将其标记为一个抽象组件，例如<code>src/core/components/keep-alive.js</code>文件</li></ol></li><li>设置当前实例的<code>$root</code>属性为父实例的<code>$root</code>，如果不存在则指向zishen</li><li>初始化<code>$children</code>属性为空数组，用于存放子组件，初始化<code>$ref</code>属性为空对象，用于存放设置了<code>ref</code>属性的DOM元素</li><li>在实例上设置了一系列供内部使用的变量：<code>_watcher</code>、<code>_inactive</code>、<code>_directInactive</code>、<code>_isMounted</code>、<code>_isDestroyed</code>、<code>_isBeingDestroyed</code></li></ol><h1 id="初始化之initEvents"><a href="#初始化之initEvents" class="headerlink" title="初始化之initEvents"></a>初始化之initEvents</h1><figure class="highlight javascript"><figcaption><span>initEvents</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>往实例上增加了<code>_events</code>、<code>_hasHookEvent</code>属性</li><li>判断了<code>vm.$options._parentListeners</code>属性（在<code>src/core/vdom/create-component.js</code>文件中的<code>createComponentInstanceForVnode</code>被初始化）是否存在，如果存在调用<code>updateComponentListeners</code>方法</li></ol><h1 id="初始化之initRender"><a href="#初始化之initRender" class="headerlink" title="初始化之initRender"></a>初始化之initRender</h1><figure class="highlight javascript"><figcaption><span>initRender</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>, vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>往实例上增加了<code>$vnode</code>、<code>$slots</code>、<code>$scopedSlots</code>属性</li><li>往实例上增加了<code>$attrs</code>、<code>$listeners</code>属性，且在非生产环境时处于<code>updateChildComponent</code>函数外（来自于<code>src/core/instance/lifecycle.js</code>）外更改<code>$attrs</code>或<code>$listeners</code>时，给予一个错误提示</li></ol><h1 id="声明周期钩子的实现方式"><a href="#声明周期钩子的实现方式" class="headerlink" title="声明周期钩子的实现方式"></a>声明周期钩子的实现方式</h1><p>在<code>initRender</code>函数执行完毕后，是这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure><ol><li><p><code>callHook</code>方法用于调用生命周期钩子函数</p> <figure class="highlight javascript"><figcaption><span>callHook</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">    pushTarget()</span><br><span class="line">    <span class="keyword">const</span> handlers = vm.$options[hook]</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handlers[i].call(vm)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">        vm.$emit(<span class="string">'hook:'</span> + hook)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 这里的<code>pushTarge</code>和<code>popTarget</code>是为了避免在某些生命周期中使用<code>props</code>数据导致收集冗余的依赖。调用钩子方法时，使用<code>call</code>方法指定了其执行上下文，即把<code>this</code>指向为<code>vm</code></p><p> <code>vm._hasHookEvent</code>是在<code>initEvents</code>函数中定义的，它的作用是判断是否存在<strong>生命周期钩子的事件侦听器</strong>，初始化值为<code>false</code>代表没有，当组件检测到存在生命周期钩子的事件侦听器时，会将<code>vm._hasHookEvent</code>设置为<code>true</code>，那么什么是<strong>生命周期钩子事件侦听器</strong>呢？</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">hook:beforeCreate</span>=<span class="string">"handleChildBeforeCreate"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">hook:created</span>=<span class="string">"handleChildCreated"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">hook:mounted</span>=<span class="string">"handleChildMounted"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">hook:</span>生命周期钩子</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p> 如上代码可以使用<code>hook:</code>加<code>生命周期钩子名称</code>的方式来监听组件相应的生命周期事件。这是<code>Vue</code>官方文档上没有体现的，但你确实可以这么用，不过除非你对<code>Vue</code>非常了解，否则不建议使用。</p></li><li><p><code>initState</code>函数包括了：<code>initProps</code>、<code>initMethods</code>、<code>initData</code>、<code>initComputed</code>、<code>initWatch</code>，所以当<code>beforeCreated</code>钩子被调用时，所有与<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>以及<code>watch</code>相关的内容都不能使用，当然<code>inject/provide</code>也是不可用的。作为对立面，<code>created</code>钩子恰好是等待<code>initInjections</code>、<code>initState</code>、<code>initProvide</code>执行完毕后才被调用的，所以在<code>created</code>钩子中，是完全能够使用上面提到的内容。但由于此时还没有任何的挂载操作，所以在<code>created</code>中是不能够访问DOM的。</p></li></ol><h1 id="Vue初始化之initState"><a href="#Vue初始化之initState" class="headerlink" title="Vue初始化之initState"></a>Vue初始化之initState</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure><p>可以看到在<code>initState</code>函数执行之前，先执行了<code>initInjections</code>函数，也就是说<code>inject</code>选项要更早被初始化，不过由于初始化 <code>inject</code> 选项的时候涉及到 <code>defineReactive</code> 函数，并且调用了 <code>toggleObserving</code> 函数操作了用于控制是否应该转换为响应式属性的状态标识 <code>observerState.shouldConvert</code>，所以我们决定先讲解 <code>initState</code>，之后再来讲解 <code>initInjections</code> 和 <code>initProvide</code>，这才是一个合理的顺序，并且从 <code>Vue</code> 的时间线上来看 <code>inject/provide</code> 选项确实是后来才添加的。</p><figure class="highlight javascript"><figcaption><span>initState</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>往实例上添加了<code>_watchers</code>属性，用于存储所有该组件实例的<code>watcher</code>对象</li><li>可以看到<code>props</code>的初始化先于<code>data</code>，这就是为什么我们能够使用<code>props</code>来初始化<code>data</code>的原因</li></ol><p>下一篇：<a href="/2019/04/05/揭开数据响应系统的面纱.html">揭开数据响应系统的面纱</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用于初始化的最终选项-options&quot;&gt;&lt;a href=&quot;#用于初始化的最终选项-options&quot; class=&quot;headerlink&quot; title=&quot;用于初始化的最终选项\$options&quot;&gt;&lt;/a&gt;用于初始化的最终选项\$options&lt;/h1&gt;&lt;p&gt;在&lt;a 
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue选项的合并</title>
    <link href="http://yoursite.com/2019/03/27/Vue%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%88%E5%B9%B6.html"/>
    <id>http://yoursite.com/2019/03/27/Vue选项的合并.html</id>
    <published>2019-03-27T05:35:09.000Z</published>
    <updated>2019-03-28T05:46:26.186Z</updated>
    
    <content type="html"><![CDATA[<p>上一章节我们了解了<code>Vue</code>对选项的规范，接下来才是真正的合并阶段，我们继续看<code>mergeOptions</code>函数的代码，接下来的一段代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">        mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeField</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure><p>这段代码的作用是，针对不同的选项，例如<code>components、props、data、filters</code>，采取不同的合并策略进行合并，其中<code>strast</code>的声明在本文件顶部进行了声明，初始化为<code>config.optionsMergeStrategies</code>，它的值现在还是一个空对象，在后续的代码中将往上添加各种合并策略函数。如果你要使用自定义合并策略，只需要在<code>Vue.config.optionsMergeStrategies</code>添加与自定义选项同名的函数就行。这就是<code>Vue</code>文档中提过的全局配置：<a href="https://cn.vuejs.org/v2/api/index.html#optionMergeStrategies" target="_blank" rel="noopener">optionMergeStrategies</a></p><h1 id="选项-el、propsData-的合并策略"><a href="#选项-el、propsData-的合并策略" class="headerlink" title="选项 el、propsData 的合并策略"></a>选项 el、propsData 的合并策略</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Options with restrictions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    strats.el = strats.propsData = <span class="function"><span class="keyword">function</span>(<span class="params">parent, child, vm, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">            warn(<span class="string">`option "<span class="subst">$&#123;key&#125;</span>" can only be used during instance `</span> + <span class="string">'creation with the `new` keyword.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultStrat(parent, child)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>el、props</code>采用的合并策略是默认的合并策略：</p><figure class="highlight javascript"><figcaption><span>默认合并策略</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default strategy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> defaultStrat = <span class="function"><span class="keyword">function</span>(<span class="params">parentVal: any, childVal: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> childVal === <span class="literal">undefined</span> ? parentVal : childVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认合并策略：如果子选项是 undefined，则使用父选项，否则使用子选项</p><p>这里有一点需要注意，那就是对<code>vm</code>是否存在进行判断，如果不存在，在非生产环境会给予错误提示，我们都知道当前这个<code>vm</code>是由<code>mergeOptions</code>中的<code>vm</code>传过来的，而<code>mergeOptions</code>的<code>vm</code>来自于<code>_init</code>方法，<code>_init</code>方法是在<code>Vue</code>构造函数中被调用，所以当我们通过<code>new</code>操作符创建<code>Vue</code>实例时，这个<code>vm</code>是一定存在的。那么说明，在某种情况下，<code>vm</code>可能不存在，也就是<code>mergeOptions</code>方法除了在<code>_init</code>方法被调用，还在其它地方也被调用了。这个地方就是<code>src/core/global-api/extend.js</code>中的<code>Vue.extend</code>方法，其中有这么一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.options = mergeOptions(Super.options, extendOptions)</span><br></pre></td></tr></table></figure><p>可以看到，当我们通过<code>Vue.extend</code>创建子类的时候<code>mergeOptions</code>会被调用，此时策略函数就拿不到第三个参数，所以最终能得到的结论是：<strong>如果策略函数中拿不到<code>vm</code>参数，那么处理的就是子组件选项（调用<code>Vue.extend传入的选项参数</code>）</strong></p><h1 id="选项-data-的合并策略"><a href="#选项-data-的合并策略" class="headerlink" title="选项 data 的合并策略"></a>选项 data 的合并策略</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">strats.data = <span class="function"><span class="keyword">function</span>(<span class="params">parentVal: any, childVal: any, vm?: Component</span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(<span class="string">'The "data" option should be a function '</span> + <span class="string">'that returns a per-instance value in component '</span> + <span class="string">'definitions.'</span>, vm)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> parentVal</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果处理的是子组件选项：</p><p>如果 data 不存在或 data 不为一个函数，给予错误提示，并返回父 data。我们都知道为了防止不同组件的共享一个 data，所以子组件的 data 选项必须要为一个返回 object 的函数</p><p>否则，调用 mergeDataOrFn 方法，传入父 data 选项、子 data 选项</p><p>如果处理的不是子组件选项，调用 mergeDataOrFn 方法，传入父 data 选项、子 data 选项、vm</p><figure class="highlight javascript"><figcaption><span>mergeDataFn</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span>(<span class="params">parentVal: any, childVal: any, vm?: Component</span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">        <span class="comment">// in a Vue.extend merge, both should be functions</span></span><br><span class="line">        <span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> parentVal</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> childVal</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// when parentVal &amp; childVal are both present,</span></span><br><span class="line">        <span class="comment">// we need to return a function that returns the</span></span><br><span class="line">        <span class="comment">// merged result of both functions... no need to</span></span><br><span class="line">        <span class="comment">// check if parentVal is a function here because</span></span><br><span class="line">        <span class="comment">// it has to be a function to pass previous merges.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mergeData(<span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal, <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// instance merge</span></span><br><span class="line">            <span class="keyword">const</span> instanceData = <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(vm, vm) : childVal</span><br><span class="line">            <span class="keyword">const</span> defaultData = <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(vm, vm) : parentVal</span><br><span class="line">            <span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">                <span class="keyword">return</span> mergeData(instanceData, defaultData)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultData</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果处理的是子组件选项：</p><ul><li>子选项不存在，则使用父选项</li><li><p>父选项不存在，则使用子选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue不存在data选项，所以使用子选项</span></span><br><span class="line"><span class="keyword">const</span> ParentComponent = Vue.extend(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ParentComponent存在data选项，而子选项不存在，使用父选项</span></span><br><span class="line"><span class="keyword">const</span> childCompoent = ParentComponent.extend(&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>子选项与父选项都存在，则返回<code>mergedDataFn</code>函数</p></li></ul><p>我们可以发现<code>mergeDataorFn</code>函数在处理子组件选项时返回的总是一个函数，这也就是间接导致<code>strats.data</code>策略函数在处理子组件选项时返回的也总是一个函数</p><p>如果处理的不是子组件选项：返回<code>mergedInstanceDataFn</code>函数</p><p><code>mergeDataorFn</code>和<code>mergedInstanceDataFn</code>中的代码类似，都是调用<code>mergeData</code>方法，传入父 data 以及子 data，如果<code>data</code>是个<code>function</code>，则调用该<code>function</code>生成一个 data 对象。TODO:这里有个疑问，当处理的是子组件的选项时，感觉不需要再判断<code>childVal</code>和<code>parentVal</code>是否是<code>function</code>了，因为它们一定是<code>function</code>，这在<code>strats.data</code>中已经判断了的。</p><p>我们接着看<code>mergeData</code>方法，它才是终极的合并策略，其源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper that recursively merges two data objects together.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeData</span>(<span class="params">to: Object, from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to</span><br><span class="line">    <span class="keyword">let</span> key, toVal, fromVal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> keys = hasSymbol ? <span class="built_in">Reflect</span>.ownKeys(<span class="keyword">from</span>) : <span class="built_in">Object</span>.keys(<span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        <span class="comment">// in case the object is already observed...</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'__ob__'</span>) <span class="keyword">continue</span></span><br><span class="line">        toVal = to[key]</span><br><span class="line">        fromVal = <span class="keyword">from</span>[key]</span><br><span class="line">        <span class="keyword">if</span> (!hasOwn(to, key)) &#123;</span><br><span class="line">            set(to, key, fromVal)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal)) &#123;</span><br><span class="line">            mergeData(toVal, fromVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mergeData</code>的参数<code>to</code>代表的是<code>childData</code>，<code>from</code>代表的是<code>parentData</code>。这里值得注意的几点有：</p><ol><li><code>mergeData</code>的函数目的是把<code>parentData</code>的属性添加到<code>childData</code>上。如果<code>parentData</code>上的属性不存在于<code>childData</code>上，则调用<code>set</code>函数把这个属性添加到<code>childData</code>上；如果<code>parentData</code>上的属性存在于<code>childData</code>中且都为纯对象，则递归调用<code>mergeData</code>进行深度合并。</li><li><code>Object.keys</code>无法遍历出<code>symbol</code>属性，而<code>Reflect.ownKeys</code>可以，<code>Reflect</code>是一个内置的对象，它提供拦截 JavaScript 操作的方法。</li><li>如果<code>key</code>为<code>__ob__</code>，TODO:</li></ol><p>上面提到了一个<code>set</code>函数，这个函数来自于<code>src/core/observe/index.js</code>，实际上这个<code>set</code>函数就是<code>Vue</code>暴露给我的全局 API<code>Vue.set</code>，TODO:。</p><p>最后我们对大家经常会产生疑问的地方做一些补充：</p><h2 id="一、为什么最终strats-data会被处理成一个函数"><a href="#一、为什么最终strats-data会被处理成一个函数" class="headerlink" title="一、为什么最终strats.data会被处理成一个函数"></a>一、为什么最终<code>strats.data</code>会被处理成一个函数</h2><p>这是因为，通过函数返回数据对象，保证了每个组件实例都有一个唯一的数据副本，避免了组件间数据互相影响。</p><h2 id="二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据"><a href="#二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据" class="headerlink" title="二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据"></a>二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据</h2><p>这个问题是什么意思呢？我们知道在合并阶段<code>strats.data</code>将被处理成一个函数，但是这个函数并没有被执行，而是到了后面初始化的阶段才执行的，这个时候才会调用<code>mergeData</code>对数据进行合并处理，那么这么做的目的是什么呢？</p><p>其实这么做是有原因的，后面讲到<code>Vue</code>的初始化的时候，大家就会发现<code>inject</code>和<code>props</code>这两个的选项的初始化是优先于<code>data</code>选项的，这就保证了我们能够使用<code>props</code>初始化<code>data</code>中的数据，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件：使用 props 初始化子组件的 childData</span></span><br><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">    template: <span class="string">'&lt;span&gt;&lt;/span&gt;'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            childData: <span class="keyword">this</span>.parentData</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [<span class="string">'parentData'</span>],</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 这里将输出 parent</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.childData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    <span class="comment">// 通过 props 向子组件传递数据</span></span><br><span class="line">    template: <span class="string">'&lt;child parent-data="parent" /&gt;'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上例所示，子组件的数据<code>childData</code>的初始值就是<code>parentData</code>这个<code>props</code>，而之所以能够这样做的原因有两个：</p><ol><li>由于<code>props</code>的初始化先于<code>data</code>选项的初始化</li><li><code>data</code>选项是在初始化的时候才求值的，你也可以理解为在初始化的时候才使用<code>mergeData</code>进行数据合并</li></ol><h2 id="三、你可以这么做"><a href="#三、你可以这么做" class="headerlink" title="三、你可以这么做"></a>三、你可以这么做</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data (vm) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    childData: vm.parentData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者使用更简单的解构赋值</span></span><br><span class="line">data (&#123; parentData &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    childData: parentData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data 函数的参数实际上就是当前实例对象。那么这个参数是在哪里传进来的呢？其实有两个地方，其中一个地方我们前面见过了，如下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> mergeData(<span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal, <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal)</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"><span class="keyword">const</span> instanceData = <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(vm, vm) : childVal</span><br><span class="line"><span class="keyword">const</span> defaultData = <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(vm, vm) : parentVal</span><br></pre></td></tr></table></figure><p>当然仅仅在这里这么做是不够的，比如<code>mergeDataFn</code>前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">    <span class="keyword">return</span> parentVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">    <span class="keyword">return</span> childVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，直接将<code>parentVal</code>或<code>childVal</code>返回了，我们知道这里的<code>parentVal</code>和<code>childVal</code>就是<code>data</code>数，由于被直接返回，所以并没有指定其运行的作用域，且也没有传递当前实例作为参数，所以我们必然还是在其他地方做这些事情，而这个地方就是我们说的第二个地方，它在哪里呢？当然是初始化的时候，后面我们会讲到的，如果这里大家没有理解也不用担心。</p><h1 id="生命周期钩子选项的合并策略"><a href="#生命周期钩子选项的合并策略" class="headerlink" title="生命周期钩子选项的合并策略"></a>生命周期钩子选项的合并策略</h1><figure class="highlight javascript"><figcaption><span>Vue生命周期钩子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LIFECYCLE_HOOKS = [<span class="string">'beforeCreate'</span>, <span class="string">'created'</span>, <span class="string">'beforeMount'</span>, <span class="string">'mounted'</span>, <span class="string">'beforeUpdate'</span>, <span class="string">'updated'</span>, <span class="string">'beforeDestroy'</span>, <span class="string">'destroyed'</span>, <span class="string">'activated'</span>, <span class="string">'deactivated'</span>, <span class="string">'errorCaptured'</span>, <span class="string">'serverPrefetch'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hooks and props are merged as arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params">parentVal: ?Array&lt;Function&gt;, childVal: ?Function | ?Array&lt;Function&gt;</span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = childVal ? (parentVal ? parentVal.concat(childVal) : <span class="built_in">Array</span>.isArray(childVal) ? childVal : [childVal]) : parentVal</span><br><span class="line">    <span class="keyword">return</span> res ? dedupeHooks(res) : res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupeHooks</span>(<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooks.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(hooks[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            res.push(hooks[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">    strats[hook] = mergeHook</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整个函数体由三组三目运算符组成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (是否有 childVal，即判断组件的选项中是否有对应名字的生命周期钩子函数)</span><br><span class="line">  ? 如果有 childVal 则判断是否有 parentVal</span><br><span class="line">    ? 如果有 parentVal 则使用 concat 方法将二者合并为一个数组</span><br><span class="line">    : 如果没有 parentVal 则判断 childVal 是不是一个数组</span><br><span class="line">      ? 如果 childVal 是一个数组则直接返回</span><br><span class="line">      : 否则将其作为数组的元素，然后返回数组</span><br><span class="line">  : 如果没有 childVal 则直接返回 parentVal</span><br></pre></td></tr></table></figure><p>这里我们以<code>created</code>钩子为例，演示一下钩子函数的合并过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">options.created = [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'created'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> Parent = Vue.extend(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> Child = <span class="keyword">new</span> Parent(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">options.created = [</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> createFn</span><br><span class="line"><span class="keyword">const</span> Parent = Vue.extend(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="keyword">new</span> Parent(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里有个地方需要注意，那就是<code>dedupeHooks</code>函数做的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createdFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// 'ChildComponent'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ParentComponent = Vue.extend(&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'ParentComponent'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: createdFn</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChildComponent = <span class="keyword">new</span> ParentComponent(&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'ChildComponent'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: createdFn</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果两个 created 函数引用的是同一个函数，则只会调用一次，而调用时绑定的<code>this</code>作用域是最后引用的组件，具体需要查看调用方法的实现 TODO:</p><p>通过钩子函数的合并代码，我们能发现还有一个地方官方文档没有提及的就是钩子函数我们能够传入数组，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    created: [</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'first'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'second'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'third'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="资源（assets）选项的合并策略"><a href="#资源（assets）选项的合并策略" class="headerlink" title="资源（assets）选项的合并策略"></a>资源（assets）选项的合并策略</h1><figure class="highlight javascript"><figcaption><span>资源（assets）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [<span class="string">'component'</span>, <span class="string">'directive'</span>, <span class="string">'filter'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Assets</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When a vm is present (instance creation), we need to do</span></span><br><span class="line"><span class="comment"> * a three-way merge between constructor options, instance</span></span><br><span class="line"><span class="comment"> * options and parent options.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeAssets</span>(<span class="params">parentVal: ?Object, childVal: ?Object, vm?: Component, key: string</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (childVal) &#123;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; assertObjectType(key, childVal, vm)</span><br><span class="line">        <span class="keyword">return</span> extend(res, childVal)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    strats[type + <span class="string">'s'</span>] = mergeAssets</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>assets</code>的合并策略：首先以<code>parentVal</code>为原型创建一个对象赋给<code>res</code>，然后判断<code>childVal</code>是否存在，如果存在且为纯对象，则调用<code>extend</code>方法进行合并，然后返回；如果<code>childVal</code>不存在，则直接返回<code>res</code></p><p>以<code>components</code>为例，假设我们有以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        ChildComponent: ChildComponent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>则合并后为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = &#123;</span><br><span class="line">  ChildComponent</span><br><span class="line">  <span class="comment">// 原型</span></span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    KeepAlive,</span><br><span class="line">    Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们不用显示地注册组件就能够使用一些内置组件的原因，同时这也是内置组件的实现方式，通过<code>Vue.extend</code>创建出来的子类也是一样的道理，一层一层地通过原型进行组件的搜索。</p><h1 id="选项-watch-的合并策略"><a href="#选项-watch-的合并策略" class="headerlink" title="选项 watch 的合并策略"></a>选项 watch 的合并策略</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watchers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Watchers hashes should not overwrite one</span></span><br><span class="line"><span class="comment"> * another, so we merge them as arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">strats.watch = <span class="function"><span class="keyword">function</span>(<span class="params">parentVal: ?Object, childVal: ?Object, vm?: Component, key: string</span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">// work around Firefox's Object.prototype.watch...</span></span><br><span class="line">    <span class="keyword">if</span> (parentVal === nativeWatch) parentVal = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">if</span> (childVal === nativeWatch) childVal = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (!childVal) <span class="keyword">return</span> <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        assertObjectType(key, childVal, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br><span class="line">    <span class="keyword">const</span> ret = &#123;&#125;</span><br><span class="line">    extend(ret, parentVal)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">        <span class="keyword">let</span> parent = ret[key]</span><br><span class="line">        <span class="keyword">const</span> child = childVal[key]</span><br><span class="line">        <span class="keyword">if</span> (parent &amp;&amp; !<span class="built_in">Array</span>.isArray(parent)) &#123;</span><br><span class="line">            parent = [parent]</span><br><span class="line">        &#125;</span><br><span class="line">        ret[key] = parent ? parent.concat(child) : <span class="built_in">Array</span>.isArray(child) ? child : [child]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几点需要注意：</p><ol><li>判断了<code>parentVal</code>和<code>childVal</code>是否等于<code>nativeWatch</code>，如果是，则重置为<code>undefined</code>。这么做的原因是因为在<code>firefox</code>浏览器中，<code>Object.prototype</code>拥有原生的<code>watch</code>函数。</li><li>被处理后的<code>watch</code>选项下的每个键值，有可能是一个数组，也有可能是一个函数。</li><li><p><code>watch</code>选项允许我们传入一个数组，类似于钩子函数，不同于钩子函数的地方在于对同一个函数的引用会触发两次调用，如下：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchFn</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, newVal) <span class="comment">// 会打印两次，this都指向ChildComponent</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ParentComponent = Vue.extend(&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'ParentComponent'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        name: watchFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChildComponent = <span class="keyword">new</span> ParentComponent(&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'ChildComponent'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        name: watchFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ChildComponent.name = <span class="string">'222'</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="选项props、method、inject、computed的合并策略"><a href="#选项props、method、inject、computed的合并策略" class="headerlink" title="选项props、method、inject、computed的合并策略"></a>选项props、method、inject、computed的合并策略</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Other object hashes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">strats.props =</span><br><span class="line">strats.methods =</span><br><span class="line">strats.inject =</span><br><span class="line">strats.computed = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (childVal &amp;&amp; process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assertObjectType(key, childVal, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  extend(ret, parentVal)</span><br><span class="line">  <span class="keyword">if</span> (childVal) extend(ret, childVal)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>props、method、inject、computed</code>这四个选项有一个共同点，就是它们的结构都是纯对象，虽然我们在书写<code>props</code>或者<code>inject</code>选项的时候可能是一个数组，但是在<a href="/2019/03/26/Vue选项的规范化.html">Vue选项的规范化</a>这一节我们知道，<code>Vue</code>内部都将其规范化为了一个对象</p><h1 id="选项provide的合并策略"><a href="#选项provide的合并策略" class="headerlink" title="选项provide的合并策略"></a>选项provide的合并策略</h1><p>最后一个选项的合并策略，就是<code>provide</code>选项的合并策略，只有一句代码，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strats.provide = mergeDataOrFn</span><br></pre></td></tr></table></figure><p>也就是<code>provide</code>选项的合并策略与<code>data</code>选项的合并策略相同，都是使用<code>mergeDataOrFn</code>函数</p><h1 id="选项处理小结"><a href="#选项处理小结" class="headerlink" title="选项处理小结"></a>选项处理小结</h1><p>现在我们了解了 Vue 中是如何合并处理选项的，接下来我们稍微做一个总结：</p><ul><li>对于 <code>el、propsData</code>选项使用默认的合并策略<code>defaultStrat</code>。</li><li>对于 <code>data</code> 选项，使用 <code>mergeDataOrFn</code> 函数进行处理，最终结果是 <code>data</code> 选项将变成一个函数，且该函数的执行结果为真正的数据对象。</li><li>对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行</li><li>对于 <code>directives、filters</code> 以及 <code>components</code> 等资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。</li><li>对于 <code>watch</code> 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行。</li><li>对于 <code>props、methods、inject、computed</code> 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。</li><li>对于 <code>provide</code> 选项，其合并策略使用与 <code>data</code> 选项相同的 <code>mergeDataOrFn</code> 函数。</li><li>最后，以上没有提及到的选项都将使默认选项 <code>defaultStrat</code>。</li><li>最最后，默认合并策略函数 <code>defaultStrat</code> 的策略是：只要子选项不是 <code>undefined</code> 就使用子选项，否则使用父选项。</li></ul><p>至此，我们大概介绍完了 <code>Vue</code> 对选项的处理，但留心的同学一定注意到了，<code>options.js</code> 文件的代码我们都基本逐行分析，唯独剩下一个函数我们始终没有提到，它就是 <code>resolveAsset</code> 函数。这个函数我们暂且不在这里讲，后面随着我们的深入，自然会再次碰到它，到那个时候应该是讲它的最好时机。</p><h1 id="再看mixins和extends"><a href="#再看mixins和extends" class="headerlink" title="再看mixins和extends"></a>再看mixins和extends</h1><p>在<a href="/2019/03/26/Vue选项的规范化.html">Vue选项的规范化</a>一节中，我们讲到了<code>mergeOptions</code>函数中的如下这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply extends and mixins on the child options,</span></span><br><span class="line"><span class="comment">// but only if it is a raw options object that isn't</span></span><br><span class="line"><span class="comment">// the result of another mergeOptions call.</span></span><br><span class="line"><span class="comment">// Only merged options has the _base property.</span></span><br><span class="line"><span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">            parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>mixins</code>在<code>Vue</code>中用于解决代码复用的问题，比如混入<code>created</code>生命周期钩子，用于打印一句话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleMixin = &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created:mixins'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue (&#123;</span><br><span class="line">  mixins: [consoleMixin],</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created:instance'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行以上代码，将打印两句话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created:mixins</span></span><br><span class="line"><span class="comment">// created:instance</span></span><br></pre></td></tr></table></figure><p>这是因为<code>mergeOptions</code>函数在处理<code>mixins</code>选项的时候递归调用了<code>mergeOptions</code>函数将<code>mixins</code>合并到了<code>parent</code>中，并将合并后生成的新对象作为新的<code>parent</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中我们只涉及到<code>created</code>生命周期钩子的合并，所以会使用生命周期钩子的合并策略函数进行处理，现在我们已经知道<code>mergeOptions</code>会把生命周期选项合并为一个数组，所以所有的生命周期钩子都会被执行。那么不仅仅是生命周期钩子，任何写在<code>mixins</code>中的选项，都会使用<code>mergeOptions</code>中相应的合并策略进行处理，这就是<code>mixins</code>的实现方式。</p><p>对于<code>extends</code>选项，与<code>mixins</code>相同，甚至由于<code>extends</code>选项只能是一个对象，而不能是数组，反而要比<code>mixins</code>的实现更为简单，连遍历都不需要。</p><p>下一篇：<a href="/2019/03/28/Vue的初始化之开篇.html">Vue的初始化之开篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一章节我们了解了&lt;code&gt;Vue&lt;/code&gt;对选项的规范，接下来才是真正的合并阶段，我们继续看&lt;code&gt;mergeOptions&lt;/code&gt;函数的代码，接下来的一段代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue选项的规范化</title>
    <link href="http://yoursite.com/2019/03/26/Vue%E9%80%89%E9%A1%B9%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96.html"/>
    <id>http://yoursite.com/2019/03/26/Vue选项的规范化.html</id>
    <published>2019-03-26T03:25:26.000Z</published>
    <updated>2019-03-27T05:46:16.391Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要是对 <code>mergeOptions</code> 方法进行说明，根据<code>core/instance/init.js</code>顶部的引用关系可知，<code>mergeOptions</code>函数来自于<code>src/core/util/options.js</code>文件，事实上不仅仅是<code>mergeOptions</code>函数，整个文件所做的一切都是为了一件事：选项的合并</p><h1 id="弄清楚传递给-mergeOptions-函数的三个参数"><a href="#弄清楚传递给-mergeOptions-函数的三个参数" class="headerlink" title="弄清楚传递给 mergeOptions 函数的三个参数"></a>弄清楚传递给 mergeOptions 函数的三个参数</h1><p>首先，我们需要搞清楚一件事，就是如下代码中传递给<code>mergeOptions</code>函数的三个参数到底是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><p>第一个参数是通过调用<code>resolveConstructorOptions</code>函数得到的，并将<code>vm.constructor</code>作为参数传递进去，这个函数声明在<code>src/core/instance/init.js</code>文件中，如下：</p> <figure class="highlight javascript"><figcaption><span>resolveConstructorOptions</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">    <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">        <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super)</span><br><span class="line">        <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</span><br><span class="line">        <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</span><br><span class="line">        <span class="comment">// super option changed,</span></span><br><span class="line">        <span class="comment">// need to resolve new options.</span></span><br><span class="line">        Ctor.superOptions = superOptions</span><br><span class="line">        <span class="comment">// check if there are any late-modified/attached options (#4976)</span></span><br><span class="line">        <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor)</span><br><span class="line">        <span class="comment">// update base extend options</span></span><br><span class="line">        <span class="keyword">if</span> (modifiedOptions) &#123;</span><br><span class="line">            extend(Ctor.extendOptions, modifiedOptions)</span><br><span class="line">        &#125;</span><br><span class="line">        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)</span><br><span class="line">        <span class="keyword">if</span> (options.name) &#123;</span><br><span class="line">            options.components[options.name] = Ctor</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>声明<code>options</code>变量，初始化为当前实例构造函数的<code>options</code>，在这个例子中<code>Ctor</code>是<code>Vue</code>（如果是实例化通过<code>Vue.extend</code>创建的子类，那么这里的<code>Ctor</code>就不是<code>Vue</code>，而是该子类），然后返回<code>options</code>变量</li><li>如果<code>Ctor.super</code>存在（该实例是通过实例化<code>Vue.extend</code>创建的子类实现的），则执行<code>if</code>判断语句里面的代码</li><li><p>该函数的作用就是用来获取当前实例构造者的<code>options</code>属性（在这个例子中就是Vue.options，如下）</p> <figure class="highlight javascript"><figcaption><span>Vue.options</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        KeepAlive</span><br><span class="line">        Transition,</span><br><span class="line">        TransitionGroup</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        model,</span><br><span class="line">        show</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    _base: Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>第二个参数就是我们调用<code>Vue</code>构造函数传进来的参数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三个参数<code>vm</code>是实例对象本身</p></li></ol><h1 id="检查组件名称是否符合要求"><a href="#检查组件名称是否符合要求" class="headerlink" title="检查组件名称是否符合要求"></a>检查组件名称是否符合要求</h1><p>打开<code>src/core/util/options.js</code>，找到<code>mergeOptions</code>方法，这个方法上面有一段注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two option objects into a new one.</span></span><br><span class="line"><span class="comment"> * Core utility used in both instantiation and inheritance.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>合并两个对象为一个对象，这个函数不仅仅在实例化对象（即<code>_init</code>方法中）的时候用到，在继承（<code>Vue.extend</code>）中也有用到，所以这个函数是一个用来合并两个选项对象为一个新对象的通用程序。</p><p>开始的一段代码如下，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  checkComponents(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非生产环境下，会以<code>child</code>对象（构造实例时传入的options）为参数，调用<code>checkComponents</code>方法，该方法是用来校验组件名是否符合要求的，组件名的要求如下</p><ol><li>组件的名称需要满足正则表达式：<code>/^[a-zA-Z][\\-\\.0-9_a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*$/</code></li><li>要满足：条件<code>isBuiltInTag(name) || config.isReservedTag(name)</code>不成立<ol><li><code>isBuitlInTag</code>检测是否是内置标签（slot、component）</li><li><code>config.isReservedTag</code>检测是否是保留标签，<code>isReservedTag</code>方法在<code>src/platform/web/runtime/index.js</code>中被初始化，通过查看可知在<code>Vue</code>中<code>html</code>标签和部分<code>SVG</code>标签被认为是保留的</li></ol></li></ol><h1 id="允许合并另一个实例构造者的选项"><a href="#允许合并另一个实例构造者的选项" class="headerlink" title="允许合并另一个实例构造者的选项"></a>允许合并另一个实例构造者的选项</h1><p>我们继续看代码，接下来的一段代码同样是一个<code>if</code>语句块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'function'</span>) &#123;</span><br><span class="line">  child = child.options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明<code>child</code>参数除了是普通的选项对象外，还可以是一个函数，如果是函数的话就取该函数的<code>options</code>静态属性作为新的<code>child</code>。<code>Vue</code>和通过<code>Vue.extend</code>创造出来的子类拥有<code>options</code>属性。所以这就允许我们在进行选项合并的时候，去合并一个<code>Vue</code>实例构造者的选项了。</p><h1 id="规范化选项（props-inject-directives）"><a href="#规范化选项（props-inject-directives）" class="headerlink" title="规范化选项（props, inject, directives）"></a>规范化选项（props, inject, directives）</h1><p>接着看代码，接下来是三个用来规范化选项的函数调用，因为<code>Vue</code>中拥有多种使用方法的选项有很多，例如<code>props</code>，即可以传<code>Array</code>也可以传<code>Object</code>，为了在选项合并的时候能够统一处理，所以需要将其规范成同一种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normalizeProps(child, vm)</span><br><span class="line">normalizeInject(child, vm)</span><br><span class="line">normalizeDirectives(child)</span><br></pre></td></tr></table></figure><ol><li><p>normalizeProps: 将props统一规范为对象的形式</p> <figure class="highlight javascript"><figcaption><span>props规范化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">&#123;</span><br><span class="line">    props: [<span class="string">'demo-props'</span>] <span class="comment">// 非字符串将会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        demoProps: &#123;</span><br><span class="line">            type: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line">&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        DemoProps: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        demoProps: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line">&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        DemoProps: <span class="built_in">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        demoProps: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>normalizeInject: 将inject统一规范为对象的形式</p> <figure class="highlight javascript"><figcaption><span>inject规范化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">&#123;</span><br><span class="line">    inject: [<span class="string">'data1'</span>, <span class="string">'data2'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    inject: &#123;</span><br><span class="line">        <span class="string">'data1'</span>: &#123; <span class="attr">from</span>: <span class="string">'data1'</span> &#125;</span><br><span class="line">        <span class="string">'data2'</span>: &#123; <span class="attr">from</span>: <span class="string">'data2'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">let</span> data1 = <span class="string">'data1'</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    data1,</span><br><span class="line">    d2: <span class="string">'data2'</span>,</span><br><span class="line">    data3: &#123;</span><br><span class="line">        someProperty: <span class="string">'someValue'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    data1: &#123; <span class="attr">from</span>: <span class="string">'data1'</span> &#125;,</span><br><span class="line">    d2: &#123; <span class="attr">from</span>: <span class="string">'data2'</span> &#125;,</span><br><span class="line">    data3: &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="string">'data3'</span>,</span><br><span class="line">        someProperty: <span class="string">'someValue'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>normalizeDirectives：将<code>directives</code>统一规范为对象的形式</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">&#123;</span><br><span class="line">    directives: &#123;</span><br><span class="line">        test1: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        test2: &#123;</span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">&#123;</span><br><span class="line">    directives: &#123;</span><br><span class="line">        test1: &#123;</span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        test2: &#123;</span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="处理-extends-和-mixins"><a href="#处理-extends-和-mixins" class="headerlink" title="处理 extends 和 mixins"></a>处理 <code>extends</code> 和 <code>mixins</code></h1><p>规范化<code>props、inject、directives</code>之后的一段代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply extends and mixins on the child options,</span></span><br><span class="line"><span class="comment">// but only if it is a raw options object that isn't</span></span><br><span class="line"><span class="comment">// the result of another mergeOptions call.</span></span><br><span class="line"><span class="comment">// Only merged options has the _base property.</span></span><br><span class="line"><span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">            parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归调用<code>mergeOptions</code>方法，将<code>child.exnteds</code>和<code>child.mexins</code>合并到<code>parent</code>上，直到<code>child</code>为<code>Vue</code>时，只有<code>Vue</code>上有<code>_base</code>属性，其直为<code>Vue</code></p><p>下一篇：<a href="/2019/03/27/Vue选项的合并.html">Vue选项的合并</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这节主要是对 &lt;code&gt;mergeOptions&lt;/code&gt; 方法进行说明，根据&lt;code&gt;core/instance/init.js&lt;/code&gt;顶部的引用关系可知，&lt;code&gt;mergeOptions&lt;/code&gt;函数来自于&lt;code&gt;src/core/util/o
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>以一个例子为线索</title>
    <link href="http://yoursite.com/2019/03/21/%E4%BB%A5%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%BA%E7%BA%BF%E7%B4%A2.html"/>
    <id>http://yoursite.com/2019/03/21/以一个例子为线索.html</id>
    <published>2019-03-21T08:37:16.000Z</published>
    <updated>2019-03-26T03:25:46.572Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们有如下模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>&#123;&#123;test&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和这样一段 js 代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段<code>js</code>代码很简单，我们只是简单的调用了<code>Vue</code>，传递了两个选项<code>el</code>和<code>data</code>。这段代码的最终效果就是在页面中渲染如下的<code>DOM</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code></code>被替换成了<code>1</code>，并且当我们尝试修改<code>data.set</code>的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$data.test = <span class="number">2</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">vm.test = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>那么页面的<code>DOM</code>也会随之变化为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们从<code>new Vue()</code>的操作开始分析，从<a href="/2019/03/20/Vue构造函数.html">Vue 构造函数</a>这章中我们得知<code>Vue</code>构造函数定义在<code>src/core/instance/index.js</code>中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">        warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一目了然，这里首先进行了一个判断，在非生产环境不通过<code>new</code>操作符执行<code>Vue</code>函数时，会给予一个警告，然后调用了<code>_init</code>方法，<code>_init</code>方法是在<code>initMixin</code>方法中添加到<code>Vue.prototype</code>上的，<code>initMixin</code>方法是在<code>src/core/instance/init.js</code>中声明的，并把 options 作为参数传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">options = &#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看看<code>_init</code>方法的具体代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line"><span class="comment">// a uid</span></span><br><span class="line">vm._uid = uid++</span><br></pre></td></tr></table></figure><ol><li>把当前实例对象赋给变量 vm</li><li>往 vm 实例上添加了一个唯一标识_uid，其值为<code>uid</code>，<code>uid</code>是在<code>initMixin</code>上发定义的初始化为 0，每次创建一个<code>Vue</code>实例后，<code>uid</code>的值便会加 1</li></ol><figure class="highlight javascript"><figcaption><span>性能追踪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTag, endTag</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    mark(startTag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>config.performance</code>来自于<code>src/core/config.js</code>，<code>Vue</code>提供了全局配置<code>Vue.config.performance</code>，我们可以通过将其设置为<code>true</code>，即可开启性能追踪，你可以追踪四个场景的性能：<ol><li>组件初始化（<code>component init</code>），也就是上面的代码</li><li>编译（<code>compiler</code>），将模板（<code>template</code>）编译成渲染函数</li><li>渲染（<code>render</code>），其实就是渲染函数执行并且生成虚拟 DOM（<code>vnode</code>）的性能</li><li>打补丁，将虚拟 DOM 渲染成真实 DOM 的性能</li></ol></li><li><p><code>mark</code>与<code>measure</code>的定义来自于<code>src/core/util/perf.js</code>，实际上调用的 window.performance.mark 与 window.performance.measure</p> <figure class="highlight javascript"><figcaption><span>src/core/util/perf.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> mark</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> measure</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> perf = inBrowser &amp;&amp; <span class="built_in">window</span>.performance</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures) &#123;</span><br><span class="line">        mark = <span class="function"><span class="params">tag</span> =&gt;</span> perf.mark(tag)</span><br><span class="line">        measure = <span class="function">(<span class="params">name, startTag, endTag</span>) =&gt;</span> &#123;</span><br><span class="line">            perf.measure(name, startTag, endTag)</span><br><span class="line">            perf.clearMarks(startTag)</span><br><span class="line">            perf.clearMarks(endTag)</span><br><span class="line">            <span class="comment">// perf.clearMeasures(name)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><figcaption><span>window.performance demo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> perf = <span class="built_in">window</span>.performance</span><br><span class="line"><span class="keyword">const</span> startTag = <span class="string">'perf-start'</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="string">'perf-end'</span></span><br><span class="line"></span><br><span class="line">perf &amp;&amp; perf.mark(startTag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (perf) &#123;</span><br><span class="line">    perf.mark(endTag)</span><br><span class="line">    perf.measure(<span class="string">'performance test'</span>, startTag, endTag)</span><br><span class="line">    <span class="built_in">console</span>.log(perf.getEntries())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Chorme中可通过<code>Performance Tab</code>下的<code>Timings</code>查看记录的性能</p><p><img src="/assets/vue/theory/devtool-performance.jpg" width="500" title="View Performance Record By Chrome Devtool" alt="devtool-performance.jpg"></p></li></ol><figure class="highlight javascript"><figcaption><span>性能追踪中间的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">vm._isVue = <span class="literal">true</span></span><br><span class="line"><span class="comment">// merge options</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// expose real self</span></span><br><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码是性能追踪代码中间的代码，主要做了以下几件事：</p><ol><li>在<code>Vue</code>实例上增加了<code>_isVue</code>属性，用来表示一个对象是否是<code>Vue</code>实例。这样可以避免被响应系统观测（其实在其它地方也有用到，但是宗旨是一样的）</li><li>判断<code>options._isComponent</code>属性是否存在（该属性是调用<code>Vue.component</code>方法时，追加的一个内部属性），如果存在，TODO:，如果不存在，往当前实例上追加<code>$options</code>属性（在上面代码中一系列init的初始化方法中用到）</li><li>调用了一系列的init初始化方法</li></ol><p>下一篇：<a href="/2019/03/26/Vue选项的规范化.html">Vue选项的规范化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设我们有如下模板：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>了解Vue这个项目</title>
    <link href="http://yoursite.com/2019/03/20/%E4%BA%86%E8%A7%A3Vue%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE.html"/>
    <id>http://yoursite.com/2019/03/20/了解Vue这个项目.html</id>
    <published>2019-03-20T12:59:45.000Z</published>
    <updated>2019-03-26T03:22:59.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在学习Vue源码，学习的路线主要是参考<a href="http://hcysun.me/vue-design/art/2vue-constructor.html" target="_blank" rel="noopener">Vue技术内幕</a>来的，阅读的过程中按照讲解一步步从浅入深，感觉自己还是跟的上的，但是当看完了一半的文章后，回过来想想又感觉自己什么都不懂，再往下读下去，我认为会非常吃力，并且最后的结果很可能是对于某一个知识点自己能稍微说的上来，但是对于整体的架构，某行具体的代码，为什么要这么做，这么做是为了解决什么样的问题等等一无所知，同时也为了以后能有个贯穿整体的复习资料再加上原文有些图片丢失了= =，就决定读完一章，便自己总结一下本章的内容，可能很多东西会跟原文的内容一致，毕竟有蝴蝶效应，但是聊胜于无，毕竟记录下来了，就相当于以自己的思路贯穿了一遍。</p><h1 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h1><p>果然，很多东西不定一个目标是无法达到自己的想要的目的，学习更是如此，每天的工作量不同导致自己看文章拖泥带水，有空的时候看看，没空的时候就不看，说实话，时间都是有的，没空只是安慰自己的借口，工作很累，下班了想要好好休息休息，我总是这么想，导致自己学东西特别的慢，不想利用自己业余时间去学习这个想法是阻碍我前进的根本原因，所以在这里立一个flag，一周之内也就是下周三（2019.3.27号）之前完成Vue源码的阅读，并产出相关的读书记录，希望这个flag能有用吧= =</p><h1 id="Vue目录分析"><a href="#Vue目录分析" class="headerlink" title="Vue目录分析"></a>Vue目录分析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">├── scripts ------------------------------- 构建相关的文件，一般情况下我们不需要动</span><br><span class="line">│   ├── git-hooks ------------------------- 存放git钩子的目录</span><br><span class="line">│   ├── alias.js -------------------------- 路径别名配置</span><br><span class="line">│   ├── config.js ------------------------- 生成rollup配置的文件</span><br><span class="line">│   ├── build.js -------------------------- 对 config.js 中所有的rollup配置进行构建</span><br><span class="line">│   ├── ci.sh ----------------------------- 持续集成运行的脚本</span><br><span class="line">│   ├── release.sh ------------------------ 用于自动发布新版本的脚本</span><br><span class="line">├── dist ---------------------------------- 构建后文件的输出目录</span><br><span class="line">├── examples ------------------------------ 存放一些使用Vue开发的应用案例</span><br><span class="line">├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)</span><br><span class="line">├── packages ------------------------------ 存放独立发布的包的目录</span><br><span class="line">├── <span class="built_in">test</span> ---------------------------------- 包含所有测试文件</span><br><span class="line">├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码</span><br><span class="line">│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数</span><br><span class="line">│   ├── core ------------------------------ 存放通用的，与平台无关的代码</span><br><span class="line">│   │   ├── observer ---------------------- 响应系统，包含数据观测的核心代码</span><br><span class="line">│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码</span><br><span class="line">│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码</span><br><span class="line">│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码</span><br><span class="line">│   │   ├── components -------------------- 包含抽象出来的通用组件</span><br><span class="line">│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码</span><br><span class="line">│   ├── platforms ------------------------- 包含平台特有的相关代码，不同平台的不同构建的入口文件也在这里</span><br><span class="line">│   │   ├── web --------------------------- web平台</span><br><span class="line">│   │   │   ├── entry-runtime.js ---------- 运行时构建的入口，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意</span><br><span class="line">│   │   │   ├── entry-runtime-with-compiler.js -- 独立构建版本的入口，它在 entry-runtime 的基础上添加了模板(template)到render函数的编译器</span><br><span class="line">│   │   │   ├── entry-compiler.js --------- vue-template-compiler 包的入口文件</span><br><span class="line">│   │   │   ├── entry-server-renderer.js -- vue-server-renderer 包的入口文件</span><br><span class="line">│   │   │   ├── entry-server-basic-renderer.js -- 输出 packages/vue-server-renderer/basic.js 文件</span><br><span class="line">│   │   ├── weex -------------------------- 混合应用</span><br><span class="line">│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包</span><br><span class="line">│   ├── shared ---------------------------- 包含整个代码库通用的代码</span><br><span class="line">├── package.json -------------------------- 不解释</span><br><span class="line">├── yarn.lock ----------------------------- yarn 锁定文件</span><br><span class="line">├── .editorconfig ------------------------- 针对编辑器的编码风格配置文件</span><br><span class="line">├── .flowconfig --------------------------- flow 的配置文件</span><br><span class="line">├── .babelrc ------------------------------ babel 配置文件</span><br><span class="line">├── .eslintrc ----------------------------- eslint 配置文件</span><br><span class="line">├── .eslintignore ------------------------- eslint 忽略配置</span><br><span class="line">├── .gitignore ---------------------------- git 忽略配置</span><br></pre></td></tr></table></figure><h1 id="Vue的不同构建输出"><a href="#Vue的不同构建输出" class="headerlink" title="Vue的不同构建输出"></a>Vue的不同构建输出</h1><p>打开文件scripts/config.js，其中定义了builds对象，builds对象针对平台、环境、构建输出的模块方式、版本、使用方的不同进行了不同的配置，总结为：</p><ul><li>构建平台：web（浏览器）、web-server（服务器）、weex（开发原生应用程序的框架）。</li><li>版本：运行时版本、编译器、完整版本（运行时版本+编译器）。编译器提供了能够在运行时把template编译成render函数的能力，运行时版本比完整版本体积大约小于30%，同时提高了性能。</li><li>环境：development、production。（TODO:具体的差别）</li><li>模块：CommonJS、UMD、ES Module。UMD使得你可以直接通过<code>&lt;script&gt;</code>标签引用，而CommonJS形式的模块就是为<code>webpack 1</code>和<code>browserify</code>提供的，它们在加载模块的时候不能直接加载<code>ES Module</code>，而<code>Webpack 2</code>和<code>Rollup</code>是可以直接加载<code>ES Module</code>的，所以就有了<code>es</code>形式的模块输出。</li><li>使用方：Bundlers（打包工具，例如Webpack，Browserify等）、Browser（浏览器）</li></ul><p>TODO:下方列出了所有的构建项以及它们的大致区别，当然也不仅仅只是这些简单的区别，具体的区别还需要进一步分析。</p><table><thead><tr><th>构建名称</th><th>平台</th><th>版本</th><th>环境</th><th>模块</th><th>使用方</th></tr></thead><tbody><tr><td>web-runtime-cjs-dev</td><td>web</td><td>运行时版</td><td>development</td><td>CommonJS</td><td>Bundlers</td></tr><tr><td>web-runtime-cjs-prod</td><td>web</td><td>运行时版</td><td>production</td><td>CommonJS</td><td>Bundlers</td></tr><tr><td>web-full-cjs-dev</td><td>web</td><td>完整版</td><td>development</td><td>CommonJS</td><td>Browser</td></tr><tr><td>web-full-cjs-prod</td><td>web</td><td>完整版</td><td>production</td><td>CommonJS</td><td>Browser</td></tr><tr><td>web-runtime-esm</td><td>web</td><td>运行时版本</td><td>不区分</td><td>ES Module</td><td>Bundlers</td></tr><tr><td>web-full-esm</td><td>web</td><td>完整版</td><td>不区分</td><td>ES Module</td><td>Bundlers</td></tr><tr><td>web-full-esm-browser-dev</td><td>web</td><td>完整版</td><td>development</td><td>ES Module</td><td>Browser</td></tr><tr><td>web-full-esm-browser-prod</td><td>web</td><td>完整版</td><td>production</td><td>ES Module</td><td>Browser</td></tr><tr><td>web-runtime-dev</td><td>web</td><td>运行时版</td><td>development</td><td>UMD</td><td>Browser</td></tr><tr><td>web-runtime-prod</td><td>web</td><td>运行时版</td><td>production</td><td>UMD</td><td>Browser</td></tr><tr><td>web-full-dev</td><td>web</td><td>完整版</td><td>development</td><td>UMD</td><td>Browser</td></tr><tr><td>web-full-prod</td><td>web</td><td>完整版</td><td>production</td><td>UMD</td><td>Browser</td></tr><tr><td>web-compiler</td><td>web</td><td>编译器</td><td>不区分</td><td>CommonJS</td><td>Bundlers</td></tr><tr><td>web-compiler-browser</td><td>web</td><td>编译器</td><td>development</td><td>UMD</td><td>Browser</td></tr><tr><td>web-server-renderer-dev</td><td>web-server</td><td>不区分</td><td>development</td><td>CommonJS</td><td>不区分</td></tr><tr><td>web-server-renderer-prod</td><td>web-server</td><td>不区分</td><td>production</td><td>CommonJS</td><td>不区分</td></tr><tr><td>web-server-renderer-webpack-server-plugin</td><td>web-server</td><td>不区分</td><td>不区分</td><td>CommonJS</td><td>Webpack Server</td></tr><tr><td>web-server-renderer-webpack-client-plugin</td><td>web-server</td><td>不区分</td><td>不区分</td><td>CommonJS</td><td>Webpack Client</td></tr><tr><td>weex-factory</td><td>weex</td><td>运行时版</td><td>不区分</td><td>CommonJS</td><td>不区分</td></tr><tr><td>weex-framework</td><td>weex</td><td>运行时版</td><td>不区分</td><td>CommonJS</td><td>不区分</td></tr><tr><td>weex-compiler</td><td>weex</td><td>编译器</td><td>不区分</td><td>CommonJS</td><td>Weex’s Webpack Loader</td></tr></tbody></table><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>package.json中的一些字段和构建命令说明如下：</p><ul><li>main：运行时版本，<code>cjs</code>模块，用于<code>webpack 1</code>或<code>browserify</code></li><li>module：运行时版本，<code>es</code>模块，用于<code>webpack 2+</code>或<code>Rollup</code></li><li>dev：构建完整版<code>umd</code>模块的Vue</li><li>dev:cjs：构建运行时<code>cjs</code>模块的Vue</li><li>dev:esm：构建运行时<code>es</code>模块的Vue</li><li>dev:ssr：构建<code>web-server-renderer</code>包</li><li>dev:compiler：构建<code>Compiler</code>包</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"dist/vue.runtime.common.js"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"dist/vue.runtime.esm.js"</span>,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"dev"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span>,</span><br><span class="line">        <span class="attr">"dev:cjs"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev"</span>,</span><br><span class="line">        <span class="attr">"dev:esm"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm"</span>,</span><br><span class="line">        <span class="attr">"dev:test"</span>: <span class="string">"karma start test/unit/karma.dev.config.js"</span>,</span><br><span class="line">        <span class="attr">"dev:ssr"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-server-renderer"</span>,</span><br><span class="line">        <span class="attr">"dev:compiler"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-compiler "</span>,</span><br><span class="line">        <span class="attr">"dev:weex"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-framework"</span>,</span><br><span class="line">        <span class="attr">"dev:weex:factory"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-factory"</span>,</span><br><span class="line">        <span class="attr">"dev:weex:compiler"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-compiler "</span>,</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">        <span class="attr">"build:ssr"</span>: <span class="string">"npm run build -- web-runtime-cjs,web-server-renderer"</span>,</span><br><span class="line">        <span class="attr">"build:weex"</span>: <span class="string">"npm run build -- weex"</span>,</span><br><span class="line">        <span class="attr">"test"</span>: <span class="string">"npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr &amp;&amp; npm run test:weex"</span>,</span><br><span class="line">        <span class="attr">"test:unit"</span>: <span class="string">"karma start test/unit/karma.unit.config.js"</span>,</span><br><span class="line">        <span class="attr">"test:cover"</span>: <span class="string">"karma start test/unit/karma.cover.config.js"</span>,</span><br><span class="line">        <span class="attr">"test:e2e"</span>: <span class="string">"npm run build -- web-full-prod,web-server-basic-renderer &amp;&amp; node test/e2e/runner.js"</span>,</span><br><span class="line">        <span class="attr">"test:weex"</span>: <span class="string">"npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.js"</span>,</span><br><span class="line">        <span class="attr">"test:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.js"</span>,</span><br><span class="line">        <span class="attr">"test:sauce"</span>: <span class="string">"npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2"</span>,</span><br><span class="line">        <span class="attr">"test:types"</span>: <span class="string">"tsc -p ./types/test/tsconfig.json"</span>,</span><br><span class="line">        <span class="attr">"lint"</span>: <span class="string">"eslint src scripts test"</span>,</span><br><span class="line">        <span class="attr">"flow"</span>: <span class="string">"flow check"</span>,</span><br><span class="line">        <span class="attr">"sauce"</span>: <span class="string">"karma start test/unit/karma.sauce.config.js"</span>,</span><br><span class="line">        <span class="attr">"bench:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; node benchmarks/ssr/renderToString.js &amp;&amp; node benchmarks/ssr/renderToStream.js"</span>,</span><br><span class="line">        <span class="attr">"release"</span>: <span class="string">"bash scripts/release.sh"</span>,</span><br><span class="line">        <span class="attr">"release:weex"</span>: <span class="string">"bash scripts/release-weex.sh"</span>,</span><br><span class="line">        <span class="attr">"release:note"</span>: <span class="string">"node scripts/gen-release-note.js"</span>,</span><br><span class="line">        <span class="attr">"commit"</span>: <span class="string">"git-cz"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一篇：<a href="/2019/03/20/Vue构造函数.html">Vue构造函数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在学习Vue源码，学习的路线主要是参考&lt;a href=&quot;http://hcysun.me/vue-design/art/
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>通过Vue源码学到的知识</title>
    <link href="http://yoursite.com/2019/03/20/%E9%80%9A%E8%BF%87Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86.html"/>
    <id>http://yoursite.com/2019/03/20/通过Vue源码学到的知识.html</id>
    <published>2019-03-20T12:20:35.000Z</published>
    <updated>2019-03-27T12:42:59.548Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>src/shared/util.js</code>:</p> <figure class="highlight javascript"><figcaption><span>camelizeRE</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> camelize = cached(</span><br><span class="line">    (str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : <span class="string">''</span>))</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> <code>String.prototype.replace</code>方法第二个参数可以传一个 Callback<code>Function</code>，其返回值将会替换匹配到的字符串</p><ul><li>如果第一个参数为字符串：Callback 的参数为（第一个匹配到的字符串，匹配到的字符串的起始索引，字符串本身）</li><li>如果第一个参数为正则表达式：Callback 的参数为（匹配到的字符串，…所有捕获组，匹配到的字符串的起始索引, 字符串本身）</li></ul></li><li><p><code>src/core/util/options.js</code></p> <figure class="highlight javascript"><figcaption><span>validateComponentName</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateComponentName</span>(<span class="params">name: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^[a-zA-Z][\\-\\.0-9_<span class="subst">$&#123;unicodeLetters&#125;</span>]*$`</span>).test(name)) &#123;</span><br><span class="line">        warn(<span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> + <span class="string">'should conform to valid custom element name in html5 specification.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isBuiltInTag(name) || config.isReservedTag(name)) &#123;</span><br><span class="line">        warn(<span class="string">'Do not use built-in or reserved HTML elements as component '</span> + <span class="string">'id: '</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个字符串时如果字符串中包含单<code>\</code>，实际上会被去除，<code>\\</code>的意思才表示<code>\</code></li><li>声明正则表达式时包含单<code>\</code>，会报错</li><li><p>正则表达式定义范围时<code>[]</code>，里面的类似于<code>*.</code>等字符不进行转义处理与进行转义处理的效果是一致的，而<code>\w</code>必须进行转义处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abcd\</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'\abcd\\'</span></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/abcde\/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ reg1的效果与reg2的效果一致</span></span><br><span class="line"><span class="regexp">let reg1 = /</span>[.*]/</span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/[\.\*]/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>调用<code>Object.defineProperty</code>时，只设置<code>get</code>不设置<code>set</code>，则其相当于<code>readonly</code></p></li><li><p>window.performance的运用，在<code>Chrome devtool</code>中的<code>Performance -&gt; Timing</code>中可以看到性能记录信息</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> perf = <span class="built_in">window</span>.performance</span><br><span class="line"><span class="keyword">const</span> startTag = <span class="string">'perf-start'</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="string">'perf-end'</span></span><br><span class="line"></span><br><span class="line">perf &amp;&amp; perf.mark(startTag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (perf) &#123;</span><br><span class="line">    perf.mark(endTag)</span><br><span class="line">    perf.measure(<span class="string">'performance test'</span>, startTag, endTag)</span><br><span class="line">    <span class="built_in">console</span>.log(perf.getEntries())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.keys</code>与<code>Reflect.ownKeys</code>都是遍历对象自身的属性，但是<code>Object.keys</code>无法遍历出<code>Symbol</code>属性且受<code>enumerable</code>影响，而<code>Reflect.ownKeys</code>可以遍历出<code>Sumbol</code>属性且不受<code>enumerable</code>影响</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;src/shared/util.js&lt;/code&gt;:&lt;/p&gt;
 &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaption&gt;&lt;span&gt;camelizeRE&lt;/span&gt;&lt;/figcaption&gt;&lt;tabl
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue构造函数</title>
    <link href="http://yoursite.com/2019/03/20/Vue%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html"/>
    <id>http://yoursite.com/2019/03/20/Vue构造函数.html</id>
    <published>2019-03-20T12:19:50.000Z</published>
    <updated>2019-03-26T03:23:54.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue构造函数的原型"><a href="#Vue构造函数的原型" class="headerlink" title="Vue构造函数的原型"></a>Vue构造函数的原型</h1><p>以<code>npm run dev</code>为切入点，查看<code>package.json</code>中的<code>dev script</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span></span><br></pre></td></tr></table></figure><p>找到scripts下的config.js，builds对象中包含了不同的构建配置，具体有哪些配置以及它们之间有什么不同请阅读<a href="/2019/03/20/了解Vue这个项目.html">了解Vue这个项目</a>，查找构建目标<code>web-full-dev</code>对应的配置，其对应的入口文件为<code>web/entry-runtime-with-compiler.js</code>，<code>web</code>所指向的目录在路径别名配置文件<code>scripts/alias.js</code>中，其指向的是<code>src/platforms/web</code>目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> builds = &#123;</span><br><span class="line">  <span class="comment">// Runtime+compiler development build (Browser)</span></span><br><span class="line">  <span class="string">'web-full-dev'</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">'web/entry-runtime-with-compiler.js'</span>),</span><br><span class="line">    dest: resolve(<span class="string">'dist/vue.js'</span>),</span><br><span class="line">    format: <span class="string">'umd'</span>,</span><br><span class="line">    env: <span class="string">'development'</span>,</span><br><span class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>打开<code>src/platforms/web/entry-runtime-with-compiler.js</code>目录，有这么一句<code>import Vue from &#39;./runtime/index&#39;</code>，依次向上查找到声明Vue的文件为<code>src/core/instance/index.js</code>，查找路径为下：</p><ol><li>src/platforms/web/entry-runtime-with-compiler.js：import Vue from ‘./runtime/index’</li><li>src/platforms/web/runtime/index.js：import Vue from ‘core/index’（core指的是src/core，请查看别名文件<code>scripts/alias.js</code>）</li><li>src/core/index.js：import Vue from ‘./instance/index’</li><li>src/core/instance/index.js：End</li></ol><p><code>src/core/instance/index.js</code>文件的内容如下图，其中所调用的各个方法的作用为：</p><figure class="highlight javascript"><figcaption><span>src/core/instance/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><ol><li><p>initMixin</p><ol><li>定义了方法：Vue.prototype._init，该方法是内部初始化的一个方法，在Vue构造函数中被调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ... _init 方法的函数体，此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>stateMixin</p><ol><li><p>定义了属性：Vue.prototype.$data代理了Vue实例的_data属性，Vue.prototype.$props代理了Vue实例的_props属性，在非生产环境修改_data和_props会给予错误提示，<a href="https://cn.vuejs.org/v2/api/index.html#vm-data" target="_blank" rel="noopener">属性介绍</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data &#125;</span><br><span class="line"><span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._props &#125;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params">newData: Object</span>) </span>&#123;</span><br><span class="line">    warn(</span><br><span class="line">        <span class="string">'Avoid replacing instance root $data. '</span> +</span><br><span class="line">        <span class="string">'Use nested data properties instead.'</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    )</span><br><span class="line">    &#125;</span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    warn(<span class="string">`$props is readonly.`</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$props'</span>, propsDef)</span><br></pre></td></tr></table></figure></li><li><p>定义了方法：Vue.prototype.$set，Vue.prototype.$delete，Vue.prototype.$watch，<a href="https://cn.vuejs.org/v2/api/index.html#vm-watch" target="_blank" rel="noopener">方法介绍</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$set = set</span><br><span class="line">Vue.prototype.$<span class="keyword">delete</span> = del</span><br><span class="line"></span><br><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>eventsMixin</p><ol><li><p>定义了方法：Vue.prototype.$on，Vue.prototype.$once，Vue.prototype.$off，Vue.prototype.$emmit，<a href="https://cn.vuejs.org/v2/api/index.html#vm-on" target="_blank" rel="noopener">方法介绍</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>lifecycleMixin</p><ol><li><p>定义了方法：Vue.prototype._update（内部使用），Vue.prototype.$forceUpdate，Vue.prototype.$destory，<a href="https://cn.vuejs.org/v2/api/index.html#vm-forceUpdate" target="_blank" rel="noopener">方法介绍</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;&#125;</span><br><span class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>renderMixin</p><ol><li><p>以Vue.prototype为参数调用了<code>src/core/instance/render-helpers/index.js</code>中的<code>installRenderHelpers</code>方法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installRenderHelpers</span> (<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">    target._o = markOnce</span><br><span class="line">    target._n = toNumber</span><br><span class="line">    target._s = toString</span><br><span class="line">    target._l = renderList</span><br><span class="line">    target._t = renderSlot</span><br><span class="line">    target._q = looseEqual</span><br><span class="line">    target._i = looseIndexOf</span><br><span class="line">    target._m = renderStatic</span><br><span class="line">    target._f = resolveFilter</span><br><span class="line">    target._k = checkKeyCodes</span><br><span class="line">    target._b = bindObjectProps</span><br><span class="line">    target._v = createTextVNode</span><br><span class="line">    target._e = createEmptyVNode</span><br><span class="line">    target._u = resolveScopedSlots</span><br><span class="line">    target._g = bindObjectListeners</span><br><span class="line">    target._d = bindDynamicKeys</span><br><span class="line">    target._p = prependModifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义了方法：Vue.prototype.$nextTick、Vue.prototype._render（内部使用），<a href="https://cn.vuejs.org/v2/api/index.html#vm-nextTick" target="_blank" rel="noopener">方法介绍</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;&#125;</span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="Vue-构造函数的静态属性和方法（全局API）"><a href="#Vue-构造函数的静态属性和方法（全局API）" class="headerlink" title="Vue 构造函数的静态属性和方法（全局API）"></a>Vue 构造函数的静态属性和方法（全局API）</h1><p>按照查找Vue构造函数时的文件路径回溯，打开<code>src/core/index.js</code>文件，其内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FunctionalRenderContext &#125; <span class="keyword">from</span> <span class="string">'core/vdom/create-functional-component'</span></span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">  get: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$ssrContext'</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// expose FunctionalRenderContext for ssr runtime helper installation</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'FunctionalRenderContext'</span>, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><ol><li><p>调用<code>src/core/global-api/index.js</code>中的<code>initGlobalAPI</code>方法</p><ol><li><p>定义了属性Vue.config，代理了<code>src/core/config.js</code>导出的对象，并且在非生产环境修改时给予错误提示。<a href="https://cn.vuejs.org/v2/api/index.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">属性介绍</a></p>  <figure class="highlight javascript"><figcaption><span>src/core/config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Option merge strategies (used in core/util/options)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">optionMergeStrategies: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Whether to suppress warnings.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">silent: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Show production mode tip message on boot?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">productionTip: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Whether to enable devtools</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">devtools: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Whether to record perf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Error handler for watcher errors</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">errorHandler: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Warn handler for watcher warns</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">warnHandler: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Ignore certain custom elements</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ignoredElements: [],</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Custom user key aliases for v-on</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// $flow-disable-line</span></span><br><span class="line">keyCodes: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check if a tag is reserved so that it cannot be registered as a</span></span><br><span class="line"><span class="comment">* component. This is platform-dependent and may be overwritten.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">isReservedTag: no,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check if an attribute is reserved so that it cannot be used as a component</span></span><br><span class="line"><span class="comment">* prop. This is platform-dependent and may be overwritten.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">isReservedAttr: no,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check if a tag is an unknown element.</span></span><br><span class="line"><span class="comment">* Platform-dependent.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">isUnknownElement: no,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Get the namespace of an element</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getTagNamespace: noop,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Parse the real tag name for the specific platform.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">parsePlatformTagName: identity,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check if an attribute must be bound using property, e.g. value</span></span><br><span class="line"><span class="comment">* Platform-dependent.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mustUseProp: no,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform updates asynchronously. Intended to be used by Vue Test Utils</span></span><br><span class="line"><span class="comment">* This will significantly reduce performance if set to false.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Exposed for legacy reasons</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_lifecycleHooks: LIFECYCLE_HOOKS</span><br><span class="line">&#125;: Config)</span><br></pre></td></tr></table></figure></li><li><p>定义了Vue.util，该对象下有4个属性：warn、extend、mergeOptions、defineReactive。这4个属性来自<code>src/core/util/index.js</code>。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exposed util methods.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on</span></span><br><span class="line"><span class="comment">// them unless you are aware of the risk.</span></span><br><span class="line">Vue.util = &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里有一段注释，大概意思是 Vue.util 以及 util 下的四个方法都不被认为是公共API的一部分，要避免依赖他们，但是你依然可以使用，只不过风险你要自己控制。并且，在官方文档上也并没有介绍这个全局API，所以能不用尽量不要用。</p></li><li><p>定义了Vue.set、Vue.delete、Vue.nextTick、Vue.observable、Vue.options，<a href="https://cn.vuejs.org/v2/api/index.html#%E5%85%A8%E5%B1%80-API" target="_blank" rel="noopener">属性介绍</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.set = set</span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.6 explicit observable API</span></span><br><span class="line">Vue.observable = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(obj: T): T =&gt; &#123;</span></span><br><span class="line"><span class="xml">    observe(obj)</span></span><br><span class="line"><span class="xml">    return obj</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Vue.options = &#123;</span></span><br><span class="line"><span class="xml">    components: &#123;</span></span><br><span class="line"><span class="xml">        KeepAlive</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    directives: Object.create(null),</span></span><br><span class="line"><span class="xml">    filters: Object.create(null),</span></span><br><span class="line"><span class="xml">    _base: Vue</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>调用了以下方法，<a href="https://cn.vuejs.org/v2/api/index.html#%E5%85%A8%E5%B1%80-API" target="_blank" rel="noopener">全局API介绍</a></p><ol><li>initUse：定义了Vue.use</li><li>initMixin：定义了Vue.mixin</li><li>initExtend：定义了Vue.cid、Vue.extend</li><li>initAssetRegisters：定义了Vue.compontent、Vue.directive、Vue.filter</li></ol></li></ol></li><li>定义了Vue.$isServer、Vue.$ssrContext、Vue.version（<strong>VERSION</strong>在<code>scripts/config.js</code>中定义）</li></ol><h1 id="Vue-平台化的包装"><a href="#Vue-平台化的包装" class="headerlink" title="Vue 平台化的包装"></a>Vue 平台化的包装</h1><p>这节主要说了几件事</p><ol><li><code>src/core</code>目录下存放的是与平台无关的代码</li><li><code>src/platforms</code>下的目录作用是针对<code>web</code>和<code>weex</code>平台进行不同的包装，例如Vue.config（代理的是<code>core/config.js</code>导出的对象，上文有说到）的默认属性，因平台的不同，其属性会被覆盖，例如：<code>src/platforms/runtime/index.js</code>中干了几件事：<ol><li>设置平台化的<code>Vue.config</code></li><li>在<code>Vue.options</code>中混合了两个指令（<code>directives</code>），分别是<code>model</code>和<code>show</code></li><li>在<code>Vue.options</code>中混合了两个组件（<code>components</code>），分别是<code>Transition</code>和<code>TransitionGroup</code></li><li>在<code>Vue.prototype</code>上添加了两个方法：<code>__patch</code>和<code>$mount</code></li></ol></li></ol><h2 id="with-compiler"><a href="#with-compiler" class="headerlink" title="with compiler"></a>with compiler</h2><ol><li><code>运行时版</code>的入口文件<code>src/platforms/web/entry-runtime.js</code>导出的<code>Vue</code>就到<code>./runtime/index.js</code>为止，Vue构造函数和原型包含的属性和方法就是上面所有的内容</li><li><code>完整版</code>导出的<code>Vue</code>在运行时版上多了个<code>compiler</code>，具体查看<code>src/platforms/web/entry-runtime-with-compiler.js</code>，这个文件对<code>Vue</code>的影响有两个：<ol><li>重写了Vue.prototype.$mount的方法</li><li>增加了Vue.compile全局API</li></ol></li></ol><p>下一篇：<a href="/2019/03/21/以一个例子为线索.html">以一个例子为线索</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue构造函数的原型&quot;&gt;&lt;a href=&quot;#Vue构造函数的原型&quot; class=&quot;headerlink&quot; title=&quot;Vue构造函数的原型&quot;&gt;&lt;/a&gt;Vue构造函数的原型&lt;/h1&gt;&lt;p&gt;以&lt;code&gt;npm run dev&lt;/code&gt;为切入点，查看&lt;code&gt;
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/"/>
    
      <category term="原理" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="VueConstructor" scheme="http://yoursite.com/tags/VueConstructor/"/>
    
  </entry>
  
  <entry>
    <title>vscode+typescript问题记录</title>
    <link href="http://yoursite.com/2019/03/19/vscode-typescript%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>http://yoursite.com/2019/03/19/vscode-typescript问题记录.html</id>
    <published>2019-03-19T13:14:55.000Z</published>
    <updated>2019-03-19T13:52:50.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><h2 id="VSCode的ESLint扩展支持-ts-tsx文件"><a href="#VSCode的ESLint扩展支持-ts-tsx文件" class="headerlink" title="VSCode的ESLint扩展支持.ts,.tsx文件"></a>VSCode的ESLint扩展支持.ts,.tsx文件</h2><p>command+shift+p调出命令面板，选择Open Settings(JSON)，在配置中加入以下内容</p><p><img width="500" src="/assets/typescript/problems/5.jpg" title="settings.json" alt="settings.json"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ESLint&quot;&gt;&lt;a href=&quot;#ESLint&quot; class=&quot;headerlink&quot; title=&quot;ESLint&quot;&gt;&lt;/a&gt;ESLint&lt;/h1&gt;&lt;h2 id=&quot;VSCode的ESLint扩展支持-ts-tsx文件&quot;&gt;&lt;a href=&quot;#VSCode的ESLi
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="typescript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/typescript/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/typescript/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="vsoce" scheme="http://yoursite.com/tags/vsoce/"/>
    
  </entry>
  
  <entry>
    <title>vue+typescript问题记录</title>
    <link href="http://yoursite.com/2019/03/19/vue-typescript%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>http://yoursite.com/2019/03/19/vue-typescript问题记录.html</id>
    <published>2019-03-19T13:14:42.000Z</published>
    <updated>2019-03-19T13:44:50.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含import或export即为模块"><a href="#文件包含import或export即为模块" class="headerlink" title="文件包含import或export即为模块"></a>文件包含import或export即为模块</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img width="500" src="/assets/typescript/problems/1.jpg" title="shims-vue.d.ts" alt="shims-vue.d.ts"></p><p>因为需要在Vue构造函数下追加一些属性而又想把所有Vue相关的类型声明放在一个文件里，所以就直接在shims-vue.d.ts文件中加入了额外的声明，结果发现引入.vue文件时，提示无法找到该模块。</p><p><img width="500" src="/assets/typescript/problems/2.jpg" title="route/index.ts" alt="route/index.ts"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>产生这个问题的原因是因为在ts中，只要最顶层中含有import或者export语法，该文件即为一个模块，如果没有，则声明默认定义在全局作用域下。正因为我们在shims-vue.d.ts中用了import的语法，导致该文件变成了一个模块，所以就导致*.vue的模块声明语句没有在全局作用域中生效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>需要声明在全局作用域下的模块单独放在一个文件，在本案例中，把module ‘*.vue’的声明单独放在shims-vue.d.ts中，其它不需要声明在全局作用域下的，例如本案例中扩展Vue构造函数的声明放在另一个文件即可，如下所示：</p><p><img width="500" src="/assets/typescript/problems/3.jpg" title="shims-vue.d.ts" alt="shims-vue.d.ts"></p><p><img width="500" src="/assets/typescript/problems/4.png" title="vue-extend.d.ts" alt="vue-extend.d.ts"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件包含import或export即为模块&quot;&gt;&lt;a href=&quot;#文件包含import或export即为模块&quot; class=&quot;headerlink&quot; title=&quot;文件包含import或export即为模块&quot;&gt;&lt;/a&gt;文件包含import或export即为模块&lt;/
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="typescript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/typescript/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/typescript/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="vue-cli" scheme="http://yoursite.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>Velocity语法</title>
    <link href="http://yoursite.com/2019/03/12/Velocity%E8%AF%AD%E6%B3%95.html"/>
    <id>http://yoursite.com/2019/03/12/Velocity语法.html</id>
    <published>2019-03-12T05:55:09.000Z</published>
    <updated>2019-03-12T07:18:12.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Velocity基本语法介绍"><a href="#Velocity基本语法介绍" class="headerlink" title="Velocity基本语法介绍"></a>Velocity基本语法介绍</h1><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if($condition)</span><br><span class="line">    ...</span><br><span class="line">#elseif($condition)</span><br><span class="line">    ...</span><br><span class="line">#else</span><br><span class="line">    ...</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li>比较符：== != &gt; &gt;= &lt; &lt;=</li><li>逻辑运算符：&amp;&amp; || !</li><li>运算符：+ - * / %</li></ol><h3 id="常用判断"><a href="#常用判断" class="headerlink" title="常用判断"></a>常用判断</h3><ol><li><p>判断是否为null</p><ul><li>#if(( !$condition) &amp;&amp; (“$!condition” == “”) )</li><li>使用NULL工具：#if( $null.isNull($condition) )</li><li><p>使用#ifnull() 或 #ifnotnull()，要使用这个特性必须在velocity.properties文件中加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdirective = org.apache.velocity.tools.generic.directive.Ifnull</span><br><span class="line">userdirective = org.apache.velocity.tools.generic.directive.Ifnotnull</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断是否为true：#if( $condition == true )</p></li><li>判断是否为null或false：#if( !$condition )</li><li>判断是否为空字符串：#if( $condition == “” )</li><li>判断是否为null或者空字符串：#if( “$!condition” === “” )</li><li>判断是否是一个数字：#if( $condition == 123 )<blockquote><p>Velocity中的==可以直接比较数值，字符串以及其它对象，如果==两侧的对象是不同的类的对象，在比较前会用toString()转换后再比较。所以当$condition的值为123或”123”时，条件都为真</p></blockquote></li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#foreach($val in $arr)</span><br><span class="line">...</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>$velocityCount和$foreach.count可以获得当前循环次数，初始值为1</p><p>$foreach.hasNext用来判断是否存在下一次循环</p><blockquote><p>#break用于用于跳出循环，经测试，在jello框架里无效</p></blockquote><p>当$arr为对象的时候：$val取到的是value，如果需要在遍历对象的过程中，同时取到对象的keys，可以使用entrySet() 或 keySet()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#foreach($item in $!obj.entrySet())</span><br><span class="line">    $!item.key: $!item.value</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#foreach($key in $!obj.keySet())</span><br><span class="line">    $key: $obj.get($key)</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><blockquote><p>注意：这种集合的遍历是无序的，即遍历顺序可能不同于$obj中元素定义的顺序</p></blockquote><h3 id="Range-Operator"><a href="#Range-Operator" class="headerlink" title="Range Operator"></a>Range Operator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#foreach($foo in [1..5])</span><br><span class="line">    $foo</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#foreach($bar in [2..-2])</span><br><span class="line">    $bar</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>以上输出为：</p><p>Example1：1 2 3 4 5<br>Example2：2 1 0 -1 -2</p><blockquote><p>Example2，经测试，在jello框架中不能包含负数</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>$str.charAt(index) 获取指定下标的字符</p><p>$str.substring(begin, end)  end不填，截取begin到字符串末尾，不改变原值</p><p>$str.length() 返回字符串的长度</p><p>$str.toUpperCase() 把字符串转换为大写</p><p>$str.toLowerCase() 把字符串转换为小写</p><p>$str.replace(old, new) 替换字符串中指定的子串</p><p>$str.indexOf($substr) 从字符串头部开始检索是否存在某个子串</p><p>$str.lastIndexOf($substr) 从字符串尾部开始检索是否存在某个子串</p><p>字符串拼接：$str + $str1 或 ${str}oo${str1}：</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set($str = “AA”)</span><br><span class="line"></span><br><span class="line">#set($str1 = “BB”)</span><br><span class="line"></span><br><span class="line">#set($str2 = $str + $str1)</span><br></pre></td></tr></table></figure><p>则${str}oo${str1}的结果为：AAooBB</p><p>字符串转数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set( $intString = “9” )</span><br><span class="line"></span><br><span class="line">#set( $Integer = 0 )</span><br><span class="line"></span><br><span class="line">$Integer.parseInt($intString)</span><br></pre></td></tr></table></figure><p>同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set( $doubleString = “12.3” )</span><br><span class="line"></span><br><span class="line">#set( $Double = 0.0 )</span><br><span class="line"></span><br><span class="line">$Double.parseDouble( $doubleString )</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>$arr.size() 返回数组长度</p><p>$arr.isEmpty() 判断数组是否为空</p><p>$arr.get(index)或$arr[index] 返回数组中指定下标index的值</p><p>$arr.set(1, “test”) 设置数组中指定下标的值</p><p>$arr.add($param) 增加元素</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏的定义：#macro(宏的名称 $参数1 $参数2)</p><p>语句体</p><p>   #end</p><p>宏的调用：#macro($参数1  $参数2)//参数之间用空格隔开</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#macro (tablerows $color $somelist)</span><br><span class="line"></span><br><span class="line">    #foreach($something in $somelist)</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;&lt;td bgColor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    #end</span><br><span class="line"></span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#set($color = “blue”)</span><br><span class="line">#set($arr = [“a”, “b”, “c”, “d”])</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line"></span><br><span class="line">#tablerows($color $arr)</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="http://www.blogjava.net/alexwan/archive/2008/06/07/206473.html" target="_blank" rel="noopener">http://www.blogjava.net/alexwan/archive/2008/06/07/206473.html</a></li><li><a href="http://velocity.apache.org/engine/devel/user-guide.html#variables" target="_blank" rel="noopener">http://velocity.apache.org/engine/devel/user-guide.html#variables</a></li><li><a href="http://wiki.apache.org/velocity/VelocityNullSupport" target="_blank" rel="noopener">http://wiki.apache.org/velocity/VelocityNullSupport</a></li><li><a href="http://wiki.apache.org/velocity/CheckingForNull" target="_blank" rel="noopener">http://wiki.apache.org/velocity/CheckingForNull</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Velocity基本语法介绍&quot;&gt;&lt;a href=&quot;#Velocity基本语法介绍&quot; class=&quot;headerlink&quot; title=&quot;Velocity基本语法介绍&quot;&gt;&lt;/a&gt;Velocity基本语法介绍&lt;/h1&gt;&lt;h2 id=&quot;判断语句&quot;&gt;&lt;a href=&quot;#判
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Velocity" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Velocity/"/>
    
    
      <category term="velocity" scheme="http://yoursite.com/tags/velocity/"/>
    
  </entry>
  
  <entry>
    <title>js-继承的5种方式</title>
    <link href="http://yoursite.com/2019/03/11/js-%E7%BB%A7%E6%89%BF%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <id>http://yoursite.com/2019/03/11/js-继承的5种方式.html</id>
    <published>2019-03-11T08:50:40.000Z</published>
    <updated>2019-03-11T10:25:56.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型基础"><a href="#原型基础" class="headerlink" title="原型基础"></a>原型基础</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; <span class="keyword">this</span>.name &#125;</span> is say something`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal(<span class="string">'animal'</span>)</span><br></pre></td></tr></table></figure><ol><li>往原型上增加属性和方法的原因：如果所有属性和方法都添加在实例上，那么每创建一个实例对象，其都有很多重复的属性和方法，需要耗费大量的内存，且降低了运行效率</li><li>构造函数Animal，其原型链为：Animal =&gt; Animal.prototype =&gt; Object的实例 =&gt; null，Animal.prototype.<strong>proto</strong>.<strong>proto</strong> === null</li><li>实例对象的consturctor属性（实际上这个属性不在实例对象本身上，而是在构造函数的原型上）指向构造函数</li><li>prototype对象的isPrototypeOf方法用来判断是否是某个对象的原型</li><li>实例对象的hasOwnProperty方法判断某个属性是否是实例对象本身的属性</li><li>in操作符用于判断某个属性是否存在于实例对象或其原型上</li><li>instanceof用于判断某个对象是否是某个构造函数的实例</li><li>animal.<strong>proto</strong> === A.prototype</li></ol><h1 id="构造函数的5种继承方法"><a href="#构造函数的5种继承方法" class="headerlink" title="构造函数的5种继承方法"></a>构造函数的5种继承方法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型基础&quot;&gt;&lt;a href=&quot;#原型基础&quot; class=&quot;headerlink&quot; title=&quot;原型基础&quot;&gt;&lt;/a&gt;原型基础&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="extends" scheme="http://yoursite.com/tags/extends/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="http://yoursite.com/2019/03/09/TypeScript%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/03/09/TypeScript笔记.html</id>
    <published>2019-03-09T07:43:06.000Z</published>
    <updated>2019-03-11T08:07:07.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript入门教程"><a href="#TypeScript入门教程" class="headerlink" title="TypeScript入门教程"></a>TypeScript入门教程</h1><ol><li>null和undefined是所有类型的子类型，也就说null和undefined类型的变量可以赋值给任意类型的变量，而void类型的变量却不行。</li><li>在any类型的变量上访问任何属性或者调用任何方法都是允许的，声明一个变量为any后，对它的任何操作，返回的内容的类型都是任意值。</li><li>变量如果在声明的时候，未指定其类型，那么它会被识别为any类型。</li><li><p>当TypeScript不确定一个联合类型的变量是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性和方法。</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure></li><li><p>赋值的时候，变量的形状必须与接口的形状保持一致。</p></li><li><p>接口一旦定义了索引签名，那么确定属性和可选属性的类型都必须是它的类型的子集。</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br></pre></td></tr></table></figure></li><li><p>只读属性的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">89757</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.</span></span><br><span class="line"><span class="comment">// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure></li><li><p>调用函数时，输入多余的（或者少于要求的）参数，是不被允许的，可以使用可选参数。</p></li><li>可选参数后面不允许再出现必须参数了。</li><li>TypeScript会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制了。</li><li>当发生函数重载的时候，TypeScript会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</li><li><p>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="built_in">boolean</span>&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.</span></span><br><span class="line"><span class="comment">// Type 'number' is not comparable to type 'boolean'.</span></span><br></pre></td></tr></table></figure></li><li><p>declare var a 与 var a的区别在于declare并没有对变量a进行声明，在编译结果中会被删除，而var a声明了这个变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">decalre <span class="keyword">var</span> a <span class="comment">// 说明在某处已经声明过改变量</span></span><br><span class="line">a = <span class="number">1</span> <span class="comment">// 对变量重新进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码编译结果</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码编译结果</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>只有function、class和interface可以直接默认导出，其它的变量需要先定义出来，再默认导出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line"><span class="comment">// ERROR: Expression expected.</span></span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当为元组类型的变量添加越界的元素时，它的类型会被限制为元组每个类型的联合类型。</p></li><li><p>枚举项有两种类型：常数项和计算所得项。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="string">"red"</span>.length, Green, Blue&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span></span><br></pre></td></tr></table></figure></li><li><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码编译为：</span></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript入门教程&quot;&gt;&lt;a href=&quot;#TypeScript入门教程&quot; class=&quot;headerlink&quot; title=&quot;TypeScript入门教程&quot;&gt;&lt;/a&gt;TypeScript入门教程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;null和undefined是所
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/TypeScript/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>git结合beyond-compare</title>
    <link href="http://yoursite.com/2019/03/08/git%E7%BB%93%E5%90%88beyond-compare.html"/>
    <id>http://yoursite.com/2019/03/08/git结合beyond-compare.html</id>
    <published>2019-03-08T07:10:44.000Z</published>
    <updated>2019-03-08T07:14:00.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="beyond-compare-无限试用"><a href="#beyond-compare-无限试用" class="headerlink" title="beyond compare 无限试用"></a>beyond compare 无限试用</h1><h2 id="for-mac"><a href="#for-mac" class="headerlink" title="for mac"></a>for mac</h2><ol><li>应用程序 -&gt; beyond cmpare右击显示包内容 -&gt; contents -&gt; macos</li><li>在当前目录下新建文件BCompare.sh，把原来的BCompare重命名为BCompare.real</li><li><p>编辑BCompare.sh，输入以下代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rm <span class="string">"/Users/<span class="variable">$(whoami)</span>/Library/Application Support/Beyond Compare/registry.dat"</span></span><br><span class="line"><span class="string">"`dirname "</span><span class="variable">$0</span><span class="string">"`"</span>/BCompare.real <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p>右击BCompare.sh -&gt; 显示简介 -&gt; 删除文件名后缀.sh</p></li></ol><h1 id="gitconfig配置"><a href="#gitconfig配置" class="headerlink" title=".gitconfig配置"></a>.gitconfig配置</h1><p>.gitconfig位于user下, shift + comand + . 显示隐藏文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    dift = &quot;difftool --dir-diff --no-symlinks&quot;</span><br><span class="line">[diff]</span><br><span class="line">    tool = bcomp</span><br><span class="line">[difftool]</span><br><span class="line">    prompt = false</span><br><span class="line">[difftool &quot;bcomp&quot;]</span><br><span class="line">    trustExitCode = true</span><br><span class="line">    cmd = &quot;/usr/local/bin/bcomp&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;</span><br><span class="line">[merge]</span><br><span class="line">    tool = bcomp</span><br><span class="line">[mergetool]</span><br><span class="line">    prompt = false</span><br><span class="line">[mergetool &quot;bcomp&quot;]</span><br><span class="line">    trustExitCode = true</span><br><span class="line">    cmd = &quot;/usr/local/bin/bcomp&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;</span><br></pre></td></tr></table></figure><ol><li>git dift origin/dev：当前分支与远程dev分支进行比较</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;beyond-compare-无限试用&quot;&gt;&lt;a href=&quot;#beyond-compare-无限试用&quot; class=&quot;headerlink&quot; title=&quot;beyond compare 无限试用&quot;&gt;&lt;/a&gt;beyond compare 无限试用&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="其它技术" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="beyond compare" scheme="http://yoursite.com/tags/beyond-compare/"/>
    
  </entry>
  
  <entry>
    <title>Jekins构建结果与本地构建结果Vue版本不同</title>
    <link href="http://yoursite.com/2019/03/08/Jekins%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9CVue%E7%89%88%E6%9C%AC%E4%B8%8D%E5%90%8C.html"/>
    <id>http://yoursite.com/2019/03/08/Jekins构建结果与本地构建结果Vue版本不同.html</id>
    <published>2019-03-08T07:00:30.000Z</published>
    <updated>2019-03-08T07:09:09.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目迁移到jenkins，通过jenkins进行构建，部署后发现页面报错，但是本地构建出来代码部署后是正常的，报错如下：</p><p><img width="800" src="/assets/webpack/problems/9.png"></p><h1 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h1><ol><li><p>注释webpack插件UglifyJsPlugin插件，不进行代码压缩</p><p> <img width="500" src="/assets/webpack/problems/13.png"></p></li><li><p>对比本地代码与jenkins构建出来的代码，构建输出目录结构如下：<br> <img width="500" src="/assets/webpack/problems/14.png"></p></li><li><p>对比结果</p><ul><li>app.js中只存在一些变量名和Path的不一致，不会产生错误</li><li>manifest.js完全一致</li><li>vendor.js中Vue的版本不一致，jenkins构建出来的Vue版本是2.5.20，本地构建出来的Vue版本是2.5.21，推测是由此产生的错误</li></ul></li><li>用本地构建出的vendor.js替换jenkins构建出的vendor.js，部署到ftp上，发现问题解决了，确认推测是正确的</li><li><p>对比两个Vue版本代码的不同，发现是以下代码影响的：</p><p> <img width="800" src="/assets/webpack/problems/10.png"></p><p> <img width="500" src="/assets/webpack/problems/8.png"></p><p> <img width="500" src="/assets/webpack/problems/12.png"></p><p> 分析：rendList是v-for的实现方法，在Vue2.5.20中，当入参val属于类型: Array, String, Number, Object（非null）时初始化变量ret为数组并进行相应的处理，然后判断ret变量不为undefined和null时，给ret变量添加属性_isVList为true，然后将ret变量返回，ret的类型可能为undefined, Array，当返回undefined时，对undefined进行一些数组的操作就会发生错误，而控制台所报的错误就是因为取了undefined.length导致的，在Vue2.5.21版本修复了这个Bug，如果ret变量为undefined或null时，初始化ret为[]，这样确保rendList的返回值类型始终为Array</p></li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>由上可知，产生改问题的原因如下：</p><ul><li>直接原因： Vue2.5.20版本中存在代码漏洞</li><li>根本原因：jenkins服务器安装的Vue版本不正确，而为什么jenkins服务器安装的vue版本和本地安装的不一致，需要进一步排查，已经排除是node版本导致的原因</li></ul><p>因此，只要把package.json中vue依赖的版本号固定为2.5.21（注意：vue-template-compiler版本需要跟vue版本保持一致），问题就可以解决了，如下图：</p><p><img width="500" src="/assets/webpack/problems/15.png"></p><p><img width="500" src="/assets/webpack/problems/11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目迁移到jenkins，通过jenkins进行构建，部署后发现页面报错，但是本地构建出来代码部署后是正常的，报错如下：&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="打包工具" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>动态加载模块</title>
    <link href="http://yoursite.com/2019/03/08/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97.html"/>
    <id>http://yoursite.com/2019/03/08/动态加载模块.html</id>
    <published>2019-03-08T06:59:10.000Z</published>
    <updated>2019-03-08T07:08:18.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目本地开发通过mockjs进行数据模拟，它是通过重写XMLHttpRequest对象来拦截请求，从而达到纯前端mock，在webpack入口文件main.js中通过require引入mock文件，以下是mock文件和main.js的代码：</p><p>mock file:</p><p><img width="500" src="/assets/webpack/problems/2.png"></p><p>main.js:</p><p><img width="500" src="/assets/webpack/problems/7.png"></p><h2 id="Bug描述"><a href="#Bug描述" class="headerlink" title="Bug描述"></a>Bug描述</h2><p>上线后，发现在部分android手机和少数ios手机上无法加载出页面</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ol><li>通过抓包排除接口&amp;数据问题</li><li>页面注入vConsole发现控制台输出脚本错误，无法识别const关键字</li><li><p>在构建出的js中定位const关键字，如下图：</p><p> <img width="500" src="/assets/webpack/problems/3.png"></p></li><li><p>可以得出问题表面原因是因为某些机型浏览器版本较低，无法识别ES6语法</p></li></ol><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过查看构建后的js与分析发现了三个问题：</p><ol><li>const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？</li><li>为何该const语法没有经过babel转译成ES5语法？</li><li>为何打包出的js没有进行压缩？</li></ol><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？</p><p>webapck构建过程：webpack在构建的时候，会从所有入口文件开始递归查找代码中的require语法和import语法，并生成一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的bundle，而动态require模块webpack也是能够支持的，但会导致所有可能用到的模块都包含在bundle中<a href="https://www.webpackjs.com/guides/dependency-management/" target="_blank" rel="noopener">（详见）</a>，如果代码中依赖条件表达式动态require模块，类似上面的main.js那样，又不想把不需要的模块打包到bundle中，需要遵循以下要求：</p><ol><li>条件表达式中不允许出现变量</li><li>条件表达式不允许执行函数调用</li><li><p>只能进行一些常量的运算，如下：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js会被打包进bundle</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> + <span class="number">1</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js会被打包进bundle</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js不会被打包进bundle</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js不会被打包进bundle</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webapck集成的DefinePlugin插件允许创建一个在编译时可以配置的全局常量<a href="https://www.webpackjs.com/plugins/define-plugin/" target="_blank" rel="noopener">（详见）</a></p></li></ol><p>问题1的原因正是因为违背了上述原则2，调用了字符串的match函数，而我们在webpack配置使用DefinePlugin插件，创建了一个全局常量process.env，从而规避了原则1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">if</span> (!process.env.NODE_ENV.match(<span class="regexp">/production|test/</span>)) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'../mock/index'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack配置</span></span><br><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env'</span>: env</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以把main.js文件中的代码改成以下内容，达到非开发环境不把mock文件打包到bundle中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'../mock/index'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>为何该const语法没有经过babel转译成ES5语法？</p><p>原因是在webpack的配置中，配置了只对src，test目录下的文件执行babel转译<a href="https://www.webpackjs.com/loaders/babel-loader/" target="_blank" rel="noopener">（详见）</a>，而mock文件不在这些目录下，所以没有进行转译</p><p><img width="500" src="/assets/webpack/problems/5.png"></p><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>为何打包出的js没有进行压缩？</p><p>我们对项目进行构建，UglifyJsWebpackPlugin插件会报出如下错误：</p><p><img width="500" src="/assets/webpack/problems/6.png"></p><p>错误问题指向的是打包后的const语法，原因是因为<a href="https://www.webpackjs.com/plugins/uglifyjs-webpack-plugin/" target="_blank" rel="noopener">UglifyJsWebpackPlugin</a>不支持ES6语法，所以在<a href="https://www.webpackjs.com/guides/tree-shaking/" target="_blank" rel="noopener">treeshaking</a>的时候，遇到const语法，就发生错误了，终止了插件的执行，从而也无法执行后续的压缩步骤，但这并不影响其它插件的功能，webpack也无法感知到这个插件在执行过程中出现了错误，所以构建结果仍然是成功的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>运用条件表达式动态加载模块，除非条件表达式中不出现变量、函数调用，只进行一些常量的运算，那么条件为false的时候该模块是不会打包进bundle中的，否则无论条件为false还是true，始终会把该模块打包进bundle，只不过在条件为false的情况下不执行代码罢了</li><li>可以运用DefinePlugin添加运行时的全局常量</li><li>可以通过配置babel-loader的include选项对指定文件夹下的文件进行转译</li><li>UglifyJsWebpackPlugin不支持ES6语法</li><li>webpack无法感知插件运行过程中出现的错误，需要构建完成对构建的结果进行check，例如通过eslint对dist文件进行检查，是否有非ES5的代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目本地开发通过mockjs进行数据模拟，它是通过重写XMLHttpRequest对象来拦截请求，从而达到纯前端mock，在webpack入
      
    
    </summary>
    
      <category term="打包工具" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/Webpack/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>滚动穿透问题</title>
    <link href="http://yoursite.com/2019/03/08/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2019/03/08/滚动穿透问题.html</id>
    <published>2019-03-08T06:52:10.000Z</published>
    <updated>2019-03-08T06:53:31.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>当页面中有弹层时，禁止body的滚动</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>给body或html增加overflow: hidden<ul><li>pc端：可行</li><li>ios：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度</li><li>android：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度</li></ul></li><li>mask增加touchmove.prevent，滚动元素增加prevent.stop<ul><li>pc端：不可行，仍然会滚动穿透</li><li>ios：不可行，仍然会滚动穿透</li><li>android: 不可行，仍然会滚动穿透</li></ul></li><li><p>给body增加fixed，打开弹层时记录滚动条位置，弹层消失时滚动到记录位置</p><ul><li>pc端：可行</li><li>ios：当你从滚动容器滑动到容器之外时，或从底部下拉起控制中心，会导致容器进入短暂的无法滚动状态，等待一段时间后自动恢复，推测是ios的页面回弹效果影响的</li><li><p>android: 可行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.modal-open</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModalHelper = (<span class="function"><span class="keyword">function</span> (<span class="params">bodyCls</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> scrollTop</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 弹出之后记录保存滚动位置，并且给body添加.modal-open</span></span><br><span class="line">        afterOpen: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            scrollTop = <span class="built_in">document</span>.scrollingElement.scrollTop</span><br><span class="line">            <span class="built_in">document</span>.body.classList.add(bodyCls)</span><br><span class="line">            <span class="built_in">document</span>.body.style.top = -scrollTop + <span class="string">'px'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 关闭时将.modal-open移除并还原之前保存滚动位置</span></span><br><span class="line">        beforeClose: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.body.classList.remove(bodyCls)</span><br><span class="line">            <span class="built_in">document</span>.scrollingElement.scrollTop = scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="string">'modal-open'</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>监听滚动容器的touchmove事件，当检测到已经处于最底部，却还意图往下滚动时，阻止默认事件（处于最顶部时同理）</p><ul><li>pc端：不支持touch事件</li><li>ios：可行，解决了页面反弹问题</li><li><p>android: 不可行，阻止默认事件没生效，仍会滚动穿透</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录开始滑动的坐标，用于判断滑动方向</span></span><br><span class="line"><span class="keyword">let</span> startY = <span class="number">0</span></span><br><span class="line"><span class="comment">// 记录滑动状态：0：未开始，1：已开始，2：滑动中</span></span><br><span class="line"><span class="keyword">let</span> scrollStatus = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下所有事件均绑定在滚动容器元素上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchstartHandler</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    status = <span class="number">1</span></span><br><span class="line">    startY = e.targetTouches[<span class="number">0</span>].pageY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchmoveHandler</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status !== <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    status = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t = e.currentTarget</span><br><span class="line">    <span class="keyword">let</span> py = e.targetTouches[<span class="number">0</span>].pageY</span><br><span class="line">    <span class="comment">// 内容可视高度</span></span><br><span class="line">    <span class="keyword">let</span> ch = t.clientHeight</span><br><span class="line">    <span class="comment">// 内容滚动高度</span></span><br><span class="line">    <span class="keyword">let</span> sh = t.scrollHeight</span><br><span class="line">    <span class="comment">// 当前滚动高度</span></span><br><span class="line">    <span class="keyword">let</span> st = t.scrollTop</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经到头部尽头了还要向上滑动，阻止它</span></span><br><span class="line">    <span class="keyword">if</span> (st === <span class="number">0</span> &amp;&amp; startY &lt; py) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经到低部尽头了还要向下滑动，阻止它</span></span><br><span class="line">    <span class="keyword">if</span> ((st === sh - ch) &amp;&amp; startY &gt; py) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchendHandler</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    status = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不用自带滚动条，使用transform+overflow:hidden，监听touchmove事件自实现滚动效果</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对网页需要适配的端的不同，可采用不同的解决方案：</p><ol><li>PC端： 上述1、3</li><li>移动端：由上可见，单独的任何一种方法都无法完美适配android和ios，因此需要合并上述方法3、4以达到完美适配（Tip：在测试过程中，发现上述方法3在ios下的某些app中弹出弹层时页面会闪动，且页面弹层会消失，拖动页面才出现，如果要适配的app出现此类问题，最好区分android和ios环境分别采用上述3、4的方法，或者采用上述1、4合并（但是要把body或html的高度设置为屏幕的高度））</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;当页面中有弹层时，禁止body的滚动&lt;/p&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="滚动穿透" scheme="http://yoursite.com/tags/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>input之type=number</title>
    <link href="http://yoursite.com/2019/03/08/input%E4%B9%8Btype-number.html"/>
    <id>http://yoursite.com/2019/03/08/input之type-number.html</id>
    <published>2019-03-08T06:51:56.000Z</published>
    <updated>2019-03-11T10:27:03.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><p>页面中存在输入框，点击输入框需要弹出数字键盘，且只能输入合法数字</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>自己开发一个键盘组件</li><li>input type=”number”</li></ol><h1 id="input-type-”number”存在的问题（只调查了部分机型，不一定完全准确）"><a href="#input-type-”number”存在的问题（只调查了部分机型，不一定完全准确）" class="headerlink" title="input type=”number”存在的问题（只调查了部分机型，不一定完全准确）"></a>input type=”number”存在的问题（只调查了部分机型，不一定完全准确）</h1><table><thead><tr><th>机型</th><th>键盘类型</th><th>表现</th><th>输入限制</th></tr></thead><tbody><tr><td>ios</td><td>自带键盘</td><td>调起带数字的特殊符号键盘，可以切换成英文键盘</td><td>可以输入任何字符，输入的不是合法的数字，则取到的value为空</td></tr><tr><td>ios</td><td>非自带键盘</td><td>调起数字键盘，可以切换成英文键盘</td><td>可以输入任何字符，输入的不是合法的数字，则取到的value为空</td></tr><tr><td>android</td><td>自带键盘</td><td>调起纯数字键盘，可以切换成英文键盘</td><td>可以输入数字，-、小数点，输入的不是合法的数字时，取到的value为空</td></tr><tr><td>android</td><td>非自带键盘</td><td>调起纯数字键盘，可以切换成英文键盘</td><td>可以输入数字，-、小数点和e，输入的不是合法的数字或带有e时，取到的value为空</td></tr></tbody></table><p>由上表可知，尽管input设置了type=”number”，但是在不同的机型与输入法下，所弹出的键盘和能输入的字符是不同的，并不能保证用户输入的是合法的数字，所以我们要对用户的输入进行限制。通过监听input事件，在用户进行输入后，进行正则校验替换非法字符，但是设置了type=”number”后，如果用户输入的不是合法的数字，取到的value为空，根本无法进行合法性校验与替换操作，在Android下还好，它已经帮我们限制了英文、符号等非法字符的输入，用户的输入得到了一定的保证，我们可以在input的blur事件中进行最终的合法性校验，并给予用户一定的提示。但是在ios下，用户可以输入任意的字符，也就是说用户输入非法的字符的可能性提高了很多，若同样在blur事件中进行校验与替换操作，给用户带来的体验过差，所以在ios下使用type=”number”并不可行</p><h1 id="那么在ios下是否有其它调起纯数字键盘的方法"><a href="#那么在ios下是否有其它调起纯数字键盘的方法" class="headerlink" title="那么在ios下是否有其它调起纯数字键盘的方法"></a>那么在ios下是否有其它调起纯数字键盘的方法</h1><p>答案是肯定的，以下两种方法可以调起纯数字键盘，但是调起来的数字键盘是不带小数点的，如果需要输入小数的话，这种方法是不可行的</p><ol><li>type=”tel”</li><li>pattern=”[0-9]*”</li><li>如果是webview，调用native的事件貌似可以，但需要native人员的支持</li></ol><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>综上所诉，type设置为number的方法是不可行的，无法实现我们对用户的输入进行实时的控制，但是把type设置为text，每次调起的都是英文键盘，用户还得切换一下键盘，才能愉快的进行输入，这个体验实在是太糟糕了，如果你的页面只有一个输入框，用户或许还能勉为其难的接受，但是如果存在多个，每次用户进行输入都得切换以下，可能砸手机的心态都有了😡，可见，把type设置为text的方法更加不可行</p><h1 id="回到我们的需求"><a href="#回到我们的需求" class="headerlink" title="回到我们的需求"></a>回到我们的需求</h1><ol><li>弹出数字键盘</li><li>限制用户输入</li></ol><p>首先要满足弹出数字键盘，就必须设置type=”number”，但是设置了type=”number”之后，该怎么限制用户的输入呢？把type设回text就行了，于是有了以下处理方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input type=<span class="string">"number"</span> :model=<span class="string">"price"</span> @focus=<span class="string">"focusHandler($event)"</span> @blur=<span class="string">"blurHandler($event)"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        watch: &#123;</span></span><br><span class="line"><span class="regexp">            price: function () &#123;</span></span><br><span class="line"><span class="regexp">                const newPrice = /</span><span class="regexp">/ 正则替换操作</span></span><br><span class="line"><span class="regexp">                return newPrice</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            blurHandler (e) &#123;</span></span><br><span class="line"><span class="regexp">                e.target.type = 'number'</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            focusHandler (e) &#123;</span></span><br><span class="line"><span class="regexp">                setTimeOut(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                    e.target.type = 'text'</span></span><br><span class="line"><span class="regexp">                &#125;, 100)</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>在输入框获取焦点，弹起了数字键盘后，再把input的type设回text，这样当用户输入的是非数字字符时，也能获取到正常的value值了，然后进行合法性校验和替换，在失去焦点的时候，再把type设回number，以防下次点击的时候弹出非数字键盘，经过测试这种实现方法在ios下操作正常，但是在android下根本无法弹出键盘，于是有了下面的解决方案</p><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"number"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo--input"</span></span><br><span class="line">        v-model=<span class="string">"realValue"</span> </span><br><span class="line">   @focus=<span class="string">"inputFocusHandler($event)"</span></span><br><span class="line">        @blur=<span class="string">"inputBlurHandler($event)"</span></span><br><span class="line">        @input=<span class="string">"inputHandler"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"DemoInput"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">   &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            realValue: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        realValue: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> realValue = newValue.replace(<span class="regexp">/[^0-9.]|(^\.)/g</span>, <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">if</span> (realValue.charAt(realValue.length - <span class="number">1</span>) === <span class="string">"."</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> tempValue = realValue.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">this</span>.realValue = <span class="regexp">/\./g</span>.test(tempValue) ? tempValue : realValue</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.realValue = realValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        validateValue () &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; realValue &#125; = <span class="keyword">this</span></span><br><span class="line">            <span class="comment">// 校验输入的是否是数字</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                realValue !== <span class="string">""</span> &amp;&amp;</span><br><span class="line">                !<span class="regexp">/^[0-9]+(\.[0-9]+)?$/</span>.test(realValue)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">this</span>.realValue = <span class="string">""</span></span><br><span class="line">                alet(<span class="string">'请输入正确的数字！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去除数字前面多余的0</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="regexp">/\./g</span>).test(realValue)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.realValue = realValue.replace(<span class="regexp">/^0+\./</span>, <span class="string">"0."</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.realValue = realValue.replace(<span class="regexp">/^0+/</span>, <span class="string">""</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        inputBlurHandler(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.APP_TYPE === <span class="string">"ios"</span>) &#123;</span><br><span class="line">                e.target.type = <span class="string">"number"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.validateValue()</span><br><span class="line">        &#125;,</span><br><span class="line">        inputHandler(e) &#123;</span><br><span class="line">        <span class="comment">// 长度输入限制</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.realValue.length &gt; <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.realValue = <span class="keyword">this</span>.realValue.slice(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        inputFocusHandler(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.APP_TYPE === <span class="string">"ios"</span>) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    e.target.type = <span class="string">"text"</span></span><br><span class="line">                &#125;, <span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><ol><li>移动端自定义指令v-focus仍然无法实现点击某个按钮，使input自动获取焦点，在pc端可行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a&gt;业务需求&lt;/h1&gt;&lt;p&gt;页面中存在输入框，点击输入框需要弹出数字键盘，且只能输入合法数字&lt;/p&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="input" scheme="http://yoursite.com/tags/input/"/>
    
      <category term="type=&quot;number&quot;" scheme="http://yoursite.com/tags/type-number/"/>
    
  </entry>
  
  <entry>
    <title>八种方法实现CSS页面底部固定</title>
    <link href="http://yoursite.com/2019/03/08/%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0CSS%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E5%9B%BA%E5%AE%9A.html"/>
    <id>http://yoursite.com/2019/03/08/八种方法实现CSS页面底部固定.html</id>
    <published>2019-03-08T06:42:59.000Z</published>
    <updated>2019-03-08T06:44:24.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八种方法实现CSS页面底部固定"><a href="#八种方法实现CSS页面底部固定" class="headerlink" title="八种方法实现CSS页面底部固定"></a>八种方法实现CSS页面底部固定</h1><p>页面布局：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通用样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>footer高度固定+绝对定位</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主体区域设置margin负值</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>header, footer设置margin负值</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过设置flex，将footer的margin-top设置为auto</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过calc()计算内容的高度</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="built_in">calc</span>(100vh - 150px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过设置flexbox，将主体main设置为flex</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用grid布局</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: auto <span class="number">1</span>fr auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>display: table</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-row;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;八种方法实现CSS页面底部固定&quot;&gt;&lt;a href=&quot;#八种方法实现CSS页面底部固定&quot; class=&quot;headerlink&quot; title=&quot;八种方法实现CSS页面底部固定&quot;&gt;&lt;/a&gt;八种方法实现CSS页面底部固定&lt;/h1&gt;&lt;p&gt;页面布局：&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSS/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="底部固定" scheme="http://yoursite.com/tags/%E5%BA%95%E9%83%A8%E5%9B%BA%E5%AE%9A/"/>
    
  </entry>
  
</feed>
