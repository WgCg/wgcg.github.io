<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WgCg Blog</title>
  
  <subtitle>Keep Learning and Never Give Up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-23T13:19:35.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cong.Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>echart问题记录</title>
    <link href="http://yoursite.com/2019/12/23/echart%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>http://yoursite.com/2019/12/23/echart问题记录.html</id>
    <published>2019-12-23T13:15:17.000Z</published>
    <updated>2019-12-23T13:19:35.918Z</updated>
    
    <content type="html"><![CDATA[<ol><li>先绘制 <code>columns</code>，再异步绘制 <code>source</code>，没有动画</li><li>指标切换的 <code>label</code> 显示不全，设置 <code>legend.textStyle.lineHeight</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;先绘制 &lt;code&gt;columns&lt;/code&gt;，再异步绘制 &lt;code&gt;source&lt;/code&gt;，没有动画&lt;/li&gt;
&lt;li&gt;指标切换的 &lt;code&gt;label&lt;/code&gt; 显示不全，设置 &lt;code&gt;legend.textStyle.lineHeight
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="echart" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/echart/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/echart/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>http问题记录</title>
    <link href="http://yoursite.com/2019/12/23/http%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>http://yoursite.com/2019/12/23/http问题记录.html</id>
    <published>2019-12-23T13:15:02.000Z</published>
    <updated>2019-12-23T13:20:31.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chrome-302-发起多余的GET请求"><a href="#Chrome-302-发起多余的GET请求" class="headerlink" title="Chrome 302 发起多余的GET请求"></a>Chrome 302 发起多余的<code>GET</code>请求</h2><ol><li>浏览器发起一个 post 请求，后端返回 302 会导致原请求变成 GET 请求并且 Post Data 丢失（在 network 中，会出现 3 次请求记录，原请求，原请求的 GET 方法（不应该显示），302 的请求），<a href="https://stackoverflow.com/questions/12548341/how-to-work-around-post-being-changed-to-get-on-302-redirect" target="_blank" rel="noopener">问题链接</a>，解决方案：<ol><li>后端请求需要 302 的地址，获取数据后，返回给前端 200</li><li>返回 307：告诉浏览器按照 original request 的方法发起新的 redirect request，但是要向用户提示安全警告，但是这并不总是有效的，因为它不是 http common status code（HTTP 常见状态码），<a href="https://ilia.ws/archives/152-Cross-Domain-POST-Redirection.html" target="_blank" rel="noopener">不同浏览器实现逻辑不一致</a><ol><li>IE7： 不会给予警告</li><li>safari: 它不会引发确认对话框并执行重定向，并且丢弃 post data，将 307 转为 302</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Chrome-302-发起多余的GET请求&quot;&gt;&lt;a href=&quot;#Chrome-302-发起多余的GET请求&quot; class=&quot;headerlink&quot; title=&quot;Chrome 302 发起多余的GET请求&quot;&gt;&lt;/a&gt;Chrome 302 发起多余的&lt;code&gt;G
      
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/HTTP/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ant-design问题记录</title>
    <link href="http://yoursite.com/2019/12/23/ant-design%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>http://yoursite.com/2019/12/23/ant-design问题记录.html</id>
    <published>2019-12-23T13:14:45.000Z</published>
    <updated>2019-12-23T13:21:22.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><ol><li><code>select</code> <code>dropdownMatchSelectWidth=false</code> 导致设置的 <code>width</code> 没用 会被设置为 <code>min-width</code></li><li><code>select</code> 增加 <code>getPopupContainer</code> 无效，给弹出层的父级增加 <code>postion:relative</code></li></ol><h2 id="PageHeader"><a href="#PageHeader" class="headerlink" title="PageHeader"></a>PageHeader</h2><ol><li><code>page-header</code> <code>.ant-page-header-content</code> 的 <code>overflow:hidden</code> 导致输入框的 <code>focus</code> 的 <code>box-shadow</code> 不显示</li></ol><h2 id="DatePicker"><a href="#DatePicker" class="headerlink" title="DatePicker"></a>DatePicker</h2><ol><li><code>DatePicker</code> 组件没有 <code>getPopupContainer</code> 属性，而是 <code>getCalendarContainer</code> 属性，且不能通过 <code>ConfigProvider</code> 统一添加</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Select&quot;&gt;&lt;a href=&quot;#Select&quot; class=&quot;headerlink&quot; title=&quot;Select&quot;&gt;&lt;/a&gt;Select&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; &lt;code&gt;dropdownMatchSelectWid
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ant-design" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/ant-design/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/ant-design/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>umi官方文档笔记</title>
    <link href="http://yoursite.com/2019/10/26/umi%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/10/26/umi官方文档笔记.html</id>
    <published>2019-10-26T03:06:29.000Z</published>
    <updated>2019-12-23T13:12:22.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>src/layouts/index.js(配置式路由下无效):</p><ol><li>全局布局，在路由外面套的一层路由。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">component</span>: <span class="string">"./pages/index"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">"/users"</span>, <span class="attr">component</span>: <span class="string">"./pages/users"</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果有<code>layouts/index.js</code>，那么路由就会变为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/"</span>,</span><br><span class="line">    component: <span class="string">"./layouts/index"</span>,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">component</span>: <span class="string">"./pages/index"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">"/users"</span>, <span class="attr">component</span>: <span class="string">"./pages/users"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>生成的路由配置字段</p><ol><li><code>Routes</code>: 权限路由配置</li><li><code>routes</code>: 路由配置</li></ol></li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ol><li><code>umi/link</code>: 提供<code>Link</code>组件</li><li><code>umi/navLink</code>: 提供<code>NavLink</code>组件</li><li><code>umi/router</code>: 提供<code>router</code>实例</li><li><code>umi/withRouter</code>: 添加<code>router</code>相关的属性到<code>props</code>中</li><li><code>umi/dynamic</code>: 提供按需加载的接口</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>路由/通过扩展注释路由：<code>Routes</code>字段与<code>嵌套路由</code>的<code>routes</code>不同</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路由&quot;&gt;&lt;/a&gt;路由&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;src/layouts/index.js(配置式路由下无效):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局布局，在路由外面套的一层路由
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="umi" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/umi/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/umi/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>redux官方文档笔记</title>
    <link href="http://yoursite.com/2019/10/17/redux%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/10/17/redux官方文档笔记.html</id>
    <published>2019-10-17T06:53:14.000Z</published>
    <updated>2019-10-23T12:45:53.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><ol><li>单一数据源，所有的状态存储在一个<code>store</code>中</li><li><code>State</code>是只读的，唯一改变的方法是触发<code>action</code></li><li>使用纯函数来执行修改，只要传入参数相同，<code>reducer</code>返回计算得到的下一个<code>state</code>就一定相同。没有特殊情况、没有副作用，没有API请求、没有变量修改，单纯执行计算。</li></ol><h3 id="redux数据流"><a href="#redux数据流" class="headerlink" title="redux数据流"></a>redux数据流</h3><ol><li>调用<code>store.dispatch(action)</code></li><li><code>store</code>调用传入的<code>reducer</code>函数</li><li>根<code>reducer</code>应该把多个子<code>reducer</code>输出合并成一个单一的<code>state</code>树</li><li><code>store</code>保存了根<code>reducer</code>返回的完整的<code>state</code>树</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><code>action type</code>放在一个地方统一维护，全部大写，以<code>_</code>分割</li><li><p><code>state</code>尽量范式化，不要深层嵌套，尽量以<code>ID</code>为主键进行索引，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;</span><br><span class="line">    todos: [</span><br><span class="line">        &#123;</span><br><span class="line">            text: <span class="string">'a'</span>,</span><br><span class="line">            completed: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            text: <span class="string">'b'</span>,</span><br><span class="line">            completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h3><ol><li>index.js: 合并<code>reducer</code>，创建<code>store</code></li><li>reducers.js: 定义<code>reducer</code>，<code>reducer</code>的名字和<code>state</code>中属性的名字保持一致，<code>reducer</code>中需要根据<code>type</code>文件中定义的类型进行匹配然后更改相应的<code>state</code></li><li>actions.js: 定义<code>action</code>工厂函数，接收要更新的<code>state</code>的值，返回包裹<code>type</code>的和更新的值的一个对象<ol><li>正常的<code>action</code>创建函数只能进行一些同步的操作，且不能包含副作用，但是可以通过<code>redux-thunk</code>库来扩展<code>action</code>，实现异步的可包含副作用的<code>action</code>，并使用<code>redux</code>提供的<code>applyMiddleware</code>方法在<code>createStore</code>的时候把中间件添加进去</li></ol></li><li>types.js: 定义<code>action type</code>，在<code>reducers</code>和<code>actions</code>中会用到</li></ol><h3 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h3><p>*<em>它提供的是位于 action 被发起之后，到达 reducer 之前的扩展点</em></p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h3><table><thead><tr><th>展示组件</th><th>容器组件</th></tr></thead><tbody><tr><td>作用</td><td>描述如何展现（骨架、样式）</td><td>描述如何运行（数据获取、状态更新）</td></tr><tr><td>直接使用 Redux</td><td>否</td><td>是</td></tr><tr><td>数据来源</td><td>props</td><td>监听redux state</td></tr><tr><td>数据修改</td><td>从props调用回调函数</td><td>向redux派发actions</td></tr><tr><td>调用方式</td><td>手动</td><td>通常由react redux生成</td></tr></tbody></table><h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><p>容器组件就是使用<code>store.subscribe()</code>从<code>Redux state</code>树中读取部分数据，并通过<code>props</code>来把这些数据提供给要渲染的组件</p><p>定义容器组件的过程主要如下：</p><ol><li>定义<code>mapStateToProps</code>方法，该方法接收<code>state</code>为参数，根据<code>state</code>作一些计算，并把结果返回，传递给需要该数据的<strong>展示组件</strong></li><li>定义<code>mapDispatchToProps</code>方法，该方法接收<code>disptach</code>为参数，并返回包含一些<code>disptach</code>操作的回调方法，传递给需要修改<code>state</code>的值的<strong>展示组件</strong></li></ol><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol><li>connect: 用于包裹组件，将<code>state</code>、<code>disptach</code>等方法作为<code>props</code>传递到组件中</li><li>hook<ol><li>useSelector:<ol><li>与<code>mapState</code>不同，可以返回任意值，其返回的值作为<code>useSelector</code>的返回值</li><li>当<code>dispatch</code>一个<code>action</code>，<code>useSelector</code>会对返回值进行一个浅比较，如果不同则重新渲染组件</li><li><code>selector</code>不接受<code>ownProps</code>参数，可以通过闭包或柯里化<code>selector</code>实现</li><li>使用<code>memoizing selectors</code>需要格外注意<ol><li>避免组件渲染时重复生成<code>selector</code>，定义在函数式组件之外</li><li>如果多个组件调用，要保证每一个<code>selector instance</code>是不一致的，通过工厂函数实现</li></ol></li><li><code>useSelecotr</code>默认使用<code>===</code>检查，而不是浅比较，<code>selector</code>每次返回一个新对象会导致每次<code>dispatch</code>都重新渲染，以下方法可以解决这个问题<ol><li>调用<code>useSelector</code>多次，每次都返回单一值，取代直接返回一个对象</li><li>使用<code>reselect</code>等相似的库，只有在对象里面的值改变时才返回一个新对象</li><li>传递第二个参数<code>shallowEqual</code></li></ol></li></ol></li><li>useDispatch</li><li>useStore</li></ol></li></ol><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li>Provider: <code>&lt;Provider store={store}&gt;&lt;App/&gt;&lt;/Provider&gt;</code>能够让所有组件都能够访问<code>store</code></li></ol><h3 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h3><ol><li>redux-action/redux-act: 用于生成<code>actions</code>创建函数和<code>reducer</code></li><li>normalizr: 把嵌套的<code>API</code>响应数据范式化</li><li>以下库，通过包装<code>store.dispatch</code>方法，以此来让你<code>dispatch</code>一些除了<code>action</code>以外的其它内容，例如：函数或者<code>promise</code><ol><li>redux-thunk</li><li>redux-promise/redux-promise-middleware</li><li>redux-observable</li><li>redux-saga</li><li>redux-pack</li></ol></li><li>reselect: 创建可记忆的(Memoized)，可组合的<code>selector</code>函数</li><li>redux-undo: 为<code>redux</code>状态树中能够的任何部分提供撤销和重做功能</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redux&quot;&gt;&lt;a href=&quot;#redux&quot; class=&quot;headerlink&quot; title=&quot;redux&quot;&gt;&lt;/a&gt;redux&lt;/h2&gt;&lt;h3 id=&quot;三大原则&quot;&gt;&lt;a href=&quot;#三大原则&quot; class=&quot;headerlink&quot; title=&quot;三大原则&quot;
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="redux" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/redux/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/redux/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>react-router官方文档笔记</title>
    <link href="http://yoursite.com/2019/10/15/react-router%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/10/15/react-router官方文档笔记.html</id>
    <published>2019-10-15T13:42:16.000Z</published>
    <updated>2019-10-17T02:09:54.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">官方文档</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>所有路由相关的标签必须嵌入在<code>routes</code>类型的标签之内</li><li><code>Route</code>放在<code>Switch</code>中才会进行<strong>单一</strong>匹配，否则只要匹配成功的<code>Route</code>，都会进行渲染</li><li>如何衡量<code>&lt;Route component/&gt;</code>、<code>&lt;Route render/&gt;</code>、<code>&lt;Route children/&gt;</code>三种方式<ol><li><code>&lt;Route component/&gt;</code>: 在<code>Route</code>内部会根据传递的<code>component</code>的值通过<code>React.createElement</code>创建组件，这意味你如果传递一个内联方法（通常需要传递额外的非路由相关的<code>props</code>时使用），在每次渲染时都会销毁旧组件，创建一个新的组件，而不会更新旧组件，<strong>造成性能上的损失</strong></li><li><code>&lt;Route render/&gt;</code>: 解决了上述问题，但是有关路由的<code>props</code>都得自己手动传递一下</li><li><code>&lt;Route children/&gt;</code>: 无论<code>path</code>是否匹配，都会触发<code>children</code>(不在<code>Switch</code>组件中)，可以根据<code>match</code>进行判断做一些特殊化处理，<code>props</code>也得手动传递</li><li><code>&lt;Route&gt;chidlren&lt;/Route&gt;</code>: 这时候没法把路由参数传递给<code>children</code>组件，使用<code>withRouter</code>或者<code>hooks</code>进行操作</li></ol></li><li><code>location</code>是<code>immutable</code>的，而<code>history.location</code>是<code>mutable</code>的<ol><li><code>immutable</code>: 对象引用不会发生变化</li><li><code>mutable</code>: 对象引用会发生变化</li></ol></li></ol><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><h3 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><ol><li>routers: 以下所有的<code>high-level</code>routes都是基于<code>Router</code>组件封装的，<code>Router</code>组件一般配合状态管理库，例如<code>redux</code>、<code>mbox</code>进行同步自定义历史记录<ol><li><code>BrowserRouter</code>: <code>history</code>模式<ol><li>basename: string : 配置所有<code>路由</code>的<code>baseurl</code></li><li>getUserConfirmation: func : 结合<code>Prompt</code>组件使用，可以在离开路由之前进行弹窗提醒</li><li>forceRefresh: bool : 路由跳转时是否刷新整个页面</li><li>keyLength: number : 设置<code>location.key</code>的长度，<code>location</code>可以通过<code>useLocation</code>或<code>props</code>取得</li><li>children: node : 要渲染的子元素</li></ol></li><li><code>HashRouter</code>: <code>hash</code>模式<ol><li>basename: string : 配置所有<code>路由</code>的<code>baseurl</code></li><li>getUserConfirmation: func : 结合<code>Prompt</code>组件使用，可以在离开路由之前进行弹窗提醒</li><li>hashType : string : 设置<code>hash</code>模式的类型<ol><li>slash: 以<code>#/</code>开头，<strong>默认值</strong></li><li>noslash: 以<code>#</code>开头</li><li>hashbang: 以<code>#!/</code>开头，<strong>已被Google废弃</strong></li></ol></li><li>children: node : 要渲染的子元素</li></ol></li><li><code>MemoryRouter</code>: 在进行<code>测试</code>和<code>非浏览器环境</code>时使用，暂不介绍</li><li><code>NativeRouter</code>: 用在<code>Native</code>环境，暂不介绍</li><li><code>StaticRouter</code>: 通常用于<code>服务端渲染</code>或<code>测试</code>，暂不介绍</li></ol></li><li>route matchers<ol><li><code>Route</code><ol><li>有三种渲染组件的方式，无论是哪种渲染方式，都会接受<code>match</code>、<code>location</code>、<code>history</code>三个<code>props</code><ol><li><code>&lt;Route component&gt;</code></li><li><code>&lt;Route render&gt;</code></li><li><code>&lt;Route children&gt;function</code></li></ol></li><li>path: string | string[]: 要匹配的路由，匹配成功后会渲染对应的组件</li><li>exact: bool: 是否是精确匹配，设置为<code>true</code>后，如果<code>path</code>设置为<code>/pages</code>，<code>/pages/home</code>不会匹配成功</li><li>strict: bool: 是否是严格匹配，设置为<code>true</code>后，如果<code>path</code>设置为<code>/pages/</code>，<code>/pages</code>不会匹配成功</li><li>location: object: <code>Route</code>匹配默认都是根据当前的<code>history location</code>进行匹配的，可以设置该属性更改匹配的<code>location</code></li><li>sensitive: bool: 是否大小写敏感</li></ol></li><li><code>Switch</code>: 当<code>Switch</code>组件渲染时，它会从上往下依次匹配<code>children</code>中的<code>Route</code>或者<code>Redirect</code>标签，匹配成功之后渲染该组件并停止匹配，如果没有匹配到，什么都不会渲染<ol><li>location: object: 设置进行匹配的<code>location</code>，默认为<code>current location</code></li><li>children: node: 该组件的<code>children</code>只能包含<code>Route</code>和<code>Redirect</code></li></ol></li></ol></li><li>navigation/route changers<ol><li><code>Link</code>: 跳转到某一路由，最终会渲染成<code>a</code>标签<ol><li>to: 要跳转的路由，值的类型有多种，具体如下<ol><li>string: 要跳转的路由对应的<code>url</code></li><li>object: 路由描述对象，具有以下属性<ol><li>pathname</li><li>search</li><li>hash</li><li>state: 附加跳转信息</li></ol></li><li>function: 该方法接收当前路由的<code>location</code>对象为参数，返回要跳转路由的<code>string</code>or<code>object</code>描述</li></ol></li><li>replace: bool: 替换当前路由</li><li>innerRef<ol><li>function : 该方法接收<code>Link</code>标签最后渲染成的<code>DOM Node</code>为参数，目前为<code>a</code>标签</li><li>RefObject : <code>react.createRef</code>创建的<code>RefObject</code></li></ol></li><li>others: 其它想要设置到<code>a</code>标签的任意属性，例如<code>title</code>、<code>id</code>等等</li></ol></li><li><code>NavLink</code>: 与<code>Link</code>的作用一致，不同的是可以提供一个<code>activeClassName</code>属性，设置与当前路由匹配时的样式<ol><li>activeClassName: string : 设置当路由匹配时的<code>className</code>，默认为<code>active</code></li><li>activeStyle: object : 设置当路由匹配时的样式</li><li>exact: bool : 当为<code>true</code>时，只有路径完全匹配，才会添加设置的<code>activeClassName</code>、<code>activeStyle</code></li><li>strict: bool : 当设置为<code>true</code>时，会对路由进行严格匹配，包括<code>#</code>、<code>#/</code></li><li>isActive: func : 添加判断当前路由是否匹配的验证方法，参数为<code>match</code>，<code>location</code></li><li>location: object : 传递给<code>isActive</code>方法的<code>location</code></li><li>aria-current: string : 设置<code>active</code>时的<code>aria-current</code>属性，默认为<code>page</code></li></ol></li><li><code>Redirect</code>: 渲染该标签时，会立即将当前的路由转跳到该标签设置的<code>to</code>属性的值所对应的路由页面<ol><li>to<ol><li>string: 要跳转的<code>url</code></li><li>object: <code>location object</code></li></ol></li><li>push: bool: 设置为<code>true</code>，将会在浏览器历史记录中增加一条，即为<code>push</code>的效果</li><li>from: string: 只能当<code>Redirect</code>组件被包裹在<code>Switch</code>组件中时，才能使用该属性</li><li>exact: bool: <code>from</code>是否需要精确匹配</li><li>strict: bool: <code>from</code>是否需要严格匹配，少个<code>\</code>都不行</li><li>sensitive: bool: <code>from</code>匹配时是否大小写敏感</li></ol></li><li><code>prompt</code>: 与<code>routes</code>的<code>getUserConfirmation</code>属性配合使用</li></ol></li></ol><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><ol><li>useHistory</li><li>useLocation</li><li>useParams</li><li>useRouteMatch</li></ol><h2 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h2><h3 id="异步组件-code-splitting"><a href="#异步组件-code-splitting" class="headerlink" title="异步组件/code splitting"></a>异步组件/code splitting</h3><p>如果想要实现异步加载组件/代码拆分的功能，需要使用进行安装如下插件以及设置：</p><ol><li><a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/" target="_blank" rel="noopener">@babel/plugin-synntax-dynamic-import</a><ol><li>{“plugins”: [“@babel/plugin-syntax-dynamic-import”]}</li></ol></li><li><a href="https://github.com/smooth-code/loadable-components" target="_blank" rel="noopener">loadable-components</a></li></ol><h3 id="开发使用"><a href="#开发使用" class="headerlink" title="开发使用"></a>开发使用</h3><ol><li><a href="将路径转换为正则表达式">path-to-regexp</a></li></ol><h3 id="底层库"><a href="#底层库" class="headerlink" title="底层库"></a>底层库</h3><ol><li><a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener">history</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://reacttraining.com/react-router/web/guides/quick-start&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="react-router" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/react-router/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/react-router/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>gitlab-ci</title>
    <link href="http://yoursite.com/2019/10/08/gitlab-ci.html"/>
    <id>http://yoursite.com/2019/10/08/gitlab-ci.html</id>
    <published>2019-10-08T01:29:21.000Z</published>
    <updated>2019-10-08T01:38:11.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GitLab CI pipeline 使用<code>.gitlab-ci.yml</code>文件来进行配置，用于定义管道的结构以及执行顺序，它决定了以下2点：</p><ol><li>使用<code>gitlab runner</code>执行什么</li><li>当遇到某些特定的条件需要执行什么，例如，一个过程的成功或者失败</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;GitLab CI pipeline 使用&lt;code&gt;.gitlab-ci.yml&lt;/code&gt;文件来进行配置，用于定义管道的结构以及执行顺
      
    
    </summary>
    
      <category term="其它技术" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/git/"/>
    
    
  </entry>
  
  <entry>
    <title>VueTypes文档</title>
    <link href="http://yoursite.com/2019/09/27/VueTypes%E6%96%87%E6%A1%A3.html"/>
    <id>http://yoursite.com/2019/09/27/VueTypes文档.html</id>
    <published>2019-09-27T08:51:57.000Z</published>
    <updated>2019-09-30T10:32:25.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>VueTypes是一个用于验证Props属性的库</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>大多数原始类型具有以下特征：</p><ol><li>默认值（<code>.any</code>与<code>.symbol</code>除外）</li><li><code>.def(any)</code>方法修改默认值</li><li><code>isRequired</code>标志表示这个属性是否是必须的</li><li><code>.validate(function)</code>方法传递一个验证函数进行验证（<code>.integer</code>除外）</li></ol><h4 id="VueTypes-any"><a href="#VueTypes-any" class="headerlink" title="VueTypes.any"></a>VueTypes.any</h4><ol><li>允许任何类型</li><li>没有默认值</li></ol><h4 id="VueTypes-array"><a href="#VueTypes-array" class="headerlink" title="VueTypes.array"></a>VueTypes.array</h4><ol><li>数组类型</li><li>默认值：一个空数组</li><li><code>.def</code>接收一个方法或数组为参数，数组会自动转换为工厂函数</li></ol><h4 id="VueTypes-bool"><a href="#VueTypes-bool" class="headerlink" title="VueTypes.bool"></a>VueTypes.bool</h4><ol><li>布尔类型</li><li>默认值：true</li></ol><h4 id="VueTypes-func"><a href="#VueTypes-func" class="headerlink" title="VueTypes.func"></a>VueTypes.func</h4><ol><li>函数类型</li><li>默认值：一个空函数</li></ol><h4 id="VueTypes-number"><a href="#VueTypes-number" class="headerlink" title="VueTypes.number"></a>VueTypes.number</h4><ol><li>数字类型</li><li>默认值：0</li></ol><h4 id="VueTypes-object"><a href="#VueTypes-object" class="headerlink" title="VueTypes.object"></a>VueTypes.object</h4><ol><li>对象类型</li><li>默认值：一个空对象</li><li><code>.def</code>接收一个方法或数组为参数，数组会自动转换为工厂函数</li></ol><h4 id="VueTypes-string"><a href="#VueTypes-string" class="headerlink" title="VueTypes.string"></a>VueTypes.string</h4><ol><li>字符串类型</li><li>默认值：’’</li></ol><h4 id="VueTypes-symbol"><a href="#VueTypes-symbol" class="headerlink" title="VueTypes.symbol"></a>VueTypes.symbol</h4><ol><li>symbol类型</li><li>没有默认值</li></ol><h3 id="原始类型相关的配置"><a href="#原始类型相关的配置" class="headerlink" title="原始类型相关的配置"></a>原始类型相关的配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否采用VueTypes提供的默认值，默认为true</span></span><br><span class="line">VueTypes.sensibleDefaults = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改某个原始类型的默认值</span></span><br><span class="line">VueTypes.sensibleDefaults = &#123;</span><br><span class="line">  string: <span class="string">'mystringdefault'</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你想要移除某个默认值的时候，可以这么做</span></span><br><span class="line"><span class="built_in">console</span>.log(VueTypes.bool.default) <span class="comment">// logs true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; bool, ...newDefaults &#125; = VueTypes.sensibleDefaults</span><br><span class="line"></span><br><span class="line">VueTypes.sensibleDefaults = newDefaults</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(VueTypes.bool.default) <span class="comment">// logs undefined</span></span><br></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>自定义类型具有以下特征：</p><ol><li>不存在默认值</li><li>不存在<code>.validate</code>方法</li><li><code>.def</code>方法设置默认值</li><li><code>isRequired</code>标志这个属性是否必须</li></ol><h4 id="VueTypes-instanceOf-any"><a href="#VueTypes-instanceOf-any" class="headerlink" title="VueTypes.instanceOf(any)"></a>VueTypes.instanceOf(any)</h4><ol><li>验证<code>prop</code>的值是不是某个’类’的实例，跟<code>instanceof</code>操作符类似</li></ol><h4 id="VueTypes-oneOf-array"><a href="#VueTypes-oneOf-array" class="headerlink" title="VueTypes.oneOf(array)"></a>VueTypes.oneOf(array)</h4><ol><li>验证<code>prop</code>的值是不是存在于数组中</li></ol><h4 id="VueTypes-oneOfType-array"><a href="#VueTypes-oneOfType-array" class="headerlink" title="VueTypes.oneOfType(array)"></a>VueTypes.oneOfType(array)</h4><ol><li>验证<code>prop</code>的值的类型是不是存在于数组</li></ol><h4 id="VueTypes-arrayOf-type"><a href="#VueTypes-arrayOf-type" class="headerlink" title="VueTypes.arrayOf(type)"></a>VueTypes.arrayOf(type)</h4><ol><li>验证某个数组中的值是否都由指定的<code>type</code>组成</li></ol><h4 id="VueTypes-objectOf-type"><a href="#VueTypes-objectOf-type" class="headerlink" title="VueTypes.objectOf(type)"></a>VueTypes.objectOf(type)</h4><ol><li>验证某个对象的所有属性是否都由指定的<code>type</code>组成</li></ol><h4 id="VueTypes-shape"><a href="#VueTypes-shape" class="headerlink" title="VueTypes.shape()"></a>VueTypes.shape()</h4><ol><li>验证<code>prop</code>的值是否包含某个对象的所有属性</li><li>可以为每一个属性指定类型，并且用<code>isRequired</code>标志这个属性是否是必须的，但是不能为属性设置默认值</li><li>可以使用<code>.def</code>为这个<code>prop</code>设置默认值</li><li>默认情况下，不能包含没有定义过的属性，可以使用<code>loose</code>标志来支持</li></ol><h4 id="VueTypes-custom-fn-message"><a href="#VueTypes-custom-fn-message" class="headerlink" title="VueTypes.custom(fn, message)"></a>VueTypes.custom(fn, message)</h4><ol><li>用传入的<code>fn</code>对<code>prop</code>进行验证</li><li>可以传入第二个参数<code>message</code>，在验证不通过时，会将<code>message</code>输出到控制台</li></ol><h3 id="扩展VueTypes"><a href="#扩展VueTypes" class="headerlink" title="扩展VueTypes"></a>扩展VueTypes</h3><ol><li>使用<code>VueTypes.extend(config)</code>进行扩展</li><li><p><code>config</code>对象可以包含<code>Vue</code>的<code>props</code>中的所有属性，加上：</p><ol><li><code>name</code>：<code>string</code>类型，必须</li><li><code>validate</code>：<code>boolean</code>类型，默认为<code>false</code>，如果为<code>true</code>，会有一个类似于原始类型的<code>validate</code>方法</li><li><p><code>getter</code>: <code>boolean</code>类型，默认为<code>false</code>， 如果为<code>true</code>，则会把定义的<code>name</code>设置为<code>VueTypes</code>的一个属性（类似于<code>VueTypes.string</code>），否则，会设置为<code>VueTypes</code>的一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as an accessor type</span></span><br><span class="line">VueTypes.extend(&#123;</span><br><span class="line">    name: <span class="string">'negative'</span>,</span><br><span class="line">    getter: <span class="literal">true</span>,</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    validator: <span class="function">(<span class="params">v</span>) =&gt;</span> v &lt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> negativeProp = VueTypes.negative</span><br><span class="line"></span><br><span class="line"><span class="comment">// as a configurable method</span></span><br><span class="line">VueTypes.extend(&#123;</span><br><span class="line">    name: <span class="string">'negativeFn'</span>,</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    validator: <span class="function">(<span class="params">v</span>) =&gt;</span> v &lt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> negativeProp2 = VueTypes.negativeFn() <span class="comment">// &lt;-- we need to call it</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>如果<code>getter</code>为<code>false</code>，传递给扩展的方法的剩余参数会被传给<code>validator</code>函数，例如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VueTypes.extend(&#123;</span><br><span class="line">  name: <span class="string">'maxLength'</span>,</span><br><span class="line">  <span class="comment">// getter: false, this is the default</span></span><br><span class="line">  type: <span class="built_in">String</span>,</span><br><span class="line">  validator: <span class="function">(<span class="params">max, v</span>) =&gt;</span> v.length &lt;= max</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxLengthType = VueTypes.maxLength(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">maxLengthType.validator(<span class="string">'ab'</span>) <span class="comment">// true</span></span><br><span class="line">maxLengthType.validator(<span class="string">'abcd'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/dwightjack/vue-types" target="_blank" rel="noopener">https://github.com/dwightjack/vue-types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;VueTypes是一个用于验证Props属性的库&lt;/p&gt;
&lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="前端库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>React官方文档笔记</title>
    <link href="http://yoursite.com/2019/09/26/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/09/26/React官方文档笔记.html</id>
    <published>2019-09-26T11:23:11.000Z</published>
    <updated>2019-10-17T03:35:14.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>当前笔记基于<code>React v16.8.6</code></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="JSX相关"><a href="#JSX相关" class="headerlink" title="JSX相关"></a>JSX相关</h3><ol><li>因为<code>JSX</code>最终会编译成<code>React.createElement</code>的调用形式，所以使用<code>JXS</code>之前必须先引入<code>React</code></li><li>在<code>JSX</code>中允许使用点语法来引用一个组件，例如<code>&lt;MyComponents.DatePicker&gt;</code></li><li><code>React</code>自定义组件必须以大写命名，否则会被认为是一个<code>html</code>标签</li><li><code>props</code>的默认值为<code>true</code></li><li><code>JSX</code>中只支持<code>JavaScript</code>表达式</li><li>属性名采用驼峰命名，但<code>arial-*</code>除外</li><li><code>class</code>采用<code>className</code>取代</li><li><code>for</code>采用<code>htmlFor</code>取代</li><li>表单组件中，对于后续不需要变化的控件，其值可以使用<code>defualtValue</code>、<code>defaultChecked</code>进行设置</li><li>在<code>JSX</code>中，<code>false</code>、<code>null</code>、<code>undefined</code>、<code>true</code>是合法的子元素，但是它们并不会被渲染，这也就是为什么<code>{ showHeader &amp;&amp; &lt;Header /&gt; }</code>可以正常渲染的原因，值得注意的是有一些<code>falsy</code>的值，例如：数值<code>0</code>仍然会被渲染</li><li>子元素的传递<ol><li><code>props.children</code>，也可以传递一个函数</li><li>通过<code>props</code>传递<code>JSX</code></li></ol></li></ol><h3 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h3><h4 id="组件编写顺序"><a href="#组件编写顺序" class="headerlink" title="组件编写顺序"></a>组件编写顺序</h4><ol><li>构建简单应用时，使用自上而下的方式进行构建（先编写层级高的组件）</li><li>构建复杂应用时，使用自下而上的方式进行构建（先编写最基本的组件）</li></ol><h4 id="如何判断数据是否属于state"><a href="#如何判断数据是否属于state" class="headerlink" title="如何判断数据是否属于state"></a>如何判断数据是否属于state</h4><ol><li>该数据是否是由父组件通过props传递而来的？如果是，那它应该不是state</li><li>该数据是否随时间内的推移而保持不变？如果是，那它应该也不是state</li><li>你能否根据其他state或props计算出该数据的值？如果是，那它也不是state</li></ol><h4 id="如何确定state放置的位置"><a href="#如何确定state放置的位置" class="headerlink" title="如何确定state放置的位置"></a>如何确定state放置的位置</h4><ol><li>找到根据这个state进行渲染的所有组件</li><li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该state的组件）</li><li>该共同所有者组件或者比它层级更高的组件应该拥有该state</li><li>如果你找不到一个合适的位置来存放该state,就可以直接创建一个新的组件来存放该state，并将这一新组件置于高于共同所有者组件层级的位置</li></ol><h3 id="高级指引"><a href="#高级指引" class="headerlink" title="高级指引"></a>高级指引</h3><h4 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h4><ol><li><code>Fragments</code>相当于<code>Vue</code>中的<code>template</code>，不会渲染真实<code>DOM</code>，这在封装组件时将会非常有用<ol><li>不同于<code>template</code>的地方是循环时，可以为<code>Fragment</code>增加<code>key</code>属性</li><li>当你不需要在<code>Fragments</code>标签中添加任何<code>prop</code>且工具支持的情况下，可以使用短语法来代替<code>&lt;&gt;&lt;/&gt;</code></li></ol></li><li><code>Suspend</code>用于包裹异步组件，可以包裹任意多个，异步组件必须用它包裹，使用<code>fallback</code>属性指定异步组件没有加载完成时的样式</li><li><code>StrictMode</code>包裹的子组件在<strong>开发模式</strong>会进行一些严格的检查，目前有：<ol><li>识别不安全的生命周期</li><li>关于使用过时字符串<code>ref API</code>的警告</li><li>关于使用废弃的<code>findDOMNode</code>方法的警告</li><li>检测意外的副作用</li></ol></li></ol><h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><ol><li><p>通过<code>React.createRef()</code>来获取真实DOM，或则设置<code>ref</code>属性，绑定一个回调方法，接收一个参数为DOM对象的回调方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.textInput = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">         &lt;input</span><br><span class="line">             type=<span class="string">"text"</span></span><br><span class="line">             ref=&#123; <span class="keyword">this</span>.textInput &#125;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    focus () &#123;</span><br><span class="line">        <span class="keyword">this</span>.textInput.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取子组件内的真实DOM</p><ol><li>父组件利用<code>React.createRef</code>创建ref，然后作为<code>prop</code>传递给子组件，给子组件内的元素设置<code>ref</code>属性</li><li><p>父组件利用<code>React.createRef</code>创建ref，然后设置子组件的<code>ref</code>为创建的ref，然后通过<code>React.forwardRef</code>定义子组件，其接收一个<code>callback</code>（最好使用具名<code>function</code>或者设置<code>function.displayName</code>，这样在<code>react devtools</code>中能够友好显示），通过参数来获取传递给它的<code>ref</code></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">&lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/</span>FancyButton&gt;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>当使用第三方库操作<code>DOM</code>时，为了避免冲突，最好使用空的<code>HTML</code>元素，即这个元素既没有属性也没有子元素，例如<code>&lt;div /&gt;</code>，这样<code>React</code>就没有理由去更新它，避免冲突</p></li><li><code>ref</code>会在<code>componentDidMount</code>或<code>componentDidUpdate</code>生命钩子触发前更新</li><li><strong>函数式组件</strong>上不能使用<code>ref</code>属性，可以使用<code>React.forwardRef</code></li></ol><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><ol><li>通过<code>props</code>和<code>callback</code>的方式</li><li><p>通过<code>Context</code>，使用方式如下：</p><ol><li>当<code>Provider</code>的<code>value</code>值发生变化时，它内部的所有消费组件都会重新渲染</li><li><code>Provider</code>及其内部的<code>consumer</code>（消费者）组件都不受制于<code>shouldComponentUpdate</code>函数</li><li>挂载在<code>class</code>上的<code>contextType</code>属性重赋值为一个由<code>React.createContext()</code>创建的<code>Context</code>对象，这能让你使用<code>this.context</code>来消费最近<code>Context</code>上的那个值</li><li>使用<code>Context.Consumer</code>能让函数式组件订阅<code>context</code>，这需要<strong>函数作为子元素</strong>，因为函数式组件没有实例，不能采用定义<code>Component.contextType</code>的方法，或者采用<code>useContext</code>hook</li><li>如果在子组件中想要更新<code>context</code>，可以通过<code>Context.provide</code>的<code>value</code>传递一个函数</li><li><p>为了确保<code>context</code>快速进行重渲染，<code>React</code>需要使每一个<code>consumers</code>组件的<code>context</code>在组件树中成为一个单独的节点，即每个<code>consumer</code>必须包含一个单独节点</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Consume&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;p&gt;&#123; value &#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>MyContext.Consume&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">            &lt;Toolbar /&gt;</span><br><span class="line">        &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ThemedButton /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class ThemedButton extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 指定 contextType 读取当前的 theme context。</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line"><span class="regexp">    static contextType = ThemeContext;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;Button theme=&#123;this.context&#125; /</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="组件加载"><a href="#组件加载" class="headerlink" title="组件加载"></a>组件加载</h4><ol><li><p>使用<code>React.lazy</code>来动态引入组件，<code>React.lazy</code>目前只支持默认导出，如果需要使用命名导出，可以创建一个中间模块，使用<code>export { xxx as default } from</code>来重新导出为默认模块</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">             &lt;OtherComponent /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><ol><li><p>在<code>React</code>中，要实现类似于<code>Vue</code>的<code>component</code>（动态组件）的效果很简单，如下：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="keyword">from</span> <span class="string">'./stories'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">    photo: PhotoStory,</span><br><span class="line">    video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SpecificStory = components[props.storyType];</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SpecificStory</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li>使用<code>ReactDOM.createPortal(child, container)</code>可以将子节点渲染到存在于父组件以外的<code>DOM</code>节点上，其所有特征与普通的<code>React</code>组件嵌套没有什么不同，包括<strong>事件冒泡</strong></li><li><code>Class.defaultProps</code>用于设置<code>props</code>的默认值</li></ol><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ol><li>错误边界组件：使用正常的<code>class</code>组件定义方式，当定义了<code>getDerivedStateFromError()</code>或<code>componentDidCatch()</code>这两个生命周期方法中的任意一个时，那么它就变成了一个错误边界<ol><li>getDerivedStateFromError：返回一个<strong>对象</strong>，取代<code>state</code>，在<code>render</code>函数中根据<code>state</code>进行判断是否渲染<code>error UI</code></li><li>componentDidCatch: 打印错误信息</li><li>只能捕获子组件的错误，无法捕获自身的错误</li></ol></li></ol><h4 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h4><p>高阶组件只是一种<strong>设计模式</strong>，其表现为：组件作为参数，返回值为新组件的函数</p><ol><li>不会修改传入的组件，也不会使用继承来复制其行为</li><li>通过将组件<strong>包装在容器组件中</strong>来组成新组件</li><li>被包装组件接收来自容器组件的所有<code>prop</code></li><li>为了方便调试，可以修改<code>HOC</code>的<code>displayName</code>，通常采用的命名方法是<code>HOCName(WrappedComponent)</code></li><li>不要在<code>render</code>方法中使用<code>HOC</code>，它会导致以下几个问题：<ol><li>每次调用<code>render</code>时，都会使用<code>HOC</code>创建一个新的组件，这将导致子树每次渲染都会进行卸载，和重新挂载的操作</li><li>重新挂载将会导致该组件及其所有子组件的状态丢失</li></ol></li><li>当被包裹组件上有静态方法时，使用<code>HOC</code>进行包装之后，新返回的组件并没有这些静态方法，解决这个问题，有以下几种方法<ol><li>使用<code>hoist-non-react-statics</code>库拷贝组件的静态方法到返回的包装组件上</li><li>单独导出组件的静态方法，并在需要使用的时候单独引入它</li></ol></li></ol><h3 id="React原理"><a href="#React原理" class="headerlink" title="React原理"></a>React原理</h3><h4 id="diffing算法"><a href="#diffing算法" class="headerlink" title="diffing算法"></a>diffing算法</h4><p><code>diff</code>步骤：</p><ol><li>对比元素类型，如果不同，则销毁组件实例，然后挂载新组件</li><li>对比元素的属性，仅对比及更新有改变的属性</li></ol><p>注意点：</p><ol><li>当一个组件更新时，组件实例保持不变，这就是<code>state</code>在跨越不同的渲染时能保持一致的原因。在更新时，<code>React</code>将更新该组件实例的<code>props</code>，并且调用该实例的<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>方法</li><li>当往列表末尾插入元素时，开销较小；但是往开头插入时，每一个元素都必须进行<code>mutate</code>，<code>key</code>可以解决这个问题</li></ol><h3 id="React相关库"><a href="#React相关库" class="headerlink" title="React相关库"></a>React相关库</h3><h4 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h4><ol><li>react-router</li><li>redux</li><li>relay</li><li>immutable、immer、immutability-helper、seamless-immutable</li><li>prop-types: <code>props</code>类型检查</li><li>hoist-non-react-statics: 静态方法拷贝</li><li>react-window/react-virtualized: 虚拟滚动库</li></ol><h4 id="webpack相关"><a href="#webpack相关" class="headerlink" title="webpack相关"></a>webpack相关</h4><ol><li>@babel/plugin-proposal-class-properties: 可以解决类组件中需要手动调用<code>bind</code>来绑定<code>this</code>的问题，采用箭头函数进行方法的定义</li><li>@babel/plugin-proposal-class-properties: 在<code>React</code>类组件中可以通过声明<code>defaultProps</code>作为静态属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;备注&quot;&gt;&lt;a href=&quot;#备注&quot; class=&quot;headerlink&quot; title=&quot;备注&quot;&gt;&lt;/a&gt;备注&lt;/h2&gt;&lt;p&gt;当前笔记基于&lt;code&gt;React v16.8.6&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/React/"/>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/React/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Element与Component与Instance</title>
    <link href="http://yoursite.com/2019/09/25/Element%E4%B8%8EComponent%E4%B8%8EInstance.html"/>
    <id>http://yoursite.com/2019/09/25/Element与Component与Instance.html</id>
    <published>2019-09-25T08:47:50.000Z</published>
    <updated>2019-09-25T09:05:40.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>其实就是<code>virtual dom</code>，用js对象来描述一个<code>dom</code>节点，它的<code>type</code>类型可以是字符串（HTML Tag Name）、Components、HTML Node，一个Element Tree最终渲染时只能包含<code>HTML Tag Name</code></p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>在React中定义组件的方式有很多中：</p><ol><li>创建一个<code>Class</code>继承自<code>React.Component</code></li><li>单纯的功能组件，是一个<code>Function</code>，返回一个<code>Element</code></li><li>调用<code>React.createClass</code></li></ol><h2 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h2><p>实例就是我们创建<code>Class Components</code>时，<code>this</code>的指向，它描述了这个组件相关的一些信息，<code>Function Components</code>是没有实例的，对于存储本地状态和对声明周期时间作出反应很有用</p><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>但我们创建一个Element时，使用<code>React.createElement</code>、<code>JSX</code>、<code>element factory helper</code>，不要直接使用<code>plain object</code></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Element&quot;&gt;&lt;a href=&quot;#Element&quot; class=&quot;headerlink&quot; title=&quot;Element&quot;&gt;&lt;/a&gt;Element&lt;/h2&gt;&lt;p&gt;其实就是&lt;code&gt;virtual dom&lt;/code&gt;，用js对象来描述一个&lt;code&gt;dom&lt;/
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/React/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/React/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>正向代理、反向代理、透明代理</title>
    <link href="http://yoursite.com/2019/09/24/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html"/>
    <id>http://yoursite.com/2019/09/24/正向代理与反向代理与透明代理.html</id>
    <published>2019-09-24T14:56:46.000Z</published>
    <updated>2019-09-26T13:13:48.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="什么是正向代理"><a href="#什么是正向代理" class="headerlink" title="什么是正向代理"></a>什么是正向代理</h3><p>正向代理是当客户端获取源服务器的内容时，通过携带上源服务器的域名和端口号访问一个中间服务器，中间服务器接收到需要访问的源服务器域名和端口，然后请求源服务器获取内容，并将内容返回给客户端</p><h3 id="正向代理的特点"><a href="#正向代理的特点" class="headerlink" title="正向代理的特点"></a>正向代理的特点</h3><ol><li>隐藏了客户端，客户端对于源服务器而言是不可见的</li><li>代理了客户端</li><li>客户端需要进行一些特别的设置</li><li>由客户端决定要访问哪个源服务器，代理服务器只做转发功能</li><li><p>启用了正向代理后，请求头首行会包含请求的整个url，例如请求<a href="http://www.a.com，所以可以据此来判断一个请求是否被代理过" target="_blank" rel="noopener">www.a.com，所以可以据此来判断一个请求是否被代理过</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正向代理</span><br><span class="line">GET http://www.a.com/ HTTP/1.1</span><br><span class="line"></span><br><span class="line">// 非正向代理</span><br><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure></li></ol><h3 id="正向代理的应用"><a href="#正向代理的应用" class="headerlink" title="正向代理的应用"></a>正向代理的应用</h3><ol><li>VPN应用，例如Shadowsocks在Mac中的应用，通过设置网络-&gt;网络偏好设置-&gt;高级-&gt;代理-&gt;自动代理-&gt;代理配置文件地址默认为（<a href="http://127.0.0.1:8090/proxy.pac），同时选择一个节点（比如日本1之类的，其实就是中间服务器的地址）。配置成功后，当我们访问外网，例如" target="_blank" rel="noopener">http://127.0.0.1:8090/proxy.pac），同时选择一个节点（比如日本1之类的，其实就是中间服务器的地址）。配置成功后，当我们访问外网，例如</a> <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 或 <a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a> 时，这两个域名被包含在在proxy.pac中的rules数组中，所以会走代理，请求你选择的节点（这里为日本1）服务器，并携带上源服务器的地址（这里为 <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 或 <a href="https://www.facebook.com/），然后节点服务器接收到请求后，获得你要请求的源服务器地址并发送请求，获得内容然后返回给你" target="_blank" rel="noopener">https://www.facebook.com/），然后节点服务器接收到请求后，获得你要请求的源服务器地址并发送请求，获得内容然后返回给你</a></li><li>手机的代理功能</li></ol><h3 id="正向代理的作用"><a href="#正向代理的作用" class="headerlink" title="正向代理的作用"></a>正向代理的作用</h3><ol><li>访问某些不可达的服务器，例如VPN、客户端与源服务器中间的某个路由器故障导致访问不了等。</li><li>加速访问服务器，这种说法不像以前那么流行了，主要是因为带宽流量的飞速发展。客户端到源服务都是低带宽链路，而客户端到代理服务器、代理服务器到源服务器都是高带宽链路，这样即加快了访问服务器的速度。</li><li>Cache作用。第一次访问某资源时代理服务器将资源缓存到本地，后续再次访问直接返回，不用再去请求源服务器（PS: 这不是nginx的实现原理，nginx采用的是反向代理机制）。</li><li>客户端访问授权。代理服务器进行权限过滤，允许符合权限的客户端访问源服务器，否则访问源服务器时，丢弃数据包。</li><li>隐藏客户端</li></ol><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h3><p>反向代理是客户端访问某一服务器时，这个<strong>服务器判断</strong>将请求转发到何处，并将获得的内容返回给客户端</p><h3 id="反向代理的特点"><a href="#反向代理的特点" class="headerlink" title="反向代理的特点"></a>反向代理的特点</h3><ol><li>隐藏了源服务器，源服务器对于客户端是不可见的，对于客户端而言，代理服务器就相对于源服务器</li><li>代理了服务器</li><li>客户端不需要进行设置</li><li>由代理服务器决定访问哪个源服务器</li></ol><h3 id="反向代理的应用"><a href="#反向代理的应用" class="headerlink" title="反向代理的应用"></a>反向代理的应用</h3><ol><li>保护和隐藏原始服务器，例如源服务器的防火墙只允许代理服务器Z进行访问，客户端只能通过访问代理服务器Z来获取源服务器的资源，并不知道源服务器的地址</li><li>负载均衡，当反向代理服务器不只一个时，我们可以把它们做成集群，当更多的用户访问源服务器时，让不同的代理服务器去应答不同的用户，然后发送不同用户需要的资源（CDN技术的核心）</li></ol><h4 id="负载均衡和CDN的区别"><a href="#负载均衡和CDN的区别" class="headerlink" title="负载均衡和CDN的区别"></a>负载均衡和CDN的区别</h4><ol><li>CDN是由多个<strong>反向可缓存</strong>的代理服务器组成，源服务器就一个，通过DNS解析成不同反向可缓存的代理服务器的IP来实现</li><li>负载均衡只有一个反向代理服务器，源服务器有多个，DNS解析成反向代理服务器的IP，只有一个<ol><li>单机：所有功能部署在一台服务器上</li><li>集群：有多台服务器，每台服务器都部署了所有功能，通过nginx反向代理实现负载均衡</li><li>分布式：有多台服务器，对功能进行划分成不同的子系统，部署在不同的服务器上，每台服务器负责不同的功能，每个子系统就被称为<strong>服务</strong>。这些子系统能够运行在web容器中，它们之间通过<code>RPC</code>方式通信</li></ol></li></ol><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。</p><h2 id="如何区分正向代理和反向代理"><a href="#如何区分正向代理和反向代理" class="headerlink" title="如何区分正向代理和反向代理"></a>如何区分正向代理和反向代理</h2><p>主要区别：</p><ol><li>客户端是否需要进行配置</li></ol><p>正向代理：</p><p>客户端需要配置代理服务器的地址和端口，客户端拦截原请求，转发到代理服务器，并带上原请求的地址和端口，代理服务器取得请求携带的原地址和端口，可以直接把请求转发到原服务器或者进行配置，转发到其它服务器，例如VPN。</p><p>反向代理：</p><p>客户端请求代理服务器，服务器进行配置，根据请求内容转发到不同的源服务器，并将内容返回给客户端，例如nginx负载均衡</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h2&gt;&lt;h3 id=&quot;什么是正向代理&quot;&gt;&lt;a href=&quot;#什么是正向代理&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="正向代理" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="透明代理" scheme="http://yoursite.com/tags/%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>npm之简介</title>
    <link href="http://yoursite.com/2019/09/20/npm%E4%B9%8B%E7%AE%80%E4%BB%8B.html"/>
    <id>http://yoursite.com/2019/09/20/npm之简介.html</id>
    <published>2019-09-20T03:50:46.000Z</published>
    <updated>2019-09-24T14:55:54.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm"></a>什么是npm</h2><p>npm是世界上最大的软件注册表。js包管理工具，包的结构能够使我们轻松的跟踪依赖项和版本。</p><p>npm由三部分组成：</p><ol><li>网站：开发者查找包，设置参数以及管理npm使用体验的主要途径</li><li>注册表：是一个巨大的数据库，保存了每个包的信息</li><li>CLI：通过命令行或终端运行</li></ol><h2 id="如何安装npm-amp-管理npm版本"><a href="#如何安装npm-amp-管理npm版本" class="headerlink" title="如何安装npm&amp;管理npm版本"></a>如何安装npm&amp;管理npm版本</h2><p>安装npm：NodeJs官网进行下载安装</p><p>管理npm版本：使用nvm进行npm多版本管理</p><p>更新npm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -v // 显示当前npm版本</span><br><span class="line">npm install npm@latest -g // 安装官方最新测试版本</span><br><span class="line">npm install npm@next -g // 安装即将发布的最新版本</span><br></pre></td></tr></table></figure><h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Semver全称Semantic versioning（语义化版本），其作用是当开发者依赖某个包时，当包更新时，开发者能通过Semver明确这次更新的程度与影响范围，并在必要时更改他们的代码来适配新的版本。</p><p>npm使用语义化控制版本，我们可安装一定版本范围内的npm包，npm会选择和你指定的版本<strong>相匹配</strong>的<strong>latest（最新版本）</strong>安装。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>npm的版本号由三部分组成，变更不同的版本号代表不同的意义：</p><ul><li>主版本号（major）</li><li>次版本号（minor）</li><li>补丁版本号（patch）</li></ul><table><thead><tr><th>更改内容</th><th>阶段</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>第一次发布</td><td>New Product</td><td>把1.0.0作为起始版本</td><td>1.0.0</td></tr><tr><td>向后兼容的Bug修复或极小的改动</td><td>Patch release</td><td>patch版本+1</td><td>1.0.1</td></tr><tr><td>向后兼容的新功能</td><td>Minor release</td><td>minor版本+1</td><td>1.1.0</td></tr><tr><td>不向后兼容的更改</td><td>Major release</td><td>major版本+1</td><td>2.0.0</td></tr></tbody></table><p>有时候为了表达更确切的版本，还会在版本号后面添加<strong>标签</strong>或者<strong>扩展</strong>，来说明是预发布版本或者测试版本等，例如：2.0.2-beta-3。</p><p>常见的标签有：</p><table><thead><tr><th>标签</th><th>意义</th><th>说明</th></tr></thead><tbody><tr><td>demo</td><td>demo版本</td><td>可能用于验证问题的版本</td></tr><tr><td>dev</td><td>开发版</td><td>开发阶段使用，bug多，体积较大等特点，功能不完善</td></tr><tr><td>alpha</td><td>α版本</td><td>用于内部交流或者测试人员测试，bug较多</td></tr><tr><td>beta</td><td>测试版本（β版本）</td><td>较α版本，有较大的改进，但是还是有bug</td></tr><tr><td>gamma</td><td>伽马版本（γ版本）</td><td>较α和β版本有很大的改进，与稳定版相差无几，用户可使用</td></tr><tr><td>trial</td><td>试用版本</td><td>本软件通常都有时间限制，过期之后用户如果希望继续使用，一般得交纳一定的费用进行注册或购买。有些试用版软件还在功能上做了一定的限制。</td></tr><tr><td>stable</td><td>稳定版本</td><td></td></tr><tr><td>csp</td><td>内容安全版本</td><td>js库常用</td></tr></tbody></table><h2 id="限制安装包的版本"><a href="#限制安装包的版本" class="headerlink" title="限制安装包的版本"></a>限制安装包的版本</h2><p>在package.json中可以通过一些符号来限制包只能更新到某个版本</p><ul><li>Patch release: 1.0 or 1.0.x or ~1.0.x</li></ul><h2 id="安装包的方式"><a href="#安装包的方式" class="headerlink" title="安装包的方式"></a>安装包的方式</h2><p>安装包有两种方式：本地安装和全局安装，采用何种安装方式取决于要如何使用这个包：</p><ul><li>如果你自己的模块依赖于某个包，并且通过NodeJs的<code>require</code>加载，那么你应该选择本地安装这个包，这也是<code>npm install</code>命令的默认行为</li><li>如果你想将包作为一个命令行工具，比如<code>grunt CLI</code>，那么你应该选择全局安装</li></ul><h3 id="本地包"><a href="#本地包" class="headerlink" title="本地包"></a>本地包</h3><h3 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是npm&quot;&gt;&lt;a href=&quot;#什么是npm&quot; class=&quot;headerlink&quot; title=&quot;什么是npm&quot;&gt;&lt;/a&gt;什么是npm&lt;/h2&gt;&lt;p&gt;npm是世界上最大的软件注册表。js包管理工具，包的结构能够使我们轻松的跟踪依赖项和版本。&lt;/p&gt;
&lt;p&gt;n
      
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序之webview常见问题</title>
    <link href="http://yoursite.com/2019/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwebview%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2019/08/28/微信小程序之webview常见问题.html</id>
    <published>2019-08-28T08:55:48.000Z</published>
    <updated>2019-09-20T09:50:11.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;lang=zh_CN&amp;token=585555149&amp;docid=ebfd9e5ec9986b4f23c41f8d8bbf2730" target="_blank" rel="noopener">官方汇总链接</a></p><p><a href="https://zhuanlan.zhihu.com/p/33985049" target="_blank" rel="noopener">微信小程序内嵌网页的一些（最佳）实践 </a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>web-view 不支持推送服务通知（或称模板消息)</li><li>webview 里面的网页不能调用JSSDK进行微信支付，需要小程序原生页面通过小程序的支付api进行支付</li><li>web-view 跟小程序是独立的两个环境，数据完全不通，包括 cookie、session、localStorage 等等；</li><li>但小程序内嵌 web-view 跟微信内置浏览器是一套环境，也就是说你在 web-view 里面留下的以上痕迹，到微信里内置浏览器打开也有；</li><li>在两种环境下，不太容易区分到底是什么环境，小程序官方给的判断方法是 window.__wxjs_environment === ‘miniprogram’，但是在 web-view 进入第二页时候，安卓机下这个变量就 undefined 了。</li></ol><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ol><li>打开的域名没有在小程序管理后台设置业务域名(注意是业务域名，不是服务器域名)；</li><li>打开的页面 302 过去的地址也必须设置过业务域名；</li><li>页面可以包含 iframe，但是 iframe 的地址必须为业务域名；</li><li>打开的页面必须为 https 服务；</li><li>开发者自己检查自己的 https 服务是否正常，测试方法：普通浏览器打开对应的地址；</li><li>iOS上传图片问题 iOS小程序webview内input选择文件崩溃</li><li>webview postmessage 给小程序，data对应的值必须是个对象，不能是字符串<a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0000429a4004205ecf96ea80c51004&amp;highline=web-view&amp;comment_lvl=1，如下图" target="_blank" rel="noopener">https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0000429a4004205ecf96ea80c51004&amp;highline=web-view&amp;comment_lvl=1，如下图</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/blogdetail?action=ge
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="常见问题" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>H5上传图片</title>
    <link href="http://yoursite.com/2019/08/28/H5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.html"/>
    <id>http://yoursite.com/2019/08/28/H5上传图片.html</id>
    <published>2019-08-28T08:36:26.000Z</published>
    <updated>2019-08-28T09:11:59.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img width="500" src="/assets/mobile/solution/h5上传图片.png"></p><h2 id="问题-amp-解决方案"><a href="#问题-amp-解决方案" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h2><h3 id="如何区分环境"><a href="#如何区分环境" class="headerlink" title="如何区分环境"></a>如何区分环境</h3><p>通过 User Agent 来区分。 UA 中含有 MicroMessage 表明为微信环境。<br>UA 中或者 cookie 中含有 cdvsupport 表明为 APP 环境。<br>UA 匹配/(i[^;]+;( U;)? CPU.+Mac OS X/ 表明是 IOS 环境。</p><h3 id="在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法"><a href="#在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法" class="headerlink" title="在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法"></a>在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法</h3><p>File 对象 h5 文件上传后的对象， 也是作为最终通过 FormData 上传的对象。<br>HTMLImageElement 通过 new Image 创建， 可以获取上传图片的宽高。</p><p>HTMLCanvasElemen 对象 用于图片压缩，通过 toBlob 获取 blob 对象 和 canvas.toDataURL 方法获取 dataurl</p><h3 id="图片如何实现压缩的"><a href="#图片如何实现压缩的" class="headerlink" title="图片如何实现压缩的"></a>图片如何实现压缩的</h3><p>将图片转化成 canvas 对象，利用 canvas.toBlob 和 canvas.toDataURL 的压缩参数来进行压缩。 因而上传的图片需要先转化成 canvas。</p><h3 id="在微信内部调用-h5-方法需要哪些提前的准备工作和注意事项"><a href="#在微信内部调用-h5-方法需要哪些提前的准备工作和注意事项" class="headerlink" title="在微信内部调用 h5 方法需要哪些提前的准备工作和注意事项"></a>在微信内部调用 h5 方法需要哪些提前的准备工作和注意事项</h3><p>微信分享<br>微信公众号开发相关</p><h3 id="在这个过程中运用了哪些第三方库，是干什么用的"><a href="#在这个过程中运用了哪些第三方库，是干什么用的" class="headerlink" title="在这个过程中运用了哪些第三方库，是干什么用的"></a>在这个过程中运用了哪些第三方库，是干什么用的</h3><ol><li>exifjs <a href="http://code.ciaoca.com/javascript/exif-js" target="_blank" rel="noopener">http://code.ciaoca.com/javascript/exif-js</a> 获取图片的 Orientation 属性（拍摄方向） Tip: exif 的获取 Orientation 的渊源</li><li>swiper <a href="https://www.swiper.com.cn/usage/index.html" target="_blank" rel="noopener">https://www.swiper.com.cn/usage/index.html</a> 图片预览</li><li>touch.js <a href="https://allcky.github.io/touchjs/" target="_blank" rel="noopener">https://allcky.github.io/touchjs/</a> 在裁剪图片时，支持用户缩放，移动图片</li><li>toBlob.js <a href="https://github.com/eligrey/canvas-toBlob.js/" target="_blank" rel="noopener">https://github.com/eligrey/canvas-toBlob.js/</a> 解决 canvas.toBlob 的浏览器支持问题</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>小程序内嵌 h5 页面，如果使用原生 input 上传，在 IOS10 及以下会奔溃。因而，需要在微信小程序环境下，调用微信提供的原生 API。</li><li>在 APP 中，使用原生的 input 在安卓设备下无法调起摄像头。可以考虑原生 APP 提供的拍照和相册功能。</li></ol><h2 id="input-的-capture-amp-multiple-属性"><a href="#input-的-capture-amp-multiple-属性" class="headerlink" title="input 的 capture&amp;multiple 属性"></a>input 的 capture&amp;multiple 属性</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 无capture,无multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 无capture,有multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">multiple</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// capture="camera",无multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">capture</span>=<span class="string">"camera"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// capture="camera",有multiple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">capture</span>=<span class="string">"camera"</span> <span class="attr">multiple</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分别在 IOS 微信，IOS 非微信（Safari、QQ 浏览器）、Android 微信、Android 非微信（UC、原生）下进行实验</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th>无 capture,无 multiple</th><th>capture=”camera”,无 multiple</th><th>无 capture,有 multiple</th><th>capture=”camera”,有 multiple</th></tr></thead><tbody><tr><td>Android 微信</td><td>正常（单选）</td><td>仅相机</td><td>仅文件</td><td>正常</td></tr><tr><td>Android 非微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（单选）</td><td>仅相机</td></tr><tr><td>IOS 微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（多选）</td><td>仅相机</td></tr><tr><td>IOS 非微信</td><td>正常（单选）</td><td>仅相机</td><td>正常（多选）</td><td>仅相机</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>input[type=”file”]在不同环境下的表现形式不仅和 capture 属性有关，还和 multiple 有关</li><li>安卓系统下，无论是否加 multiple 属性，只能单选图片</li><li>无 capture、无 multiple 属性时，各种环境下表现正常且一致。因此若需求不要求多选图片，则可放心使用 &lt;input type=”file” accept=”image/*“&gt;</li><li>在进行开发时，大家要根据具体需求选择不同的兼容方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h2&gt;&lt;p&gt;&lt;img width=&quot;500&quot; src=&quot;/assets/mobile/solution/h5上传图片.png&quot;&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="解决方案" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>页面返回刷新方案</title>
    <link href="http://yoursite.com/2019/08/28/%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html"/>
    <id>http://yoursite.com/2019/08/28/页面返回刷新方案.html</id>
    <published>2019-08-28T08:16:54.000Z</published>
    <updated>2019-08-28T08:27:33.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需求中经常会遇到需要两个页面之间做联动的情况，比如：</p><p>一、从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列表页时，因为通用地址做了更改，需要列表页进行刷新重新获取列表项的操作；</p><p>二、从订单详情页点击评价进入到评价页面，当评价页面提交评价成功后，需要跳回到订单详情页，这时需要订单详情页展示评价的内容；</p><p>如果不用单页应用的方式实现，而只用两个不同页面 A 和 B 实现的话，以目前的方法，无论采取哪种，都会造成体验上的缺失：</p><p>A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，再通过 a 标签或 location.href 的方式打开一个新的 A 页面。这种情况会在 history 存在 3 个记录，用户从新的 A 页面点击返回按钮时，会从新的 A 页面 →B 页面 → 旧的 A 页面；<br>A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：history 会存在 2 个记录，用户从新的 A 页面点击返回时，会从新的 A 页面 → 旧的 A 页面，虽然看不到 B 页面（地址选择页、评价输入页等），但还是会返回到旧的 A 页面，也会造成用户的困惑；而且在 android 到家 webview 中，replace 仍然会保留之前页面的 history；<br>A 页面直接通过 location.replace 打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：虽然只有一条记录，在新的 A 页面可以直接返回 A 页面的来源页，但由于 B 页面是 replace A 页面的，当用户不想操作 B 页面而只想返回到 A 页面时，A 页面已经丢失了，会返回到 A 页面的来源页；且同样存在 android 到家 webview 中 replace 的问题；<br>更好的方法是（如果不用单页面应用），从 A 页面正常打开 B 页面（a 标签或 location.href），当在 B 页面操作成功后，直接返回到 A 页面(histroty.back()/history.go(-1)/点击回退按钮)。但这时往往由于浏览器强大的缓存能力，展现的是缓存的旧的 A 页面，与我们预想的展示新的 A 页面不符。</p><p>这时我们想到的，就是让 A 页面在监听到 B 页面的返回时，可以进行刷新操作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>用以下三个方法的结合，可以解决大部分机型缓存页面的问题。</p><h3 id="pageshow"><a href="#pageshow" class="headerlink" title="pageshow"></a>pageshow</h3><p>在 A 页面用监听 pageshow 事件，当浏览器从 B 页面返回时，会执行 pageshow 的回调，我们在事件中使用 location.reload()方法刷新 A 页面。网上的方案还会加上 pagehide 方法，以防 pageshow 不成功的情况，但在调研时发现只要支持 pagehide 的浏览器都支持会支持 pageshow，所以暂时用 pageshow 就可以搞定了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt.persisted) &#123;</span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：微信、safari、Chrome、Firefox、Yandex</p><p>Android：QQ 浏览器、Firefox、UC、手机百度</p><p>这些浏览器中的 A 页面会完全地缓存下来，时刻监听 pageshow/pagehide，当从 B 返回到 A 页面时，不会重新请求 html 文档，也不会重新执行 js。（参见 bfcache）</p><h3 id="借助前页面重新执行-js-的方法对比-html-文档版本号"><a href="#借助前页面重新执行-js-的方法对比-html-文档版本号" class="headerlink" title="借助前页面重新执行 js 的方法对比 html 文档版本号"></a>借助前页面重新执行 js 的方法对比 html 文档版本号</h3><p>有些浏览器不支持 pageshow/pagehide，但这些浏览器大部分都会在 A 页面重新被展示时，虽然不会拉取 html 文档，但是会重新执行一遍 A 页面的 js。这时我们可以借助重新执行 js 的机会，比较文档版本号（我们自己定义的），然后在判断是否是旧的 A 页面时，reload 页面。</p><p>具体操作：</p><ol><li>给每个需要后退刷新的页面上加一个 hidden input，存储页面在服务端的生成时间【需要后端支持】，作为页面的服务端版本号。</li><li>并附加一段 JS 读取读取页面的版本号，同时也记录在浏览器/webview 本地（cookie/localStorage/sessionStorage）进行存储，作为本地版本号。</li><li>JS 检查页面的服务端版本号和本地存储中的版本号，如果服务端版本号大于本地存储中版本号，说明页面是从服务端重新生成的；否则页面就是本地缓存的，即发生了后退行为。</li><li>JS 在监测到后退时，强制页面重新从服务端获取。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SERVER_TIME = <span class="built_in">document</span>.getElementById(<span class="string">'SERVER_TIME'</span>)</span><br><span class="line"><span class="keyword">var</span> REMOTE_VER = SERVER_TIME &amp;&amp; SERVER_TIME.value</span><br><span class="line"><span class="keyword">if</span> (REMOTE_VER) &#123;</span><br><span class="line">    <span class="keyword">var</span> LOCAL_VER = sessionStorage &amp;&amp; sessionStorage.PAGEVERSION</span><br><span class="line">    <span class="keyword">if</span> (LOCAL_VER &amp;&amp; <span class="built_in">parseInt</span>(LOCAL_VER) &gt;= <span class="built_in">parseInt</span>(REMOTE_VER)) &#123;</span><br><span class="line">        <span class="comment">//说明html是从本地缓存中读取的</span></span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//说明html是从server端重新生成的，更新LOCAL_VER</span></span><br><span class="line">        sessionStorage.PAGEVERSION = REMOTE_VER</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：UC、手机百度</p><p>Android：微信、Chrome、Yandex</p><h3 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h3><p>通过以上两种方法的结合，可以覆盖到大部分浏览器。但有一些浏览器在 A 页面打开 B 页面的过程中，像是开了一个新的 Webview 来展示 B 页面的（小米自带浏览器尤其明显，虽然用户看到的还是同一个 Tab），不会触发方法一和方法二。这时可以借助与浏览器 Tab 相关的 Page Visibility API，含义大概为当用户最小化页面或者切换到另一个 Tab 时，将触发 visibilitychange 方法，并可以通过判断此时页面展示相关的属性（document.hidden 、document.visibilityState）来确定页面的显示状态。</p><p>于是当浏览器疑似用新开 Webview 的方式做页面 A 到页面 B 的转跳时（再次强调，用户看到的还是同一个 Tab），页面 A 可以通过对 visibilitychange 事件，实现对返回的监听。</p><p>注：由于 visibilitychange 事件监听的是 Tab 之间的切换，所以当用户的浏览器打开了其它的 Tab，并与页面 A 所处的 Tab 间来回切换时，或者切换到其它的 APP 又回到浏览器时，同理也会触发我们的监听事件。这时如果不做特殊处理，也会导致页面 A 的刷新。（可以在页面 A 转跳到页面 B 时记录一个字段在本地存储，并在 visibilitychange 中通过此字段判断是否是 AB 之间的转跳）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        <span class="comment">// tab hidden</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// tab show</span></span><br><span class="line">        location.reload(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, handleVisibilityChange, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>支持的浏览器：</p><p>iOS：QQ 浏览器</p><p>Android：小米自带浏览器</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在调研的过程中，通过以上三个方法的结合，可以解决所有 Android&amp;iOS 浏览器。可能还有没试到的浏览器会有不支持的情况，发现后会及时更新。</p><p>以上为页面返回刷新方案的调研结果，有了对页面返回动作的监听，除了单纯地对缓存页面进行刷新，也可以结合需求做其它的操作。</p><p>三种方法的浏览器兼容情况：</p><table><thead><tr><th>方案</th><th>IOS</th><th>Android</th><th>说明</th></tr></thead><tbody><tr><td>pageshow/pagehide</td><td>微信、safari、Chrome、Firefox、Yandex</td><td>QQ 浏览器、Firefox、UC、手机百度</td><td>回退后不重新请求 html，不重新执行 js</td></tr><tr><td>重新执行 js 对比 Html 文档版本号</td><td>UC、手机百度</td><td>微信、Chrome、Yandex</td><td>回退后不重新请求 html，重新执行 js</td></tr><tr><td>Page Visibility API</td><td>QQ 浏览器</td><td>小米自带浏览器</td><td>回退后不重新请求 html，不重新执行 js</td></tr><tr><td>三种方法都不支持的情况</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>调研使用手机：</p><p>iOS: iPhone 7 Plus</p><p>Android: 红米 4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;需求中经常会遇到需要两个页面之间做联动的情况，比如：&lt;/p&gt;
&lt;p&gt;一、从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列
      
    
    </summary>
    
      <category term="移动端开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序之清除webview缓存</title>
    <link href="http://yoursite.com/2019/08/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%B8%85%E9%99%A4webview%E7%BC%93%E5%AD%98.html"/>
    <id>http://yoursite.com/2019/08/27/微信小程序之清除webview缓存.html</id>
    <published>2019-08-27T10:48:57.000Z</published>
    <updated>2019-08-28T08:17:05.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ol><li>微信-清理微信存储空间方法（iOS）<br>依次打开微信：我－设置 -  通用－存储空间 －清理微信缓存，就可以清理掉 webview 的缓存（实践表明：这种方法清理效果不好，经常清不掉）</li><li>Android清理方法<br> 在任意聊天窗口发送： <a href="http://debugx5.qq.com" target="_blank" rel="noopener">http://debugx5.qq.com</a> （必须手机端微信窗口访问），打开这个网址，找到清理缓存，点击即可（当然还有其他功能可以使用哦）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序&quot;&gt;&lt;a href=&quot;#小程序&quot; class=&quot;headerlink&quot; title=&quot;小程序&quot;&gt;&lt;/a&gt;小程序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;微信-清理微信存储空间方法（iOS）&lt;br&gt;依次打开微信：我－设置 -  通用－存储空间 －清理微信缓存，就可以清理掉 
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="常见问题" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序之文档笔记</title>
    <link href="http://yoursite.com/2019/07/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/2019/07/29/微信小程序之文档笔记.html</id>
    <published>2019-07-29T09:31:42.000Z</published>
    <updated>2019-08-27T10:48:12.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h2><h3 id="小程序的由来"><a href="#小程序的由来" class="headerlink" title="小程序的由来"></a>小程序的由来</h3><p>Web 应用存在的问题：</p><ol><li>即使<strong>微信 Web 资源离线存储</strong>技术能够解决一些问题，但对于一些复杂的页面仍有白屏问题，例如页面加载了大量的<code>js</code>和<code>css</code>文件</li><li>页面切换的生硬和点击的迟滞感</li></ol><p>​ 微信面临的问题是如何设计一个比较好的系统，使得所有开发者在微信中都能获得比较好的体验。这个问题是之前的 JS-SDK 所处理不了的，需要一个全新的系统来完成，它需要使得所有的开发者都能做到：</p><ol><li>快速的加载</li><li>更强大的能力</li><li>原生的体验</li><li>易用且安全的微信数据开发</li><li>高效和简单的开发</li></ol><h3 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h3><ol><li>web 中渲染线程和脚本线程是互斥的，而小程序采用的双线程</li><li>小程序中不能使用<code>DOM API</code>和<code>BOM API</code></li><li><p>不用面对各式各样的浏览器，只需要面对 ios、android 的微信客户端，以及用于辅助开发的小程序开发者工具</p><p> | 运行环境 | 逻辑层 | 渲染层 |<br> | IOS | JavaScriptCore | WKWebview |<br> | Android | V8 | chromium 定制内核 |<br> |开发者工具| NWJS | Chrome Webview |</p></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="WXSS选择器"><a href="#WXSS选择器" class="headerlink" title="WXSS选择器"></a>WXSS选择器</h3><ol><li>组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。</li><li>组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。</li><li>子元素选择器（.a&gt;.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。</li><li>继承样式，如 font 、 color ，会从组件外继承到组件内。</li><li>除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序简介&quot;&gt;&lt;a href=&quot;#小程序简介&quot; class=&quot;headerlink&quot; title=&quot;小程序简介&quot;&gt;&lt;/a&gt;小程序简介&lt;/h2&gt;&lt;h3 id=&quot;小程序的由来&quot;&gt;&lt;a href=&quot;#小程序的由来&quot; class=&quot;headerlink&quot; title=&quot;小
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="文档笔记" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之生成二维码</title>
    <link href="http://yoursite.com/2019/07/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html"/>
    <id>http://yoursite.com/2019/07/08/微信小程序之生成二维码.html</id>
    <published>2019-07-08T08:22:50.000Z</published>
    <updated>2019-07-09T08:56:04.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微信小程序根据url生成一个带logo的二维码</p><h2 id="weapp-qrcode"><a href="#weapp-qrcode" class="headerlink" title="weapp-qrcode"></a>weapp-qrcode</h2><p>使用<a href="https://github.com/yingye/weapp-qrcode" target="_blank" rel="noopener">weapp-qrcode</a>lib生成二维码</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><code>drawQrcode</code>方法要求传入<code>px</code>，如果页面布局使用的是<code>rpx</code>，需要动态进行转换</li><li>绘制二维码时使用到了<code>canvas</code>标签，而<code>canvas</code>标签是原生组件，层级高于普通标签，导致toast提示弹窗被<code>canvas</code>遮挡，于是把<code>canvas</code>隐藏到屏幕外，使用<code>image</code>标签配合<code>wx.canvasToTempFilePath</code>方法实现</li><li>要在二维码中绘制图片，使用的是<code>CanvasContext.drawImage</code>方法，但是此方法的图片来源必须是本地图片，所以需要先调用<code>wx.getImageInfo</code>或<code>wx.downloadFile</code>把图片下载到本地，然后用本地图片的路径进行绘制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;微信小程序根据url生成一个带logo的二维码&lt;/p&gt;
&lt;h2 id=&quot;weapp-qrcode&quot;&gt;&lt;a href=&quot;#weapp-qrco
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="问题积累" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="生成二维码" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="http://yoursite.com/2019/06/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html"/>
    <id>http://yoursite.com/2019/06/25/字符串的扩展.html</id>
    <published>2019-06-25T03:30:32.000Z</published>
    <updated>2019-06-25T12:40:29.449Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>解构赋值</title>
    <link href="http://yoursite.com/2019/06/24/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html"/>
    <id>http://yoursite.com/2019/06/24/解构赋值.html</id>
    <published>2019-06-24T13:03:32.000Z</published>
    <updated>2019-06-25T03:30:15.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><ol><li>如果等号的右边（或隐式转为对象后）不是可遍历的解构（Iterator），那么将会报错。</li><li>只有当一个数组成员严格等于（===）<code>undefined</code>时，默认值才会生效。</li></ol><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ol><li>对象的解构赋值可以取到继承的属性。</li><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</li><li>如果等号右边是字符串、数字、布尔值，则会隐式的转为对象。因为<code>undefined</code>和<code>null</code>无法转为对象，所以会报错。</li><li>不能使用圆括号的情况<ul><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式</li></ul></li><li>能使用圆括号的情况<ul><li>赋值语句的非模式部分</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果等号的右边（或隐式转为对象后）不是可遍历的解构（Iterator），那么将会报错。&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
</feed>
