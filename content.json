{"meta":{"title":"WgCg Blog","subtitle":"Keep Learning and Never Give Up","description":"WgCg、Cong.Wang、WangCong、Vue、Webpack、HTML、CSS、JS","author":"Cong.Wang","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2019-01-26T02:33:41.907Z","updated":"2019-01-26T02:33:41.907Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-01-26T02:26:44.100Z","updated":"2019-01-26T02:26:44.100Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"日程安排","date":"2019-01-26T02:35:23.254Z","updated":"2019-01-26T02:35:23.254Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-01-26T02:31:18.099Z","updated":"2019-01-26T02:31:18.099Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"echart问题记录","slug":"echart问题记录","date":"2019-12-23T13:15:17.000Z","updated":"2019-12-23T13:19:35.918Z","comments":true,"path":"2019/12/23/echart问题记录.html","link":"","permalink":"http://yoursite.com/2019/12/23/echart问题记录.html","excerpt":"","text":"先绘制 columns，再异步绘制 source，没有动画 指标切换的 label 显示不全，设置 legend.textStyle.lineHeight","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"echart","slug":"框架/echart","permalink":"http://yoursite.com/categories/框架/echart/"},{"name":"问题积累","slug":"框架/echart/问题积累","permalink":"http://yoursite.com/categories/框架/echart/问题积累/"}],"tags":[]},{"title":"http问题记录","slug":"http问题记录","date":"2019-12-23T13:15:02.000Z","updated":"2019-12-23T13:20:31.713Z","comments":true,"path":"2019/12/23/http问题记录.html","link":"","permalink":"http://yoursite.com/2019/12/23/http问题记录.html","excerpt":"","text":"Chrome 302 发起多余的GET请求 浏览器发起一个 post 请求，后端返回 302 会导致原请求变成 GET 请求并且 Post Data 丢失（在 network 中，会出现 3 次请求记录，原请求，原请求的 GET 方法（不应该显示），302 的请求），问题链接，解决方案： 后端请求需要 302 的地址，获取数据后，返回给前端 200 返回 307：告诉浏览器按照 original request 的方法发起新的 redirect request，但是要向用户提示安全警告，但是这并不总是有效的，因为它不是 http common status code（HTTP 常见状态码），不同浏览器实现逻辑不一致 IE7： 不会给予警告 safari: 它不会引发确认对话框并执行重定向，并且丢弃 post data，将 307 转为 302","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/categories/HTTP/"},{"name":"问题积累","slug":"HTTP/问题积累","permalink":"http://yoursite.com/categories/HTTP/问题积累/"}],"tags":[]},{"title":"ant-design问题记录","slug":"ant-design问题记录","date":"2019-12-23T13:14:45.000Z","updated":"2019-12-23T13:21:22.110Z","comments":true,"path":"2019/12/23/ant-design问题记录.html","link":"","permalink":"http://yoursite.com/2019/12/23/ant-design问题记录.html","excerpt":"","text":"Select select dropdownMatchSelectWidth=false 导致设置的 width 没用 会被设置为 min-width select 增加 getPopupContainer 无效，给弹出层的父级增加 postion:relative PageHeader page-header .ant-page-header-content 的 overflow:hidden 导致输入框的 focus 的 box-shadow 不显示 DatePicker DatePicker 组件没有 getPopupContainer 属性，而是 getCalendarContainer 属性，且不能通过 ConfigProvider 统一添加","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"ant-design","slug":"框架/ant-design","permalink":"http://yoursite.com/categories/框架/ant-design/"},{"name":"问题积累","slug":"框架/ant-design/问题积累","permalink":"http://yoursite.com/categories/框架/ant-design/问题积累/"}],"tags":[]},{"title":"umi官方文档笔记","slug":"umi官方文档笔记","date":"2019-10-26T03:06:29.000Z","updated":"2019-12-23T13:12:22.962Z","comments":true,"path":"2019/10/26/umi官方文档笔记.html","link":"","permalink":"http://yoursite.com/2019/10/26/umi官方文档笔记.html","excerpt":"","text":"路由 src/layouts/index.js(配置式路由下无效): 全局布局，在路由外面套的一层路由。 1234[ &#123; path: \"/\", component: \"./pages/index\" &#125;, &#123; path: \"/users\", component: \"./pages/users\" &#125;]; 如果有layouts/index.js，那么路由就会变为： 12345678910[ &#123; path: \"/\", component: \"./layouts/index\", routes: [ &#123; path: \"/\", component: \"./pages/index\" &#125;, &#123; path: \"/users\", component: \"./pages/users\" &#125; ] &#125;]; 生成的路由配置字段 Routes: 权限路由配置 routes: 路由配置 API umi/link: 提供Link组件 umi/navLink: 提供NavLink组件 umi/router: 提供router实例 umi/withRouter: 添加router相关的属性到props中 umi/dynamic: 提供按需加载的接口 问题 路由/通过扩展注释路由：Routes字段与嵌套路由的routes不同","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"umi","slug":"框架/umi","permalink":"http://yoursite.com/categories/框架/umi/"},{"name":"笔记","slug":"框架/umi/笔记","permalink":"http://yoursite.com/categories/框架/umi/笔记/"}],"tags":[]},{"title":"redux官方文档笔记","slug":"redux官方文档笔记","date":"2019-10-17T06:53:14.000Z","updated":"2019-10-23T12:45:53.361Z","comments":true,"path":"2019/10/17/redux官方文档笔记.html","link":"","permalink":"http://yoursite.com/2019/10/17/redux官方文档笔记.html","excerpt":"","text":"redux三大原则 单一数据源，所有的状态存储在一个store中 State是只读的，唯一改变的方法是触发action 使用纯函数来执行修改，只要传入参数相同，reducer返回计算得到的下一个state就一定相同。没有特殊情况、没有副作用，没有API请求、没有变量修改，单纯执行计算。 redux数据流 调用store.dispatch(action) store调用传入的reducer函数 根reducer应该把多个子reducer输出合并成一个单一的state树 store保存了根reducer返回的完整的state树 最佳实践 action type放在一个地方统一维护，全部大写，以_分割 state尽量范式化，不要深层嵌套，尽量以ID为主键进行索引，例如: 1234567891011121314// bad&#123; todos: [ &#123; text: 'a', completed: true &#125;, &#123; text: 'b', completed: false &#125; ]&#125;// 目录规范 index.js: 合并reducer，创建store reducers.js: 定义reducer，reducer的名字和state中属性的名字保持一致，reducer中需要根据type文件中定义的类型进行匹配然后更改相应的state actions.js: 定义action工厂函数，接收要更新的state的值，返回包裹type的和更新的值的一个对象 正常的action创建函数只能进行一些同步的操作，且不能包含副作用，但是可以通过redux-thunk库来扩展action，实现异步的可包含副作用的action，并使用redux提供的applyMiddleware方法在createStore的时候把中间件添加进去 types.js: 定义action type，在reducers和actions中会用到 异步数据流*它提供的是位于 action 被发起之后，到达 reducer 之前的扩展点 react-redux组件的分类 展示组件 容器组件 作用 描述如何展现（骨架、样式） 描述如何运行（数据获取、状态更新） 直接使用 Redux 否 是 数据来源 props 监听redux state 数据修改 从props调用回调函数 向redux派发actions 调用方式 手动 通常由react redux生成 容器组件容器组件就是使用store.subscribe()从Redux state树中读取部分数据，并通过props来把这些数据提供给要渲染的组件 定义容器组件的过程主要如下： 定义mapStateToProps方法，该方法接收state为参数，根据state作一些计算，并把结果返回，传递给需要该数据的展示组件 定义mapDispatchToProps方法，该方法接收disptach为参数，并返回包含一些disptach操作的回调方法，传递给需要修改state的值的展示组件 API connect: 用于包裹组件，将state、disptach等方法作为props传递到组件中 hook useSelector: 与mapState不同，可以返回任意值，其返回的值作为useSelector的返回值 当dispatch一个action，useSelector会对返回值进行一个浅比较，如果不同则重新渲染组件 selector不接受ownProps参数，可以通过闭包或柯里化selector实现 使用memoizing selectors需要格外注意 避免组件渲染时重复生成selector，定义在函数式组件之外 如果多个组件调用，要保证每一个selector instance是不一致的，通过工厂函数实现 useSelecotr默认使用===检查，而不是浅比较，selector每次返回一个新对象会导致每次dispatch都重新渲染，以下方法可以解决这个问题 调用useSelector多次，每次都返回单一值，取代直接返回一个对象 使用reselect等相似的库，只有在对象里面的值改变时才返回一个新对象 传递第二个参数shallowEqual useDispatch useStore 组件 Provider: &lt;Provider store={store}&gt;&lt;App/&gt;&lt;/Provider&gt;能够让所有组件都能够访问store 三方库 redux-action/redux-act: 用于生成actions创建函数和reducer normalizr: 把嵌套的API响应数据范式化 以下库，通过包装store.dispatch方法，以此来让你dispatch一些除了action以外的其它内容，例如：函数或者promise redux-thunk redux-promise/redux-promise-middleware redux-observable redux-saga redux-pack reselect: 创建可记忆的(Memoized)，可组合的selector函数 redux-undo: 为redux状态树中能够的任何部分提供撤销和重做功能","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"redux","slug":"框架/redux","permalink":"http://yoursite.com/categories/框架/redux/"},{"name":"笔记","slug":"框架/redux/笔记","permalink":"http://yoursite.com/categories/框架/redux/笔记/"}],"tags":[]},{"title":"react-router官方文档笔记","slug":"react-router官方文档笔记","date":"2019-10-15T13:42:16.000Z","updated":"2019-10-17T02:09:54.954Z","comments":true,"path":"2019/10/15/react-router官方文档笔记.html","link":"","permalink":"http://yoursite.com/2019/10/15/react-router官方文档笔记.html","excerpt":"","text":"官方文档 注意事项 所有路由相关的标签必须嵌入在routes类型的标签之内 Route放在Switch中才会进行单一匹配，否则只要匹配成功的Route，都会进行渲染 如何衡量&lt;Route component/&gt;、&lt;Route render/&gt;、&lt;Route children/&gt;三种方式 &lt;Route component/&gt;: 在Route内部会根据传递的component的值通过React.createElement创建组件，这意味你如果传递一个内联方法（通常需要传递额外的非路由相关的props时使用），在每次渲染时都会销毁旧组件，创建一个新的组件，而不会更新旧组件，造成性能上的损失 &lt;Route render/&gt;: 解决了上述问题，但是有关路由的props都得自己手动传递一下 &lt;Route children/&gt;: 无论path是否匹配，都会触发children(不在Switch组件中)，可以根据match进行判断做一些特殊化处理，props也得手动传递 &lt;Route&gt;chidlren&lt;/Route&gt;: 这时候没法把路由参数传递给children组件，使用withRouter或者hooks进行操作 location是immutable的，而history.location是mutable的 immutable: 对象引用不会发生变化 mutable: 对象引用会发生变化 API文档react-router-domComponent routers: 以下所有的high-levelroutes都是基于Router组件封装的，Router组件一般配合状态管理库，例如redux、mbox进行同步自定义历史记录 BrowserRouter: history模式 basename: string : 配置所有路由的baseurl getUserConfirmation: func : 结合Prompt组件使用，可以在离开路由之前进行弹窗提醒 forceRefresh: bool : 路由跳转时是否刷新整个页面 keyLength: number : 设置location.key的长度，location可以通过useLocation或props取得 children: node : 要渲染的子元素 HashRouter: hash模式 basename: string : 配置所有路由的baseurl getUserConfirmation: func : 结合Prompt组件使用，可以在离开路由之前进行弹窗提醒 hashType : string : 设置hash模式的类型 slash: 以#/开头，默认值 noslash: 以#开头 hashbang: 以#!/开头，已被Google废弃 children: node : 要渲染的子元素 MemoryRouter: 在进行测试和非浏览器环境时使用，暂不介绍 NativeRouter: 用在Native环境，暂不介绍 StaticRouter: 通常用于服务端渲染或测试，暂不介绍 route matchers Route 有三种渲染组件的方式，无论是哪种渲染方式，都会接受match、location、history三个props &lt;Route component&gt; &lt;Route render&gt; &lt;Route children&gt;function path: string | string[]: 要匹配的路由，匹配成功后会渲染对应的组件 exact: bool: 是否是精确匹配，设置为true后，如果path设置为/pages，/pages/home不会匹配成功 strict: bool: 是否是严格匹配，设置为true后，如果path设置为/pages/，/pages不会匹配成功 location: object: Route匹配默认都是根据当前的history location进行匹配的，可以设置该属性更改匹配的location sensitive: bool: 是否大小写敏感 Switch: 当Switch组件渲染时，它会从上往下依次匹配children中的Route或者Redirect标签，匹配成功之后渲染该组件并停止匹配，如果没有匹配到，什么都不会渲染 location: object: 设置进行匹配的location，默认为current location children: node: 该组件的children只能包含Route和Redirect navigation/route changers Link: 跳转到某一路由，最终会渲染成a标签 to: 要跳转的路由，值的类型有多种，具体如下 string: 要跳转的路由对应的url object: 路由描述对象，具有以下属性 pathname search hash state: 附加跳转信息 function: 该方法接收当前路由的location对象为参数，返回要跳转路由的stringorobject描述 replace: bool: 替换当前路由 innerRef function : 该方法接收Link标签最后渲染成的DOM Node为参数，目前为a标签 RefObject : react.createRef创建的RefObject others: 其它想要设置到a标签的任意属性，例如title、id等等 NavLink: 与Link的作用一致，不同的是可以提供一个activeClassName属性，设置与当前路由匹配时的样式 activeClassName: string : 设置当路由匹配时的className，默认为active activeStyle: object : 设置当路由匹配时的样式 exact: bool : 当为true时，只有路径完全匹配，才会添加设置的activeClassName、activeStyle strict: bool : 当设置为true时，会对路由进行严格匹配，包括#、#/ isActive: func : 添加判断当前路由是否匹配的验证方法，参数为match，location location: object : 传递给isActive方法的location aria-current: string : 设置active时的aria-current属性，默认为page Redirect: 渲染该标签时，会立即将当前的路由转跳到该标签设置的to属性的值所对应的路由页面 to string: 要跳转的url object: location object push: bool: 设置为true，将会在浏览器历史记录中增加一条，即为push的效果 from: string: 只能当Redirect组件被包裹在Switch组件中时，才能使用该属性 exact: bool: from是否需要精确匹配 strict: bool: from是否需要严格匹配，少个\\都不行 sensitive: bool: from匹配时是否大小写敏感 prompt: 与routes的getUserConfirmation属性配合使用 Hooks useHistory useLocation useParams useRouteMatch 三方库异步组件/code splitting如果想要实现异步加载组件/代码拆分的功能，需要使用进行安装如下插件以及设置： @babel/plugin-synntax-dynamic-import {“plugins”: [“@babel/plugin-syntax-dynamic-import”]} loadable-components 开发使用 path-to-regexp 底层库 history","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"react-router","slug":"框架/react-router","permalink":"http://yoursite.com/categories/框架/react-router/"},{"name":"笔记","slug":"框架/react-router/笔记","permalink":"http://yoursite.com/categories/框架/react-router/笔记/"}],"tags":[]},{"title":"gitlab-ci","slug":"gitlab-ci","date":"2019-10-08T01:29:21.000Z","updated":"2019-10-08T01:38:11.254Z","comments":true,"path":"2019/10/08/gitlab-ci.html","link":"","permalink":"http://yoursite.com/2019/10/08/gitlab-ci.html","excerpt":"","text":"介绍GitLab CI pipeline 使用.gitlab-ci.yml文件来进行配置，用于定义管道的结构以及执行顺序，它决定了以下2点： 使用gitlab runner执行什么 当遇到某些特定的条件需要执行什么，例如，一个过程的成功或者失败","categories":[{"name":"其它技术","slug":"其它技术","permalink":"http://yoursite.com/categories/其它技术/"},{"name":"git","slug":"其它技术/git","permalink":"http://yoursite.com/categories/其它技术/git/"}],"tags":[]},{"title":"VueTypes文档","slug":"VueTypes文档","date":"2019-09-27T08:51:57.000Z","updated":"2019-09-30T10:32:25.505Z","comments":true,"path":"2019/09/27/VueTypes文档.html","link":"","permalink":"http://yoursite.com/2019/09/27/VueTypes文档.html","excerpt":"","text":"介绍VueTypes是一个用于验证Props属性的库 文档原始类型大多数原始类型具有以下特征： 默认值（.any与.symbol除外） .def(any)方法修改默认值 isRequired标志表示这个属性是否是必须的 .validate(function)方法传递一个验证函数进行验证（.integer除外） VueTypes.any 允许任何类型 没有默认值 VueTypes.array 数组类型 默认值：一个空数组 .def接收一个方法或数组为参数，数组会自动转换为工厂函数 VueTypes.bool 布尔类型 默认值：true VueTypes.func 函数类型 默认值：一个空函数 VueTypes.number 数字类型 默认值：0 VueTypes.object 对象类型 默认值：一个空对象 .def接收一个方法或数组为参数，数组会自动转换为工厂函数 VueTypes.string 字符串类型 默认值：’’ VueTypes.symbol symbol类型 没有默认值 原始类型相关的配置1234567891011121314151617// 是否采用VueTypes提供的默认值，默认为trueVueTypes.sensibleDefaults = true// 修改某个原始类型的默认值VueTypes.sensibleDefaults = &#123; string: 'mystringdefault' //...&#125;// 当你想要移除某个默认值的时候，可以这么做console.log(VueTypes.bool.default) // logs trueconst &#123; bool, ...newDefaults &#125; = VueTypes.sensibleDefaultsVueTypes.sensibleDefaults = newDefaultsconsole.log(VueTypes.bool.default) // logs undefined 自定义类型自定义类型具有以下特征： 不存在默认值 不存在.validate方法 .def方法设置默认值 isRequired标志这个属性是否必须 VueTypes.instanceOf(any) 验证prop的值是不是某个’类’的实例，跟instanceof操作符类似 VueTypes.oneOf(array) 验证prop的值是不是存在于数组中 VueTypes.oneOfType(array) 验证prop的值的类型是不是存在于数组 VueTypes.arrayOf(type) 验证某个数组中的值是否都由指定的type组成 VueTypes.objectOf(type) 验证某个对象的所有属性是否都由指定的type组成 VueTypes.shape() 验证prop的值是否包含某个对象的所有属性 可以为每一个属性指定类型，并且用isRequired标志这个属性是否是必须的，但是不能为属性设置默认值 可以使用.def为这个prop设置默认值 默认情况下，不能包含没有定义过的属性，可以使用loose标志来支持 VueTypes.custom(fn, message) 用传入的fn对prop进行验证 可以传入第二个参数message，在验证不通过时，会将message输出到控制台 扩展VueTypes 使用VueTypes.extend(config)进行扩展 config对象可以包含Vue的props中的所有属性，加上： name：string类型，必须 validate：boolean类型，默认为false，如果为true，会有一个类似于原始类型的validate方法 getter: boolean类型，默认为false， 如果为true，则会把定义的name设置为VueTypes的一个属性（类似于VueTypes.string），否则，会设置为VueTypes的一个方法 123456789101112131415161718// as an accessor typeVueTypes.extend(&#123; name: 'negative', getter: true, type: Number, validator: (v) =&gt; v &lt; 0&#125;)const negativeProp = VueTypes.negative// as a configurable methodVueTypes.extend(&#123; name: 'negativeFn', type: Number, validator: (v) =&gt; v &lt; 0&#125;)const negativeProp2 = VueTypes.negativeFn() // &lt;-- we need to call it 如果getter为false，传递给扩展的方法的剩余参数会被传给validator函数，例如： 1234567891011VueTypes.extend(&#123; name: 'maxLength', // getter: false, this is the default type: String, validator: (max, v) =&gt; v.length &lt;= max&#125;)const maxLengthType = VueTypes.maxLength(2)maxLengthType.validator('ab') // truemaxLengthType.validator('abcd') // false 参考文档https://github.com/dwightjack/vue-types","categories":[{"name":"前端库","slug":"前端库","permalink":"http://yoursite.com/categories/前端库/"}],"tags":[]},{"title":"React官方文档笔记","slug":"React官方文档笔记","date":"2019-09-26T11:23:11.000Z","updated":"2019-10-17T03:35:14.211Z","comments":true,"path":"2019/09/26/React官方文档笔记.html","link":"","permalink":"http://yoursite.com/2019/09/26/React官方文档笔记.html","excerpt":"","text":"备注当前笔记基于React v16.8.6 核心概念JSX相关 因为JSX最终会编译成React.createElement的调用形式，所以使用JXS之前必须先引入React 在JSX中允许使用点语法来引用一个组件，例如&lt;MyComponents.DatePicker&gt; React自定义组件必须以大写命名，否则会被认为是一个html标签 props的默认值为true JSX中只支持JavaScript表达式 属性名采用驼峰命名，但arial-*除外 class采用className取代 for采用htmlFor取代 表单组件中，对于后续不需要变化的控件，其值可以使用defualtValue、defaultChecked进行设置 在JSX中，false、null、undefined、true是合法的子元素，但是它们并不会被渲染，这也就是为什么{ showHeader &amp;&amp; &lt;Header /&gt; }可以正常渲染的原因，值得注意的是有一些falsy的值，例如：数值0仍然会被渲染 子元素的传递 props.children，也可以传递一个函数 通过props传递JSX React哲学组件编写顺序 构建简单应用时，使用自上而下的方式进行构建（先编写层级高的组件） 构建复杂应用时，使用自下而上的方式进行构建（先编写最基本的组件） 如何判断数据是否属于state 该数据是否是由父组件通过props传递而来的？如果是，那它应该不是state 该数据是否随时间内的推移而保持不变？如果是，那它应该也不是state 你能否根据其他state或props计算出该数据的值？如果是，那它也不是state 如何确定state放置的位置 找到根据这个state进行渲染的所有组件 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该state的组件） 该共同所有者组件或者比它层级更高的组件应该拥有该state 如果你找不到一个合适的位置来存放该state,就可以直接创建一个新的组件来存放该state，并将这一新组件置于高于共同所有者组件层级的位置 高级指引内置组件 Fragments相当于Vue中的template，不会渲染真实DOM，这在封装组件时将会非常有用 不同于template的地方是循环时，可以为Fragment增加key属性 当你不需要在Fragments标签中添加任何prop且工具支持的情况下，可以使用短语法来代替&lt;&gt;&lt;/&gt; Suspend用于包裹异步组件，可以包裹任意多个，异步组件必须用它包裹，使用fallback属性指定异步组件没有加载完成时的样式 StrictMode包裹的子组件在开发模式会进行一些严格的检查，目前有： 识别不安全的生命周期 关于使用过时字符串ref API的警告 关于使用废弃的findDOMNode方法的警告 检测意外的副作用 DOM操作 通过React.createRef()来获取真实DOM，或则设置ref属性，绑定一个回调方法，接收一个参数为DOM对象的回调方法 12345678910111213141516class CustomTextInput extends React.Component &#123; constructor (props) &#123; super(props); this.textInput = React.createRef() &#125; render () &#123; return ( &lt;input type=\"text\" ref=&#123; this.textInput &#125;/&gt; ) &#125; focus () &#123; this.textInput.current.focus() &#125;&#125; 获取子组件内的真实DOM 父组件利用React.createRef创建ref，然后作为prop传递给子组件，给子组件内的元素设置ref属性 父组件利用React.createRef创建ref，然后设置子组件的ref为创建的ref，然后通过React.forwardRef定义子组件，其接收一个callback（最好使用具名function或者设置function.displayName，这样在react devtools中能够友好显示），通过参数来获取传递给它的ref 123456789const FancyButton = React.forwardRef((props, ref) =&gt; (&lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125;&lt;/button&gt;));// 你可以直接获取 DOM button 的 ref：const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; 当使用第三方库操作DOM时，为了避免冲突，最好使用空的HTML元素，即这个元素既没有属性也没有子元素，例如&lt;div /&gt;，这样React就没有理由去更新它，避免冲突 ref会在componentDidMount或componentDidUpdate生命钩子触发前更新 函数式组件上不能使用ref属性，可以使用React.forwardRef 组件间通信 通过props和callback的方式 通过Context，使用方式如下： 当Provider的value值发生变化时，它内部的所有消费组件都会重新渲染 Provider及其内部的consumer（消费者）组件都不受制于shouldComponentUpdate函数 挂载在class上的contextType属性重赋值为一个由React.createContext()创建的Context对象，这能让你使用this.context来消费最近Context上的那个值 使用Context.Consumer能让函数式组件订阅context，这需要函数作为子元素，因为函数式组件没有实例，不能采用定义Component.contextType的方法，或者采用useContexthook 如果在子组件中想要更新context，可以通过Context.provide的value传递一个函数 为了确保context快速进行重渲染，React需要使每一个consumers组件的context在组件树中成为一个单独的节点，即每个consumer必须包含一个单独节点 123456789&lt;MyContext.Consume&gt; &#123; value =&gt; &#123; return ( &lt;p&gt;&#123; value &#125;&lt;/p&gt; ) &#125; &#125;&lt;/MyContext.Consume&gt; 1234567891011121314151617181920212223242526272829303132333435// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。// 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext = React.createContext('light');class App extends React.Component &#123;render() &#123; // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。 // 无论多深，任何组件都能读取这个值。 // 在这个例子中，我们将 “dark” 作为当前的值传递下去。 return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;&#125;// 中间的组件再也不必指明往下传递 theme 了。function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class ThemedButton extends React.Component &#123; // 指定 contextType 读取当前的 theme context。 // React 会往上找到最近的 theme Provider，然后使用它的值。 // 在这个例子中，当前的 theme 值为 “dark”。 static contextType = ThemeContext; render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;; &#125;&#125; 组件加载 使用React.lazy来动态引入组件，React.lazy目前只支持默认导出，如果需要使用命名导出，可以创建一个中间模块，使用export { xxx as default } from来重新导出为默认模块 123456789const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))function MyComponent() &#123; return ( &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; )&#125; 动态组件 在React中，要实现类似于Vue的component（动态组件）的效果很简单，如下： 123456789101112import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 其它 使用ReactDOM.createPortal(child, container)可以将子节点渲染到存在于父组件以外的DOM节点上，其所有特征与普通的React组件嵌套没有什么不同，包括事件冒泡 Class.defaultProps用于设置props的默认值 错误处理 错误边界组件：使用正常的class组件定义方式，当定义了getDerivedStateFromError()或componentDidCatch()这两个生命周期方法中的任意一个时，那么它就变成了一个错误边界 getDerivedStateFromError：返回一个对象，取代state，在render函数中根据state进行判断是否渲染error UI componentDidCatch: 打印错误信息 只能捕获子组件的错误，无法捕获自身的错误 高阶组件（HOC）高阶组件只是一种设计模式，其表现为：组件作为参数，返回值为新组件的函数 不会修改传入的组件，也不会使用继承来复制其行为 通过将组件包装在容器组件中来组成新组件 被包装组件接收来自容器组件的所有prop 为了方便调试，可以修改HOC的displayName，通常采用的命名方法是HOCName(WrappedComponent) 不要在render方法中使用HOC，它会导致以下几个问题： 每次调用render时，都会使用HOC创建一个新的组件，这将导致子树每次渲染都会进行卸载，和重新挂载的操作 重新挂载将会导致该组件及其所有子组件的状态丢失 当被包裹组件上有静态方法时，使用HOC进行包装之后，新返回的组件并没有这些静态方法，解决这个问题，有以下几种方法 使用hoist-non-react-statics库拷贝组件的静态方法到返回的包装组件上 单独导出组件的静态方法，并在需要使用的时候单独引入它 React原理diffing算法diff步骤： 对比元素类型，如果不同，则销毁组件实例，然后挂载新组件 对比元素的属性，仅对比及更新有改变的属性 注意点： 当一个组件更新时，组件实例保持不变，这就是state在跨越不同的渲染时能保持一致的原因。在更新时，React将更新该组件实例的props，并且调用该实例的componentWillReceiveProps()和componentWillUpdate()方法 当往列表末尾插入元素时，开销较小；但是往开头插入时，每一个元素都必须进行mutate，key可以解决这个问题 React相关库编码相关 react-router redux relay immutable、immer、immutability-helper、seamless-immutable prop-types: props类型检查 hoist-non-react-statics: 静态方法拷贝 react-window/react-virtualized: 虚拟滚动库 webpack相关 @babel/plugin-proposal-class-properties: 可以解决类组件中需要手动调用bind来绑定this的问题，采用箭头函数进行方法的定义 @babel/plugin-proposal-class-properties: 在React类组件中可以通过声明defaultProps作为静态属性","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"React","slug":"框架/React","permalink":"http://yoursite.com/categories/框架/React/"},{"name":"笔记","slug":"框架/React/笔记","permalink":"http://yoursite.com/categories/框架/React/笔记/"}],"tags":[]},{"title":"Element与Component与Instance","slug":"Element与Component与Instance","date":"2019-09-25T08:47:50.000Z","updated":"2019-09-25T09:05:40.285Z","comments":true,"path":"2019/09/25/Element与Component与Instance.html","link":"","permalink":"http://yoursite.com/2019/09/25/Element与Component与Instance.html","excerpt":"","text":"Element其实就是virtual dom，用js对象来描述一个dom节点，它的type类型可以是字符串（HTML Tag Name）、Components、HTML Node，一个Element Tree最终渲染时只能包含HTML Tag Name Components在React中定义组件的方式有很多中： 创建一个Class继承自React.Component 单纯的功能组件，是一个Function，返回一个Element 调用React.createClass Instance实例就是我们创建Class Components时，this的指向，它描述了这个组件相关的一些信息，Function Components是没有实例的，对于存储本地状态和对声明周期时间作出反应很有用 Attention但我们创建一个Element时，使用React.createElement、JSX、element factory helper，不要直接使用plain object Reference https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"React","slug":"框架/React","permalink":"http://yoursite.com/categories/框架/React/"},{"name":"学习笔记","slug":"框架/React/学习笔记","permalink":"http://yoursite.com/categories/框架/React/学习笔记/"}],"tags":[]},{"title":"正向代理、反向代理、透明代理","slug":"正向代理与反向代理与透明代理","date":"2019-09-24T14:56:46.000Z","updated":"2019-09-26T13:13:48.430Z","comments":true,"path":"2019/09/24/正向代理与反向代理与透明代理.html","link":"","permalink":"http://yoursite.com/2019/09/24/正向代理与反向代理与透明代理.html","excerpt":"","text":"正向代理什么是正向代理正向代理是当客户端获取源服务器的内容时，通过携带上源服务器的域名和端口号访问一个中间服务器，中间服务器接收到需要访问的源服务器域名和端口，然后请求源服务器获取内容，并将内容返回给客户端 正向代理的特点 隐藏了客户端，客户端对于源服务器而言是不可见的 代理了客户端 客户端需要进行一些特别的设置 由客户端决定要访问哪个源服务器，代理服务器只做转发功能 启用了正向代理后，请求头首行会包含请求的整个url，例如请求www.a.com，所以可以据此来判断一个请求是否被代理过 12345// 正向代理GET http://www.a.com/ HTTP/1.1// 非正向代理GET / HTTP/1.1 正向代理的应用 VPN应用，例如Shadowsocks在Mac中的应用，通过设置网络-&gt;网络偏好设置-&gt;高级-&gt;代理-&gt;自动代理-&gt;代理配置文件地址默认为（http://127.0.0.1:8090/proxy.pac），同时选择一个节点（比如日本1之类的，其实就是中间服务器的地址）。配置成功后，当我们访问外网，例如 https://www.google.com/ 或 https://www.facebook.com/ 时，这两个域名被包含在在proxy.pac中的rules数组中，所以会走代理，请求你选择的节点（这里为日本1）服务器，并携带上源服务器的地址（这里为 https://www.google.com/ 或 https://www.facebook.com/），然后节点服务器接收到请求后，获得你要请求的源服务器地址并发送请求，获得内容然后返回给你 手机的代理功能 正向代理的作用 访问某些不可达的服务器，例如VPN、客户端与源服务器中间的某个路由器故障导致访问不了等。 加速访问服务器，这种说法不像以前那么流行了，主要是因为带宽流量的飞速发展。客户端到源服务都是低带宽链路，而客户端到代理服务器、代理服务器到源服务器都是高带宽链路，这样即加快了访问服务器的速度。 Cache作用。第一次访问某资源时代理服务器将资源缓存到本地，后续再次访问直接返回，不用再去请求源服务器（PS: 这不是nginx的实现原理，nginx采用的是反向代理机制）。 客户端访问授权。代理服务器进行权限过滤，允许符合权限的客户端访问源服务器，否则访问源服务器时，丢弃数据包。 隐藏客户端 反向代理什么是反向代理反向代理是客户端访问某一服务器时，这个服务器判断将请求转发到何处，并将获得的内容返回给客户端 反向代理的特点 隐藏了源服务器，源服务器对于客户端是不可见的，对于客户端而言，代理服务器就相对于源服务器 代理了服务器 客户端不需要进行设置 由代理服务器决定访问哪个源服务器 反向代理的应用 保护和隐藏原始服务器，例如源服务器的防火墙只允许代理服务器Z进行访问，客户端只能通过访问代理服务器Z来获取源服务器的资源，并不知道源服务器的地址 负载均衡，当反向代理服务器不只一个时，我们可以把它们做成集群，当更多的用户访问源服务器时，让不同的代理服务器去应答不同的用户，然后发送不同用户需要的资源（CDN技术的核心） 负载均衡和CDN的区别 CDN是由多个反向可缓存的代理服务器组成，源服务器就一个，通过DNS解析成不同反向可缓存的代理服务器的IP来实现 负载均衡只有一个反向代理服务器，源服务器有多个，DNS解析成反向代理服务器的IP，只有一个 单机：所有功能部署在一台服务器上 集群：有多台服务器，每台服务器都部署了所有功能，通过nginx反向代理实现负载均衡 分布式：有多台服务器，对功能进行划分成不同的子系统，部署在不同的服务器上，每台服务器负责不同的功能，每个子系统就被称为服务。这些子系统能够运行在web容器中，它们之间通过RPC方式通信 透明代理透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 如何区分正向代理和反向代理主要区别： 客户端是否需要进行配置 正向代理： 客户端需要配置代理服务器的地址和端口，客户端拦截原请求，转发到代理服务器，并带上原请求的地址和端口，代理服务器取得请求携带的原地址和端口，可以直接把请求转发到原服务器或者进行配置，转发到其它服务器，例如VPN。 反向代理： 客户端请求代理服务器，服务器进行配置，根据请求内容转发到不同的源服务器，并将内容返回给客户端，例如nginx负载均衡","categories":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"正向代理","slug":"正向代理","permalink":"http://yoursite.com/tags/正向代理/"},{"name":"反向代理","slug":"反向代理","permalink":"http://yoursite.com/tags/反向代理/"},{"name":"透明代理","slug":"透明代理","permalink":"http://yoursite.com/tags/透明代理/"}]},{"title":"npm之简介","slug":"npm之简介","date":"2019-09-20T03:50:46.000Z","updated":"2019-09-24T14:55:54.898Z","comments":true,"path":"2019/09/20/npm之简介.html","link":"","permalink":"http://yoursite.com/2019/09/20/npm之简介.html","excerpt":"","text":"什么是npmnpm是世界上最大的软件注册表。js包管理工具，包的结构能够使我们轻松的跟踪依赖项和版本。 npm由三部分组成： 网站：开发者查找包，设置参数以及管理npm使用体验的主要途径 注册表：是一个巨大的数据库，保存了每个包的信息 CLI：通过命令行或终端运行 如何安装npm&amp;管理npm版本安装npm：NodeJs官网进行下载安装 管理npm版本：使用nvm进行npm多版本管理 更新npm 123npm -v // 显示当前npm版本npm install npm@latest -g // 安装官方最新测试版本npm install npm@next -g // 安装即将发布的最新版本 Semver介绍Semver全称Semantic versioning（语义化版本），其作用是当开发者依赖某个包时，当包更新时，开发者能通过Semver明确这次更新的程度与影响范围，并在必要时更改他们的代码来适配新的版本。 npm使用语义化控制版本，我们可安装一定版本范围内的npm包，npm会选择和你指定的版本相匹配的latest（最新版本）安装。 规则npm的版本号由三部分组成，变更不同的版本号代表不同的意义： 主版本号（major） 次版本号（minor） 补丁版本号（patch） 更改内容 阶段 规则 示例 第一次发布 New Product 把1.0.0作为起始版本 1.0.0 向后兼容的Bug修复或极小的改动 Patch release patch版本+1 1.0.1 向后兼容的新功能 Minor release minor版本+1 1.1.0 不向后兼容的更改 Major release major版本+1 2.0.0 有时候为了表达更确切的版本，还会在版本号后面添加标签或者扩展，来说明是预发布版本或者测试版本等，例如：2.0.2-beta-3。 常见的标签有： 标签 意义 说明 demo demo版本 可能用于验证问题的版本 dev 开发版 开发阶段使用，bug多，体积较大等特点，功能不完善 alpha α版本 用于内部交流或者测试人员测试，bug较多 beta 测试版本（β版本） 较α版本，有较大的改进，但是还是有bug gamma 伽马版本（γ版本） 较α和β版本有很大的改进，与稳定版相差无几，用户可使用 trial 试用版本 本软件通常都有时间限制，过期之后用户如果希望继续使用，一般得交纳一定的费用进行注册或购买。有些试用版软件还在功能上做了一定的限制。 stable 稳定版本 csp 内容安全版本 js库常用 限制安装包的版本在package.json中可以通过一些符号来限制包只能更新到某个版本 Patch release: 1.0 or 1.0.x or ~1.0.x 安装包的方式安装包有两种方式：本地安装和全局安装，采用何种安装方式取决于要如何使用这个包： 如果你自己的模块依赖于某个包，并且通过NodeJs的require加载，那么你应该选择本地安装这个包，这也是npm install命令的默认行为 如果你想将包作为一个命令行工具，比如grunt CLI，那么你应该选择全局安装 本地包全局包","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"}],"tags":[]},{"title":"微信小程序之webview常见问题","slug":"微信小程序之webview常见问题","date":"2019-08-28T08:55:48.000Z","updated":"2019-09-20T09:50:11.107Z","comments":true,"path":"2019/08/28/微信小程序之webview常见问题.html","link":"","permalink":"http://yoursite.com/2019/08/28/微信小程序之webview常见问题.html","excerpt":"","text":"参考资料官方汇总链接 微信小程序内嵌网页的一些（最佳）实践 特点 web-view 不支持推送服务通知（或称模板消息) webview 里面的网页不能调用JSSDK进行微信支付，需要小程序原生页面通过小程序的支付api进行支付 web-view 跟小程序是独立的两个环境，数据完全不通，包括 cookie、session、localStorage 等等； 但小程序内嵌 web-view 跟微信内置浏览器是一套环境，也就是说你在 web-view 里面留下的以上痕迹，到微信里内置浏览器打开也有； 在两种环境下，不太容易区分到底是什么环境，小程序官方给的判断方法是 window.__wxjs_environment === ‘miniprogram’，但是在 web-view 进入第二页时候，安卓机下这个变量就 undefined 了。 常见错误 打开的域名没有在小程序管理后台设置业务域名(注意是业务域名，不是服务器域名)； 打开的页面 302 过去的地址也必须设置过业务域名； 页面可以包含 iframe，但是 iframe 的地址必须为业务域名； 打开的页面必须为 https 服务； 开发者自己检查自己的 https 服务是否正常，测试方法：普通浏览器打开对应的地址； iOS上传图片问题 iOS小程序webview内input选择文件崩溃 webview postmessage 给小程序，data对应的值必须是个对象，不能是字符串https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0000429a4004205ecf96ea80c51004&amp;highline=web-view&amp;comment_lvl=1，如下图","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"},{"name":"常见问题","slug":"微信小程序/常见问题","permalink":"http://yoursite.com/categories/微信小程序/常见问题/"}],"tags":[]},{"title":"H5上传图片","slug":"H5上传图片","date":"2019-08-28T08:36:26.000Z","updated":"2019-08-28T09:11:59.581Z","comments":true,"path":"2019/08/28/H5上传图片.html","link":"","permalink":"http://yoursite.com/2019/08/28/H5上传图片.html","excerpt":"","text":"流程图 问题&amp;解决方案如何区分环境通过 User Agent 来区分。 UA 中含有 MicroMessage 表明为微信环境。UA 中或者 cookie 中含有 cdvsupport 表明为 APP 环境。UA 匹配/(i[^;]+;( U;)? CPU.+Mac OS X/ 表明是 IOS 环境。 在图片上传，压缩，裁剪，上传中应用到了哪些对象及哪些方法File 对象 h5 文件上传后的对象， 也是作为最终通过 FormData 上传的对象。HTMLImageElement 通过 new Image 创建， 可以获取上传图片的宽高。 HTMLCanvasElemen 对象 用于图片压缩，通过 toBlob 获取 blob 对象 和 canvas.toDataURL 方法获取 dataurl 图片如何实现压缩的将图片转化成 canvas 对象，利用 canvas.toBlob 和 canvas.toDataURL 的压缩参数来进行压缩。 因而上传的图片需要先转化成 canvas。 在微信内部调用 h5 方法需要哪些提前的准备工作和注意事项微信分享微信公众号开发相关 在这个过程中运用了哪些第三方库，是干什么用的 exifjs http://code.ciaoca.com/javascript/exif-js 获取图片的 Orientation 属性（拍摄方向） Tip: exif 的获取 Orientation 的渊源 swiper https://www.swiper.com.cn/usage/index.html 图片预览 touch.js https://allcky.github.io/touchjs/ 在裁剪图片时，支持用户缩放，移动图片 toBlob.js https://github.com/eligrey/canvas-toBlob.js/ 解决 canvas.toBlob 的浏览器支持问题 注意事项 小程序内嵌 h5 页面，如果使用原生 input 上传，在 IOS10 及以下会奔溃。因而，需要在微信小程序环境下，调用微信提供的原生 API。 在 APP 中，使用原生的 input 在安卓设备下无法调起摄像头。可以考虑原生 APP 提供的拍照和相册功能。 input 的 capture&amp;multiple 属性测试1234567891011// 无capture,无multiple&lt;input type=\"file\" accept=\"image/*\" /&gt;// 无capture,有multiple&lt;input type=\"file\" accept=\"image/*\" multiple=\"\" /&gt;// capture=\"camera\",无multiple&lt;input type=\"file\" accept=\"image/*\" capture=\"camera\" /&gt;// capture=\"camera\",有multiple&lt;input type=\"file\" accept=\"image/*\" capture=\"camera\" multiple=\"\" /&gt; 分别在 IOS 微信，IOS 非微信（Safari、QQ 浏览器）、Android 微信、Android 非微信（UC、原生）下进行实验 测试结果 无 capture,无 multiple capture=”camera”,无 multiple 无 capture,有 multiple capture=”camera”,有 multiple Android 微信 正常（单选） 仅相机 仅文件 正常 Android 非微信 正常（单选） 仅相机 正常（单选） 仅相机 IOS 微信 正常（单选） 仅相机 正常（多选） 仅相机 IOS 非微信 正常（单选） 仅相机 正常（多选） 仅相机 结论 input[type=”file”]在不同环境下的表现形式不仅和 capture 属性有关，还和 multiple 有关 安卓系统下，无论是否加 multiple 属性，只能单选图片 无 capture、无 multiple 属性时，各种环境下表现正常且一致。因此若需求不要求多选图片，则可放心使用 &lt;input type=”file” accept=”image/*“&gt; 在进行开发时，大家要根据具体需求选择不同的兼容方案","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"解决方案","slug":"移动端开发/解决方案","permalink":"http://yoursite.com/categories/移动端开发/解决方案/"}],"tags":[]},{"title":"页面返回刷新方案","slug":"页面返回刷新方案","date":"2019-08-28T08:16:54.000Z","updated":"2019-08-28T08:27:33.475Z","comments":true,"path":"2019/08/28/页面返回刷新方案.html","link":"","permalink":"http://yoursite.com/2019/08/28/页面返回刷新方案.html","excerpt":"","text":"背景需求中经常会遇到需要两个页面之间做联动的情况，比如： 一、从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列表页时，因为通用地址做了更改，需要列表页进行刷新重新获取列表项的操作； 二、从订单详情页点击评价进入到评价页面，当评价页面提交评价成功后，需要跳回到订单详情页，这时需要订单详情页展示评价的内容； 如果不用单页应用的方式实现，而只用两个不同页面 A 和 B 实现的话，以目前的方法，无论采取哪种，都会造成体验上的缺失： A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，再通过 a 标签或 location.href 的方式打开一个新的 A 页面。这种情况会在 history 存在 3 个记录，用户从新的 A 页面点击返回按钮时，会从新的 A 页面 →B 页面 → 旧的 A 页面；A 页面通过 a 标签或 location.href 的方式打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：history 会存在 2 个记录，用户从新的 A 页面点击返回时，会从新的 A 页面 → 旧的 A 页面，虽然看不到 B 页面（地址选择页、评价输入页等），但还是会返回到旧的 A 页面，也会造成用户的困惑；而且在 android 到家 webview 中，replace 仍然会保留之前页面的 history；A 页面直接通过 location.replace 打开 B 页面，B 页面操作成功后，用 location.replace 的方式打开新的 A 页面。缺点：虽然只有一条记录，在新的 A 页面可以直接返回 A 页面的来源页，但由于 B 页面是 replace A 页面的，当用户不想操作 B 页面而只想返回到 A 页面时，A 页面已经丢失了，会返回到 A 页面的来源页；且同样存在 android 到家 webview 中 replace 的问题；更好的方法是（如果不用单页面应用），从 A 页面正常打开 B 页面（a 标签或 location.href），当在 B 页面操作成功后，直接返回到 A 页面(histroty.back()/history.go(-1)/点击回退按钮)。但这时往往由于浏览器强大的缓存能力，展现的是缓存的旧的 A 页面，与我们预想的展示新的 A 页面不符。 这时我们想到的，就是让 A 页面在监听到 B 页面的返回时，可以进行刷新操作。 解决方案用以下三个方法的结合，可以解决大部分机型缓存页面的问题。 pageshow在 A 页面用监听 pageshow 事件，当浏览器从 B 页面返回时，会执行 pageshow 的回调，我们在事件中使用 location.reload()方法刷新 A 页面。网上的方案还会加上 pagehide 方法，以防 pageshow 不成功的情况，但在调研时发现只要支持 pagehide 的浏览器都支持会支持 pageshow，所以暂时用 pageshow 就可以搞定了。 12345window.addEventListener('pageshow', function(evt) &#123; if (evt.persisted) &#123; location.reload(true) &#125;&#125;) 支持的浏览器： iOS：微信、safari、Chrome、Firefox、Yandex Android：QQ 浏览器、Firefox、UC、手机百度 这些浏览器中的 A 页面会完全地缓存下来，时刻监听 pageshow/pagehide，当从 B 返回到 A 页面时，不会重新请求 html 文档，也不会重新执行 js。（参见 bfcache） 借助前页面重新执行 js 的方法对比 html 文档版本号有些浏览器不支持 pageshow/pagehide，但这些浏览器大部分都会在 A 页面重新被展示时，虽然不会拉取 html 文档，但是会重新执行一遍 A 页面的 js。这时我们可以借助重新执行 js 的机会，比较文档版本号（我们自己定义的），然后在判断是否是旧的 A 页面时，reload 页面。 具体操作： 给每个需要后退刷新的页面上加一个 hidden input，存储页面在服务端的生成时间【需要后端支持】，作为页面的服务端版本号。 并附加一段 JS 读取读取页面的版本号，同时也记录在浏览器/webview 本地（cookie/localStorage/sessionStorage）进行存储，作为本地版本号。 JS 检查页面的服务端版本号和本地存储中的版本号，如果服务端版本号大于本地存储中版本号，说明页面是从服务端重新生成的；否则页面就是本地缓存的，即发生了后退行为。 JS 在监测到后退时，强制页面重新从服务端获取。 123456789101112var SERVER_TIME = document.getElementById('SERVER_TIME')var REMOTE_VER = SERVER_TIME &amp;&amp; SERVER_TIME.valueif (REMOTE_VER) &#123; var LOCAL_VER = sessionStorage &amp;&amp; sessionStorage.PAGEVERSION if (LOCAL_VER &amp;&amp; parseInt(LOCAL_VER) &gt;= parseInt(REMOTE_VER)) &#123; //说明html是从本地缓存中读取的 location.reload(true) &#125; else &#123; //说明html是从server端重新生成的，更新LOCAL_VER sessionStorage.PAGEVERSION = REMOTE_VER &#125;&#125; 支持的浏览器： iOS：UC、手机百度 Android：微信、Chrome、Yandex Page Visibility API通过以上两种方法的结合，可以覆盖到大部分浏览器。但有一些浏览器在 A 页面打开 B 页面的过程中，像是开了一个新的 Webview 来展示 B 页面的（小米自带浏览器尤其明显，虽然用户看到的还是同一个 Tab），不会触发方法一和方法二。这时可以借助与浏览器 Tab 相关的 Page Visibility API，含义大概为当用户最小化页面或者切换到另一个 Tab 时，将触发 visibilitychange 方法，并可以通过判断此时页面展示相关的属性（document.hidden 、document.visibilityState）来确定页面的显示状态。 于是当浏览器疑似用新开 Webview 的方式做页面 A 到页面 B 的转跳时（再次强调，用户看到的还是同一个 Tab），页面 A 可以通过对 visibilitychange 事件，实现对返回的监听。 注：由于 visibilitychange 事件监听的是 Tab 之间的切换，所以当用户的浏览器打开了其它的 Tab，并与页面 A 所处的 Tab 间来回切换时，或者切换到其它的 APP 又回到浏览器时，同理也会触发我们的监听事件。这时如果不做特殊处理，也会导致页面 A 的刷新。（可以在页面 A 转跳到页面 B 时记录一个字段在本地存储，并在 visibilitychange 中通过此字段判断是否是 AB 之间的转跳） 123456789function handleVisibilityChange() &#123; if (document.hidden) &#123; // tab hidden &#125; else &#123; // tab show location.reload(true) &#125;&#125;document.addEventListener('visibilitychange', handleVisibilityChange, false) 支持的浏览器： iOS：QQ 浏览器 Android：小米自带浏览器 总结在调研的过程中，通过以上三个方法的结合，可以解决所有 Android&amp;iOS 浏览器。可能还有没试到的浏览器会有不支持的情况，发现后会及时更新。 以上为页面返回刷新方案的调研结果，有了对页面返回动作的监听，除了单纯地对缓存页面进行刷新，也可以结合需求做其它的操作。 三种方法的浏览器兼容情况： 方案 IOS Android 说明 pageshow/pagehide 微信、safari、Chrome、Firefox、Yandex QQ 浏览器、Firefox、UC、手机百度 回退后不重新请求 html，不重新执行 js 重新执行 js 对比 Html 文档版本号 UC、手机百度 微信、Chrome、Yandex 回退后不重新请求 html，重新执行 js Page Visibility API QQ 浏览器 小米自带浏览器 回退后不重新请求 html，不重新执行 js 三种方法都不支持的情况 - - - 调研使用手机： iOS: iPhone 7 Plus Android: 红米 4","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"问题积累","slug":"移动端开发/问题积累","permalink":"http://yoursite.com/categories/移动端开发/问题积累/"}],"tags":[]},{"title":"微信小程序之清除webview缓存","slug":"微信小程序之清除webview缓存","date":"2019-08-27T10:48:57.000Z","updated":"2019-08-28T08:17:05.411Z","comments":true,"path":"2019/08/27/微信小程序之清除webview缓存.html","link":"","permalink":"http://yoursite.com/2019/08/27/微信小程序之清除webview缓存.html","excerpt":"","text":"小程序 微信-清理微信存储空间方法（iOS）依次打开微信：我－设置 - 通用－存储空间 －清理微信缓存，就可以清理掉 webview 的缓存（实践表明：这种方法清理效果不好，经常清不掉） Android清理方法 在任意聊天窗口发送： http://debugx5.qq.com （必须手机端微信窗口访问），打开这个网址，找到清理缓存，点击即可（当然还有其他功能可以使用哦）。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"},{"name":"常见问题","slug":"微信小程序/常见问题","permalink":"http://yoursite.com/categories/微信小程序/常见问题/"}],"tags":[]},{"title":"微信小程序之文档笔记","slug":"微信小程序之文档笔记","date":"2019-07-29T09:31:42.000Z","updated":"2019-08-27T10:48:12.795Z","comments":true,"path":"2019/07/29/微信小程序之文档笔记.html","link":"","permalink":"http://yoursite.com/2019/07/29/微信小程序之文档笔记.html","excerpt":"","text":"小程序简介小程序的由来Web 应用存在的问题： 即使微信 Web 资源离线存储技术能够解决一些问题，但对于一些复杂的页面仍有白屏问题，例如页面加载了大量的js和css文件 页面切换的生硬和点击的迟滞感 ​ 微信面临的问题是如何设计一个比较好的系统，使得所有开发者在微信中都能获得比较好的体验。这个问题是之前的 JS-SDK 所处理不了的，需要一个全新的系统来完成，它需要使得所有的开发者都能做到： 快速的加载 更强大的能力 原生的体验 易用且安全的微信数据开发 高效和简单的开发 小程序与普通网页开发的区别 web 中渲染线程和脚本线程是互斥的，而小程序采用的双线程 小程序中不能使用DOM API和BOM API 不用面对各式各样的浏览器，只需要面对 ios、android 的微信客户端，以及用于辅助开发的小程序开发者工具 | 运行环境 | 逻辑层 | 渲染层 | | IOS | JavaScriptCore | WKWebview | | Android | V8 | chromium 定制内核 | |开发者工具| NWJS | Chrome Webview | 常见问题WXSS选择器 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。 子元素选择器（.a&gt;.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。 继承样式，如 font 、 color ，会从组件外继承到组件内。 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"},{"name":"文档笔记","slug":"微信小程序/文档笔记","permalink":"http://yoursite.com/categories/微信小程序/文档笔记/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"微信小程序之生成二维码","slug":"微信小程序之生成二维码","date":"2019-07-08T08:22:50.000Z","updated":"2019-07-09T08:56:04.472Z","comments":true,"path":"2019/07/08/微信小程序之生成二维码.html","link":"","permalink":"http://yoursite.com/2019/07/08/微信小程序之生成二维码.html","excerpt":"","text":"背景微信小程序根据url生成一个带logo的二维码 weapp-qrcode使用weapp-qrcodelib生成二维码 遇到的问题 drawQrcode方法要求传入px，如果页面布局使用的是rpx，需要动态进行转换 绘制二维码时使用到了canvas标签，而canvas标签是原生组件，层级高于普通标签，导致toast提示弹窗被canvas遮挡，于是把canvas隐藏到屏幕外，使用image标签配合wx.canvasToTempFilePath方法实现 要在二维码中绘制图片，使用的是CanvasContext.drawImage方法，但是此方法的图片来源必须是本地图片，所以需要先调用wx.getImageInfo或wx.downloadFile把图片下载到本地，然后用本地图片的路径进行绘制","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"},{"name":"问题积累","slug":"微信小程序/问题积累","permalink":"http://yoursite.com/categories/微信小程序/问题积累/"},{"name":"生成二维码","slug":"微信小程序/问题积累/生成二维码","permalink":"http://yoursite.com/categories/微信小程序/问题积累/生成二维码/"}],"tags":[]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2019-06-25T03:30:32.000Z","updated":"2019-06-25T12:40:29.449Z","comments":true,"path":"2019/06/25/字符串的扩展.html","link":"","permalink":"http://yoursite.com/2019/06/25/字符串的扩展.html","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"},{"name":"ES6","slug":"编程语言/JavaScript/ES6","permalink":"http://yoursite.com/categories/编程语言/JavaScript/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"解构赋值","slug":"解构赋值","date":"2019-06-24T13:03:32.000Z","updated":"2019-06-25T03:30:15.577Z","comments":true,"path":"2019/06/24/解构赋值.html","link":"","permalink":"http://yoursite.com/2019/06/24/解构赋值.html","excerpt":"","text":"数组的解构赋值 如果等号的右边（或隐式转为对象后）不是可遍历的解构（Iterator），那么将会报错。 只有当一个数组成员严格等于（===）undefined时，默认值才会生效。 对象的解构赋值 对象的解构赋值可以取到继承的属性。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 如果等号右边是字符串、数字、布尔值，则会隐式的转为对象。因为undefined和null无法转为对象，所以会报错。 不能使用圆括号的情况 变量声明语句 函数参数 赋值语句的模式 能使用圆括号的情况 赋值语句的非模式部分","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"},{"name":"ES6","slug":"编程语言/JavaScript/ES6","permalink":"http://yoursite.com/categories/编程语言/JavaScript/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"let和const命令","slug":"let和const命令","date":"2019-06-24T12:01:17.000Z","updated":"2019-06-24T13:04:02.706Z","comments":true,"path":"2019/06/24/let和const命令.html","link":"","permalink":"http://yoursite.com/2019/06/24/let和const命令.html","excerpt":"","text":"let 只在块级作用域内有效。 不存在变量提升。 暂时性死区，只要块级作用域内存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错（无论父级作用域是否定义了这些变量），这意味着typeof不再是一个百分百的安全操作。 不允许重复声明同一个变量。 for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 块级作用域 ES5 规定函数只能在顶层作用域和函数作用域进行声明，不能再块级作用域中进行声明，但是浏览器为了兼容以前的旧代码，并没有遵守这个规范。 ES6 明确规定允许在块级作用域中声明函数。 ES5 中，函数的整条声明语句会被提升到函数头部或顶级作用域头部 ES6 的浏览器函数声明的限制（其他环境的实现不用遵守，还是将块级作用域中的函数声明当作let处理）： 允许在块级作用域内声明函数 函数声明类似于var，会提升到全局作用域或函数作用域的头部 同时，函数声明还会提升到块级作用域的头部 考虑到环境的行为差异太大，不建议在块级作用域内进行函数声明，如果要使用，最好使用函数表达式。 ES6 的块级作用域必须有大括号，如果没有大括号，JS引擎就认为不存在块级作用域。 const const声明一个常量，一旦声明，常量的值不允许改变。单对于复合类型数据（例如对象，数组），其只能保证指向内存地址的指针不改变，无法保证其数据结构不变。可以使用Object.freeze进行冻结（只能冻结改对象的属性，如果其属性是一个对象，只能保证指针不变，无法保证子对象的属性不变）。 必须立即初始化。 只在块级作用域内有效。 不存在变量提升。 暂时性死区。 不允许重复声明。 ES6 声明变量的六种方法 var function let const import class 顶层对象属性 var和function命令声明的全局变量，依旧是顶层对象的属性。 let、const、class命令声明的全局变量，不属于顶层对象的属性。 globalThis 对象 不同环境中指向顶层对象的变量不同 浏览器：self 和 this Web Worker：self Node: global 全局环境中，this返回的是顶层对象。但是，在ES6模块和Node模块中，this返回的是当前模块。 函数里面的 this，如果函数不是作为对象的方法允许，而是单纯作为函数允许，this会指向顶层对象。但是，在严格模式下，this会返回undefined。 不管是在严格模式还是普通模式，new Function(&#39;return this&#39;)()总是返回全局对象。但是，如果浏览器使用了 CSP（Content Security Policy，内容安全策略），那么eval，new Function这些方法可能无法使用。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"},{"name":"ES6","slug":"编程语言/JavaScript/ES6","permalink":"http://yoursite.com/categories/编程语言/JavaScript/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"面试之Web其它","slug":"面试之Web其它","date":"2019-05-06T14:44:43.000Z","updated":"2019-05-06T15:39:19.348Z","comments":true,"path":"2019/05/06/面试之Web其它.html","link":"","permalink":"http://yoursite.com/2019/05/06/面试之Web其它.html","excerpt":"","text":"SEO什么是SEOSEO（Search Engine Optimization），中文译为“搜索引擎优化”，是一种透过了解搜索引擎的运作规则来调整网站，以提高目的网站在有关搜索引擎内的自然排名的方式。 SEO的分类 白帽SEO：改良和规范网页的设计，使其对搜索引擎和用户更加友好，是一种搜索引擎推荐的做法。 黑帽SEO：利用或者放大搜索引擎的缺陷，使用不正当的手段提高目的网站在搜索引擎的排名。 SEO的主要方面白帽SEO： 合理的title、keywords、description 语义化的HTML 重要的HTML尽量放在前面。搜索引擎抓取HTML的顺序是从上到下的，有些搜索引擎的抓取长度有限，保证重要内容一定会被抓取 重要的内容不要用js输出：搜索引擎不会执行js获取内容 减少iframe的使用：搜索引擎不会抓取iframe中的内容 非装饰性的图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 增加与网页内容相关的外链引用 黑帽SEO： 垃圾索引：透过欺骗技术和滥用搜索算法来推销毫不相关、主要以商业为着眼的网页。 斗篷法：用了两版不同的网页来达到最优化的效果。 关键字隐密字：通常是指设置关键字的颜色和网页背景颜色一样，或透过 css hidden attribute （隐密特性） 来达到优化效果。 桥页：通常是用软件自动生成大量包含关键词的网页，然后从这些网页做自动转向到主页。 付费链接：是利用支付费用方式要求其他网站提供链接至自身网站，借此伪装高信任网站来欺骗搜索引擎。 链接农场：是故意在一些低质量，内容跟自己内容无关的网站上获取大量链接，藉以提高排名。 参考链接 维基百科 https://segmentfault.com/a/1190000002994538 会话跟踪什么是会话跟踪会话跟踪技术是用于维持客户端和服务器端通信信息的技术 引入会话跟踪的原因HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户以及维持客户的上下文信息，会话跟踪技术就可以解决这个问题。 Web中会话跟踪的方法有哪些 cookie session url重写：动态生成sessionID拼接在url上 隐藏的表单域 ip地址 参考链接 https://blog.csdn.net/qq_38363396/article/details/78289344 https://blog.csdn.net/qfs_v/article/details/2652119","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"面试之HTTP","slug":"面试之HTTP","date":"2019-05-05T14:28:49.000Z","updated":"2019-07-09T11:48:05.111Z","comments":true,"path":"2019/05/05/面试之HTTP.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之HTTP.html","excerpt":"","text":"HTTPHTTP Method 一台服务器要与HTTP 1.1兼容、只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源 HEAD与GET类似，但服务器在响应中只返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链 DELETE请求服务器删除请求URL指定的资源 从浏览器地址输入URL到显示页面的步骤 在浏览器地址中输入URL 浏览器查看缓存，如果请求资源在缓存中并且没有过期，跳转到15 如果资源未缓存，发起新请求 如果已缓存，检验是否过期，没有过期直接提供给客户端，否则与服务器进行验证。 检验资源是否过期通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存过期日期 HTTP1.1增加了Cache-Control: max-age=，值为以秒为单位的最大过期时间 浏览器解析URL获取协议、主机、端口、path 浏览器组装一个HTTP请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址、端口建立TCP连接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器返回SYN=1，ACK=X+1,Seq=Y的响应包 客户端发送ACK=Y+1，Seq=Z TCP连接建立后发送HTTP请求 服务器接收请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息，如果验证缓存没过期，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应后，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下 主动方发送Fin=1，Ack=Z，Seq=X报文 被动方发送ACK=X+1，Seq=Z报文 被动方发送Fin=1，ACK=X，Seq=Y报文 主动方发送ACK=Y，Seq=X报文 浏览器检查响应状态码：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML，构建DOM树，下载资源，构建CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树 Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树 Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树 从DOM树的根节点遍历所有可见节点，不可见的节点包括 script、meta这样本身不可见的标签 被CSS隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册时间处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到了设置async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readyState变成interactive 所有defer脚本会按照在文档中出现的顺序执行，延迟脚本能访问完整DOM树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件 显示页面（HTML解析过程中会逐步显示页面）","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[]},{"title":"面试之Web安全","slug":"面试之Web安全","date":"2019-05-05T14:28:31.000Z","updated":"2019-05-05T14:28:31.334Z","comments":true,"path":"2019/05/05/面试之Web安全.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之Web安全.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试之Web性能","slug":"面试之Web性能","date":"2019-05-05T14:28:15.000Z","updated":"2019-05-05T14:28:15.672Z","comments":true,"path":"2019/05/05/面试之Web性能.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之Web性能.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试之Webpack","slug":"面试之Webpack","date":"2019-05-05T14:28:00.000Z","updated":"2019-05-05T14:28:00.846Z","comments":true,"path":"2019/05/05/面试之Webpack.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之Webpack.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试之Vue","slug":"面试之Vue","date":"2019-05-05T14:27:49.000Z","updated":"2019-06-18T13:32:21.128Z","comments":true,"path":"2019/05/05/面试之Vue.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之Vue.html","excerpt":"","text":"定义Vue组件的方式 单文件组件（Single File Component） 字符串模板（String Template） 渲染函数（Render Function） JSX vue-class-component","categories":[],"tags":[]},{"title":"面试之HTML","slug":"面试之HTML","date":"2019-05-05T14:27:30.000Z","updated":"2019-07-03T01:04:51.028Z","comments":true,"path":"2019/05/05/面试之HTML.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之HTML.html","excerpt":"","text":"Web语义化什么是Web语义化web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的class，id，补充未表达的语义 Web语义化的好处 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便于团队项目的可持续运作及维护 doctypedoctype是什么文档类型说明，现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型 doctype的特点 &lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTML版本的指令 &lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写 在HTML4.01中&lt;!doctype&gt;声明指向一个DTD(Document Type Definition，文档类型定义)，由于HTML4.01基于SGML(Standard Generalized Markup Language，标准通用标记语言)，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD 常见的doctype HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; HTML 5: &lt;!doctype html&gt; 参考链接 DTD SGML HTML全局属性有哪些 accesskey:设置快捷键，提供快速访问元素如&lt;a href=&quot;#&quot; accesskey=&quot;a&quot;在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 参考资料 MDN &lt;img&gt;的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。当鼠标滑动到元素上的时候显示。 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 什么是渐进增强渐进增强是指在Web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高宽带用户提供更好的用户体验。核心原则如下： 所有浏览器都必须能访问基本内容 所有浏览器都必须能使用基本功能 所有内容都包含在语义化的标签中 通过外部CSS提供增强的布局 通过非侵入式、外部javascript提供增强功能 end-user web browser preferences are respected","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[]},{"title":"面试之CSS","slug":"面试之CSS","date":"2019-05-05T14:27:17.000Z","updated":"2019-05-05T14:27:17.667Z","comments":true,"path":"2019/05/05/面试之CSS.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之CSS.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试之JavaScript","slug":"面试之JavaScript","date":"2019-05-05T14:27:07.000Z","updated":"2019-05-06T14:45:04.922Z","comments":true,"path":"2019/05/05/面试之JavaScript.html","link":"","permalink":"http://yoursite.com/2019/05/05/面试之JavaScript.html","excerpt":"","text":"##","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"webpack加载动态图片","slug":"webpack加载动态图片","date":"2019-04-22T08:29:06.000Z","updated":"2019-04-22T09:26:36.872Z","comments":true,"path":"2019/04/22/webpack加载动态图片.html","link":"","permalink":"http://yoursite.com/2019/04/22/webpack加载动态图片.html","excerpt":"","text":"背景在基于Webpack的项目中，我们加载图片有以下三种方式： 使用img标签的src属性 使用css的background-image 使用require或者import导入图片模块 以上3中方式配合url-loader和file-loader我们可以很轻易对图片进行处理，例如： 为图片增加hash 处理图片url，为其增加assetsPublicPath，把相对路径转化为绝对路径 然而在一些情况下，我们无可避免的需要利用js来控制加载图片，例如：我们要加载list-1、list-2、...list-10 10张图片，有可能你会这么做： 12 &lt;!-- 在vue中 --&gt;&lt;img v-for=\"index in 10\" :src=\"`../assets/imgs/list-$&#123; index + 1 &#125;.png`\" :key=\"index\"/&gt; 但这么做是存在问题的，webpack构建时采用的是静态分析，它不会导入包含变量的文件并对其进行解析，上面代码将导致如下结果： 打包出来的图片目录根本没有list图片，因为webpack会认为你没有导入这些文件，就不会将其输出到打包目录中 图片链接没有进行hash、assetsPublicPath处理 解决方案针对如上问题，我们有两种解决方案： 将图片放到static目录，不经过webpack处理，采用绝对路径引入，但是这样就无法进行hash处理了，而且对于html放在后端的应用而言，图片的host还需要进行额外处理 动态加载图片，如下： 123456let imgList = []for (let i = 1; i &lt;= 10; i++) &#123; const img = require(`../assets/imgs/list-$&#123; i &#125;.png`) imgList.push(img)&#125; 这里要注意几个问题，require的参数不能完全为一个变量，需要将其定位到某一个目录内，例如，如下方式都将导致can&#39;t find module： 12345678910111213// 例1 failfunction resolveUrl(filename) &#123; return '../assets/imgs/' + filename&#125;require('list-1.png')// 例2 failconst imgUrl = '../assets/imgs/list-1.png'require(imgUrl)// 例3 failconst path = '../assets/imgs/'require(path + 'list-1.png') 必须在字符串中将其定义到某个具体目录，例如： 123// successconst imgName = 'imgs/list-1.png'require('../assets/' + imgName) 参考文档https://github.com/webpack/webpack/issues/6680","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"},{"name":"Webpack","slug":"打包工具/Webpack","permalink":"http://yoursite.com/categories/打包工具/Webpack/"},{"name":"问题积累","slug":"打包工具/Webpack/问题积累","permalink":"http://yoursite.com/categories/打包工具/Webpack/问题积累/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"loading images","slug":"loading-images","permalink":"http://yoursite.com/tags/loading-images/"}]},{"title":"渲染函数的观察者与进阶的数据响应系统","slug":"渲染函数的观察者与进阶的数据响应系统","date":"2019-04-15T14:41:37.000Z","updated":"2019-05-05T07:14:33.298Z","comments":true,"path":"2019/04/15/渲染函数的观察者与进阶的数据响应系统.html","link":"","permalink":"http://yoursite.com/2019/04/15/渲染函数的观察者与进阶的数据响应系统.html","excerpt":"","text":"本节主要以Vue.prototype._init函数为切入点来详细的讲解Dep和Watcher的作用。我们在上一节揭开数据响应系统的面纱中只是假设的认为dep.depend()收集了依赖，dep.notify()触发了依赖，并没有讲解其具体的实现。除此之外，正是因为Watcher对所观察字段的求值才触发了字段的get，从而才有收集到该观察者的机会。 \\$mount 挂载函数打开src/core/instance/init.js文件，并找到Vue.prototype._init函数，如下所示： Vue.prototype._init1234567891011121314151617181920Vue.prototype._init = function(options?: Object) &#123; // 省略... // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') // 省略... if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125; 上面代码的最后一句，调用vm.$mount方法将组件挂载到固定的元素，而vm.$mount方法分别在两处进行了定义： platforms/web/runtime/index.js，即运行时版Vue的入口文件： 1234Vue.prototype.$mount = function(el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 如果el选项存在且当前处于浏览器环境中，则调用query方法获取el选项对应的DOM元素，如果不存在则手动创建一个div，然后返回DOM元素复写el变量，最后调用mountComponent进行真正的挂载操作 src/platforms/web/entry-runtime-with-compiler.js，即完整版Vue的入口文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const mount = Vue.prototype.$mountVue.prototype.$mount = function(el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn(`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn(`Template element not found or is empty: $&#123;options.template&#125;`, this) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this ) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`vue $&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 完整版的Vue只是在运行版的基础上增加了模板编译的能力（把template或者el选项对应的html模板编译成渲染函数），其主要逻辑为： 如果template选项不存在，则使用el元素的outerHTML作为模板内容 如果template选项存在： 且template的类型是字符串 如果第一个字符是#，那么会把改字符作为css选择符去选中对应的元素，并把该元素的innerHTML作为模板 如果第一个字符不是#，那么什么都不做，就用template自身的字符串作为模板值 且template的类型是元素节点（template.nodeType存在） 则使用该元素的innerHTML作为模板 若template既不是字符串又不是元素节点，那么在非生产环境会提示开发者传递的template选项无效 然后对上述处理后的template选项进行了判断，如果不为空，调用compileToFunctions将字符串编译为渲染函数 渲染函数的观察者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export function mountComponent(vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) &#123; warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) &#125; else &#123; warn('Failed to mount component: template or render function not defined.', vm) &#125; &#125; &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher( vm, updateComponent, noop, &#123; before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */ ) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 首先判断了vm.$options.render函数是否存在，如果不存在，则把createEmptyVNode函数赋给vm.$options.render，其作用是渲染一个空的vnode对象 触发beforeMount生命周期钩子 定义并初始化updateComponent函数，该函数的作用是以vm._render()的返回值作为一个参数调用vm._update函数，第二个参数hydrating是patch算法，这里可以简单的认为vm._render与vm._update的作用如下： vm._render函数的作用是调用vm.$options.render函数并返回生成的虚拟节点（vnode） vm_update函数的作用是把vm._render函数生成的虚拟节点渲染成真实的DOM 实例化Watcher对象 我们知道，正是因为Watcher对表达式的求值，触发了数据属性的get拦截器函数，从而收集到了依赖，当数据变化时能够触发收集的依赖。在上面的Watcher实例中，会对updateComponent函数进行求值，从而间接的触发渲染函数vm.$options.render的执行，而渲染函数的执行会触发数据属性的的get拦截器函数，从而将依赖（观察者）收集，当数据变化时将重新执行updateComponent函数，这就完成了重新渲染。同时我们把上面代码中实例化的观察者对象称为渲染函数的观察者。 初识 Watcher接下来我们就以渲染函数的观察者对象为例，顺着脉络了解Watcher类，Watcher类定义在src/core/observer/watcher.js中，如下是Watcher类的全部内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237let uid = 0/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */export default class Watcher &#123; vm: Component expression: string cb: Function id: number deep: boolean user: boolean lazy: boolean sync: boolean dirty: boolean active: boolean deps: Array&lt;Dep&gt; newDeps: Array&lt;Dep&gt; depIds: SimpleSet newDepIds: SimpleSet before: ?Function getter: Function value: any constructor(vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) &#123; this.vm = vm // 如果是渲染函数的观察者，这赋值给组件实例的_watcher属性，所有每个组件实例的_watcher属性指向的都是该实例的渲染函数的观察者 if (isRenderWatcher) &#123; vm._watcher = this &#125; // 组件实例的_watchers属性包含了该组件实例的所有的观察者 vm._watchers.push(this) // options if (options) &#123; // 用来告诉当前观察者实例对象是否是深度观测 this.deep = !!options.deep // 用来标识当前观察者实例对象是 开发者定义的 还是 内部定义的 this.user = !!options.user // 用来标识当前观察者实例对象是否是计算属性的观察者，惰性求值 === 计算属性的观察者 this.lazy = !!options.lazy // 用来告诉观察者当数据变化时是否同步求值并执行回调 this.sync = !!options.sync // 可以理解为 Watcher 实例的钩子，当数据变化之后，触发更新之前，调用在创建渲染函数的观察者实例对象时传递的 before 选项 this.before = options.before &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; // this.$watch('b.a', function () &#123;&#125;) 此时 expOrFn = 'b.a' // 如果expOrFn 包含字母 . $之外的符号 则 parsePath 返回undefined 否则 // 返回一个新函数 新函数接收一个obj参数 其作用是触发b.a的get拦截器函数 并返回b.a的值 this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop process.env.NODE_ENV !== 'production' &amp;&amp; warn(`Failed watching path: \"$&#123;expOrFn&#125;\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm) &#125; &#125; // this.value 保存着被观察的目标的值 this.value = this.lazy ? undefined : this.get() &#125; /** * 收集依赖&amp;求值 * 触发访问器属性的 get 方法，返回被观察的目标的值 * Evaluate the getter, and re-collect dependencies. */ get() &#123; // 设置 Dep.target 为当前观察者实例 pushTarget(this) let value const vm = this.vm try &#123; // 触发过程 被观察目标的 get 拦截器函数 -&gt; dep.depend() -&gt; Dep.target.addDep(dep) value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; else &#123; throw e &#125; &#125; finally &#123; // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; /** * Add a dependency to this directive. */ addDep(dep: Dep) &#123; const id = dep.id // 避免在 一次求值过程中 重复收集依赖 if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) // 避免在 多次求值过程中 重复收集依赖 if (!this.depIds.has(id)) &#123; // 收集观察者 观察者被添加到 dep.subs 数组中 dep.addSub(this) &#125; &#125; &#125; /** * Clean up for dependency collection. */ cleanupDeps() &#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; // 移除废弃的观察者 dep.removeSub(this) &#125; &#125; // 清空 newDepIds 和 new Deps 并赋给 depIds 和 newDeps let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125; /** * 触发过程 被观察目标的 set 拦截器函数 -&gt; dep.notify() -&gt; 虚幻遍历 dep.subs数组 调用dep.subs[i].update * Subscriber interface. * Will be called when a dependency changes. */ update() &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; // 同步执行 this.run() &#125; else &#123; // 放到异步队列执行 queueWatcher(this) &#125; &#125; /** * Scheduler job interface. * Will be called by the scheduler. */ run() &#123; if (this.active) &#123; // 重新求值 const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; /** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ evaluate() &#123; this.value = this.get() this.dirty = false &#125; /** * Depend on all deps collected by this watcher. */ depend() &#123; let i = this.deps.length while (i--) &#123; this.deps[i].depend() &#125; &#125; /** * Remove self from all dependencies' subscriber list. */ teardown() &#123; if (this.active) &#123; // remove self from vm's watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this) &#125; let i = this.deps.length while (i--) &#123; this.deps[i].removeSub(this) &#125; this.active = false &#125; &#125;&#125; queueWatcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** * Reset the scheduler's state. */function resetSchedulerState() &#123; index = queue.length = activatedChildren.length = 0 has = &#123;&#125; if (process.env.NODE_ENV !== 'production') &#123; circular = &#123;&#125; &#125; waiting = flushing = false&#125;// Async edge case #6566 requires saving the timestamp when event listeners are// attached. However, calling performance.now() has a perf overhead especially// if the page has thousands of event listeners. Instead, we take a timestamp// every time the scheduler flushes and use that for all event listeners// attached during that flush.export let currentFlushTimestamp = 0// Async edge case fix requires storing an event listener's attach timestamp.let getNow: () =&gt; number = Date.now// Determine what event timestamp the browser is using. Annoyingly, the// timestamp can either be hi-res (relative to page load) or low-res// (relative to UNIX epoch), so in order to compare time we have to use the// same timestamp type when saving the flush timestamp.if (inBrowser &amp;&amp; getNow() &gt; document.createEvent('Event').timeStamp) &#123; // if the low-res timestamp which is bigger than the event timestamp // (which is evaluated AFTER) it means the event is using a hi-res timestamp, // and we need to use the hi-res version for event listeners as well. getNow = () =&gt; performance.now()&#125;/** * Flush both queues and run the watchers. */function flushSchedulerQueue() &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn('You may have an infinite update loop ' + (watcher.user ? `in watcher with expression \"$&#123;watcher.expression&#125;\"` : `in a component render function.`), watcher.vm) break &#125; &#125; &#125; // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit('flush') &#125;&#125;function callUpdatedHooks(queue) &#123; let i = queue.length while (i--) &#123; const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'updated') &#125; &#125;&#125;/** * Queue a kept-alive component that was activated during patch. * The queue will be processed after the entire tree has been patched. */export function queueActivatedComponent(vm: Component) &#123; // setting _inactive to false here so that a render function can // rely on checking whether it's in an inactive tree (e.g. router-view) vm._inactive = false activatedChildren.push(vm)&#125;function callActivatedHooks(queue) &#123; for (let i = 0; i &lt; queue.length; i++) &#123; queue[i]._inactive = true activateChildComponent(queue[i], true /* true */) &#125;&#125;/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */export function queueWatcher(watcher: Watcher) &#123; const id = watcher.id // 避免相同的观察者重复入队 if (has[id] == null) &#123; has[id] = true // 判断队列中的事件是否处于执行中 if (!flushing) &#123; // 如果不处于执行中，将 观察者 添加到队列末尾 queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // 只能存在一个异步事件 // queue the flush if (!waiting) &#123; waiting = true if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; nextTick(flushSchedulerQueue) &#125; &#125;&#125; nextTick1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980let timerFunc// The nextTick behavior leverages the microtask queue, which can be accessed// via either native Promise.then or MutationObserver.// MutationObserver has wider support, however it is seriously bugged in// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It// completely stops working after triggering a few times... so, if native// Promise is available, we will use it:/* istanbul ignore next, $flow-disable-line */if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if ( !isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; (isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;export function nextTick(cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"揭开数据响应系统的面纱","slug":"揭开数据响应系统的面纱","date":"2019-04-05T09:01:48.000Z","updated":"2019-04-22T09:26:45.292Z","comments":true,"path":"2019/04/05/揭开数据响应系统的面纱.html","link":"","permalink":"http://yoursite.com/2019/04/05/揭开数据响应系统的面纱.html","excerpt":"","text":"笔记 优先级关系：props &gt; data &gt; methods：即已经在props中定义的key不允许出现在data与methods中，已经在data中定义的key不允许出现在methods中 vm代理了vm._data对象，vm._data对象是通过vm.$options.data()得到的，即访问vm.a等于访问vm._data.a，对应到源码中src/core/instance/state.js中的proxy方法 响应式数据处理本节主要针对src/core/instance/state.js中的initData方法最后一句observe(data, true)的执行逻辑进行说明 observe方法具体的内容如下： 123456789101112131415161718192021export function observe(value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void // 如果value上有__ob__属性且是Observer实例，说明该对象已经被观测 if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ // shouldObserve控制是否允许观测的开关 // isServerRendering 判断是否是服务端渲染 // Array.isArray(value) || isPlainObject(value) 判断是否是数组或纯对象 // Object.isExtensible(value) 判断是否是可扩展的 // !value._isVue 判断是否是Vue实例 &#125; else if (shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; Observer（观察者类）定义如下： 1234567891011121314151617181920212223242526272829303132333435class Observer &#123; value: any // 要观察的对象本身的引用 dep: Dep // 依赖实例，用于收集依赖，为了使Vue.set和Vue.delete能够监听对象和数组属性的添加和删除等 vmCount: number // 除非是根数据，即vm.data，其值大于0，否则等于0 constructor(value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; walk(obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; observeArray(items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; constructor做的事情： 初始化数据：value引用数据对象本身、dep为Dep类的实例（用于Vue.set &amp; Vue.delete实现对象或数组的添加、删除操作）、初始化vmCount的值为 0（如果是根数据在observe函数中对vmCount进行了自加 1，说明只有根数据即vm.data本身的vmCount会大于 0） 往数据对象上添加了__ob__属性，其值为当前Observer实例 判断数据对象是否是数组 如果是数组，判断浏览器是否支持__proto__属性 如果支持，利用原型链，使value.__proto__属性指向arrMethods，arrMethods是用以Array.prototype为原型创建的对象，其对数组的变异方法（即能修改自身值得方法）进行了重写，这样当使用数组的变异方法时，就会查找原型链，查找到arrMethods对象上定义的方法，在这些方法中我们就能进行依赖收集与事件发布 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// src/core/observer/index.jsprotoAugment(value, arrayMethods)function protoAugment (target, src: Object) &#123; target.__proto__ = src&#125;// src/core/observer/array.jsconst arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/*** Intercept mutating methods and emit events*/methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; // inserted的值为往数组中添加的元素，其作用是用于确定当前数组的操作为添加操作，当添加一个新的元素后，要确保对新的元素进行了观测，所以当存在inserted时，调用当前数组的`__ob__`对象的observeArray方法 if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;) // src/core/observer/index.js Observer.observeArray：该方法的作用是循环数组，对数组中的每一项进行观测 observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125;) 如果不支持__proto__方法，则直接把重写的变异数组方法添加到数据对象本身上 1234567891011// src/core/observer/index.jsconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)copyAugment(value, arrayMethods, arrayKeys)function copyAugment(target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 如果不是数组（即对象），则调用Observer的walk方法，遍历对象上的属性，调用defineReactive方法，对每一个属性进行观测 123456walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; defineReactive定义在src/core/observer/index.js中 defineReactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788export function defineReactive(obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() // 获取属性的描述信息 const property = Object.getOwnPropertyDescriptor(obj, key) // 如果该属性是不可配置的，则没必要也无法进行观测，因为要实现观测必须修改属性的`get`和`set`方法 if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 缓存原来的geeter和setter const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set // 首先要明确的一点是，如果if中的代码不执行，那么val的值有可能为undefined，则这时候下方的深度观测语句`let childOb = !shallow &amp;&amp; observe(val)`中的val为undefined，即不会进行深度观测 // !getter &amp;&amp; arguments.length == 2：如果属性本身存在着`getter`函数，在这里是不希望触发用户所写的`getter`函数的，所以当属性本身不存在`getter`函数时，再获取其值，而付出的代价是如果存在`getters`函数不会进行深度观测 // !getter || setter：如果不加setter的判断，当第一次观测之后且是深度观测之后，属性上有了下方代码添加的`getter`函数，这时候将属性值赋予一个新的对象，则时候对象上有`getter`函数，造成的结果就是不会进行深度观测，这跟之前的深度观测是相违背的，所以加上setter是否存在的判断 if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // 进行深度观测，可以把shallow看做一个控制深度观测的开关 let childOb = !shallow &amp;&amp; observe(val) // 依赖收集&amp;事件发布 Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; // 利用闭包，保留对getter的引用，如果存在getter，则调用getter获取其值，否则为val const value = getter ? getter.call(obj) : val // Dep.target为要收集的依赖 if (Dep.target) &#123; // 收集依赖 dep.depend() // 如果子对象也是观测对象 if (childOb) &#123; // 收集依赖，因为当一个事件依赖一个对象后，则相当于这个事件也依赖于其子对象，因为修改了子对象，其父对象也变了，这样当修改子对象是，才能正确的发布事件 childOb.dep.depend() if (Array.isArray(value)) &#123; // 如果是数组，则递归调用dependArray进行依赖收集 dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val // 如果数据没有发生改变，或者之前为NaN改变之后也为NaN（我们都知道NaN !== NaN），则什么都不做 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; // customSetter：允许在非生产环境进行监听时提供一个函数为参数作为拦截，例如不允许修改内置的属性时会提示错误信息 if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return // 如果本身存在setter，则调用本身提供的setter进行赋值 if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 深度观测 childOb = !shallow &amp;&amp; observe(newVal) // 事件发布 dep.notify() &#125; &#125;)&#125;function dependArray(value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125; Vue.set &amp; Vue.delete 的实现Vue.set12345678910111213141516171819202122232425262728293031323334353637383940export function set(target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // 在非生产环境对target的类型进行判断，如果是基本数据类型undefined、Number、String、Boolean、Symblo则不进行处理 if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) &#123; warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`) &#125; // 如果是数组且索引key &gt;= 0 且 是整数 且 isFinite(key)为true if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 将数组的长度修改为 target.length 和 key 中的较大者，否则如果当要设置的元素的索引大于数组长度时 splice 无效 target.length = Math.max(target.length, key) // 利用splice实现数据观测 target.splice(key, 1, val) return val &#125; // 如果是对象，直接改变其值就行，会触发对应的setter方法 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ // 不允许给Vue实例添加属性：为了避免属性覆盖 // 不允许给Vue根数据对象添加属性：根数据对象是永远都触发不了依赖的，原因是因为根数据对象的Observer实例无法收集到依赖（观察者）。如果想要在跟数据上使用Vue.set/Vue.delete触发响应，则data必须是响应式数据才行，这样当 data 字段被依赖时，才能够收集依赖(观察者)到两个“筐”中(data属性自身的 dep以及data.__ob__)。这样在 Vue.set/$set 函数中才有机会触发根数据的响应。但 data 本身并不是响应的，这就是问题所在 if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.') return val &#125; // 如果target原本不是响应的，则直接设置其值 if (!ob) &#123; target[key] = val return val &#125; // 调用defineReactive方法设置属性值，确保新添加的属性是响应式的 defineReactive(ob.value, key, val) // 触发响应 ob.dep.notify() return val&#125; Vue.delete12345678910111213141516171819202122export function del(target: Array&lt;any&gt; | Object, key: any) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) &#123; warn(`Cannot delete reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`) &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1) return &#125; const ob = (target: any).__ob__ if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.') return &#125; if (!hasOwn(target, key)) &#123; return &#125; delete target[key] if (!ob) &#123; return &#125; ob.dep.notify()&#125; 下一章：渲染函数的观察者与进阶的数据响应系统","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue的初始化之开篇","slug":"Vue的初始化之开篇","date":"2019-03-28T05:40:28.000Z","updated":"2019-04-15T09:10:42.595Z","comments":true,"path":"2019/03/28/Vue的初始化之开篇.html","link":"","permalink":"http://yoursite.com/2019/03/28/Vue的初始化之开篇.html","excerpt":"","text":"用于初始化的最终选项\\$options在以一个例子为线索一节中，我们写了一个很简单的例子，这个例子如下： 123456var vm = new Vue(&#123; el: '#app', data: &#123; test: 1 &#125;&#125;) 我们以这个例子为线索开始了对Vue代码的讲解，我们知道了在实例化Vue实例的时候，Vue.prototype._init方法被第一个执行，这个方法定义在src/core/instance/init.js文件中，在分析_init方法的时候我们遇到了下面的代码： 1vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) 正式因为上面的代码，使得我们花了大篇章来讲其内部实现和运作，也就是Vue 选项的规范化和Vue 选项的合并这两节所介绍的内容。现在我们已经知道了mergeOptions函数是如何对父子选项进行合并处理的，也知道了它的作用。 我们打开core/util/options.js文件，找到mergeOptions函数，看其最后一句代码： 1return options 这说明mergeOptions函数最终将合并处理后的选项返回，并以该返回值作为vm.$options的值。vm.$options在Vue的官方文档中是可以找到的，它作为实例属性暴露给开发者，那么现在你应该知道vm.$options到底是什么了。并且看文档的时候你应该更能够理解其作用，比如官方文档是这样介绍$options实例属性的： 用于当前Vue实例的初始化选项。需要在选项中包含自定义属性时会有用处 并且给了一个例子，如下： 123456new Vue(&#123; customOptions: 'foo', created: function() &#123; console.log(this.$options.customOption) &#125;&#125;) 上面的例子中，在创建Vue实例的时候传递了一个自定义选项：customOption,在之后的代码中我们可以通过this.$options.customOption进行访问。原理其实就是使用mergeOptions函数对自定义选项进行合并处理，由于没有指定customOption选项的合并策略，所以将会使用默认的策略函数defaultStrat。最终效果就是你初始化的值是什么，得到的就是什么。 另外，Vue也提供了Vue.config.optionMergeStrategies全局配置，用来指定某一个选项的合并策略，常用于指定自定义选项的合并策略，具体请查看optionMergeStrategies 用法 现在我们回到正题上，还是拿我们的例子，如下： 123456var vm = new Vue(&#123; el: '#app', data: &#123; test: 1 &#125;&#125;) 这个时候mergeOptions函数将会把Vue.options作为父选项，把我们传递的实例选项作为子选项进行合并，合并的结果我们可以通过打印$options属性得知。其实我们前面已经分析过了，el选项将使用默认合并策略合并，最终的值就是字符串#app，而data选项将变成一个函数，且这个函数的执行结果就是合并后的数据，即：{test: 1}。 下面是vm.$options的截图： 我们发现el确实还是原来的值，而data也确实变成了一个函数，并且这个函数就是我们之前遇到过的mergedInstanceDataFn，除此之外我们还能看到其他合并后的选项，其中components、directives、filters以及_base是存在于Vue.options中的，这些是我们所知道的，至于render赫尔staticRenderFns这两个选项是在将模板编译成渲染函数时添加上去的，我们后面会遇到。另外_parentElm和_refElm这两个选项是在为虚拟 DOM 创建组件实例时添加的，我们后面也会降到，这里大家不需要关心，免得失去重点。 渲染函数的作用域代理_init方法中，经过mergeOptions合并处理选项之后，要执行的是下面这段代码： 123456/* istanbul ignore else */if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm)&#125; else &#123; vm._renderProxy = vm&#125; 这段代码的目的是在vm上添加_renderProxy属性，在非生产环境下调用initProxy方法添加，而在生产环境下直接赋值为vm 接下来我们来看initProxy中的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142let initProxyif (process.env.NODE_ENV !== 'production') &#123; // 中间代码省略... const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; isNative(Proxy) // 中间代码省略... const hasHandler = &#123; has(target, key) &#123; const has = key in target const isAllowed = allowedGlobals(key) || (typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data)) if (!has &amp;&amp; !isAllowed) &#123; if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key) &#125; return has || !isAllowed &#125; &#125; const getHandler = &#123; get(target, key) &#123; if (typeof key === 'string' &amp;&amp; !(key in target)) &#123; if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key) &#125; return target[key] &#125; &#125; initProxy = function initProxy(vm) &#123; if (hasProxy) &#123; // determine which proxy handler to use const options = vm.$options const handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler vm._renderProxy = new Proxy(vm, handlers) &#125; else &#123; vm._renderProxy = vm &#125; &#125;&#125; initProxy方法的主要逻辑是： 如果宿主环境支持Proxy方法，使用Proxy方法对vm进行代理，并赋值给vm._renderProxy 如果不满足options.render &amp;&amp; options.render._withStripped条件时，拦截器对象为hasHandler has可以拦截的操作有： 属性查询：foo in proxy 继承属性查询：foo in Object.create(proxy) with检查：with(proxy) { (foo); } Reflect.has() 其中关键点就在于has操作可以拦截with操作，在src/core/instance/render.js文件中，找到Vue.prototype._render方法，里面有这样的代码： 1vnode = render.call(vm._renderProxy, vm.$createElement) 在调用render函数的时候，指定了其执行环境为vm._renderProxy，那么render函数长什么样呢？还是以上面的例子为例，我们可以通过打印vm.$options.render查看，它长成这样： 123456vm.$options.render = function () &#123; // render 函数的 this 指向实例的 _renderProxy with(this)&#123; return _c('div', [_v(_s(a))]) // 在这里访问 a，相当于访问 vm._renderProxy.a &#125;&#125; 我们可以知道with中的this被指定为了vm._renderProxy，所以当我们访问a变量时，就相当于访问vm._renderProxy.a，也正是因为如此，当我们在with语句块中调用一些内置的全局对象是，是不希望被代理到vm._renderProxy，这就是为什么hasHandler中有下面这段代码： 123456const has = key in targetconst isAllowed = allowedGlobals(key) || (typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data))if (!has &amp;&amp; !isAllowed) &#123; if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key)&#125; 上面代码的意思是：如果访问的属性不存在于target(也就是vm)且不是全局对象或者以_开头且不在target.$data上时，是允许被访问的，否则不允许被访问，并给予警告 如果满足时，拦截器对象为getHandler 当render方法存在，即我们构造实例的时候是通过render方法进行模板渲染的时候，且render方法的_withStripped属性为true的时候会使用getHandler，vue-loader提供的单文件组件的能力，其实最终就是把template编译成render方法，并且设置render._withStripped为true，在不使用with语句的render方法中，模板内的变量都是通过属性访问操作vm.a的形式访问的，从前文中我们了解到Proxy的has无法拦截属性访问操作，所以这里需要使用Proxy中可以拦截到属性访问的get，同时也省去了has中的全局变量检查（因为全局变量的访问不会被get拦截） 如果宿主环境不支持Proxy方法，则和生成环境一样，vm._renderProxy的值被设置为vm 初始化之initLifecycle_init函数在执行完initProxy之后，执行的就是initLifecycle函数： 12vm._self = vminitLifecycle(vm) 在initLifecycle函数执行之前，执行了vm.self = vm语句，这句话在Vue实例对象vm上添加了_self属性，指向真实的实例本身。注意vm._self和vm._renderProxy不同，首先在用途上来说寓意是不同的，另外vm._renderProxy有可能是一个代理对象，即Proxy实例。 initLifecycle1234567891011121314151617181920212223242526272829303132export function initLifecycle (vm: Component) &#123; // 定义 options，它是 vm.$options 的引用，后面的代码使用的都是 options 常量 const options = vm.$options // locate first non-abstract parent (查找第一个非抽象的父组件) // 定义 parent，它引用当前实例的父实例 let parent = options.parent // 如果当前实例有父组件，且当前实例不是抽象的 if (parent &amp;&amp; !options.abstract) &#123; // 使用 while 循环查找第一个非抽象的父组件 while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; // 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里 parent.$children.push(vm) &#125; // 设置当前实例的 $parent 属性，指向父级 vm.$parent = parent // 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身 vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; initLifecycle主要做了几件事： 将当前实例添加到父实例（第一个非抽象组件）的$children属性里，并设置当前实例的$parent指向父实例 options.parent来源于Vue的自动侦测父级的功能，实际上，当我们构建Vue实例时传入的components选项，内部会先调用Vue.extend方法，创建compoents对应的子类，然后在实例化子类作为子组件，这是options.parent也就是compoents的parent属性会被初始化为当前构造的实例，这个过程都在虚拟DOM的patch算法中进行的，可以查看src/core/vdom/create-component.js中的createComponentInstanceForVnode方法，它在src/core/vdom/create-component.js文件内的componentVNodeHooks钩子对象的init钩子函数内被调用 抽象组件的特点是：一般不渲染真实DOM，例如Vue内置的组件keep-alive、transition等；不会出现在父子关系的路径上，创建组件实例时，通过设置abstract属性为true，可以将其标记为一个抽象组件，例如src/core/components/keep-alive.js文件 设置当前实例的$root属性为父实例的$root，如果不存在则指向zishen 初始化$children属性为空数组，用于存放子组件，初始化$ref属性为空对象，用于存放设置了ref属性的DOM元素 在实例上设置了一系列供内部使用的变量：_watcher、_inactive、_directInactive、_isMounted、_isDestroyed、_isBeingDestroyed 初始化之initEventsinitEvents123456789export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 往实例上增加了_events、_hasHookEvent属性 判断了vm.$options._parentListeners属性（在src/core/vdom/create-component.js文件中的createComponentInstanceForVnode被初始化）是否存在，如果存在调用updateComponentListeners方法 初始化之initRenderinitRender12345678910111213141516171819202122232425262728293031323334export function initRender (vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true) &#125; else &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) &#125;&#125; 往实例上增加了$vnode、$slots、$scopedSlots属性 往实例上增加了$attrs、$listeners属性，且在非生产环境时处于updateChildComponent函数外（来自于src/core/instance/lifecycle.js）外更改$attrs或$listeners时，给予一个错误提示 声明周期钩子的实现方式在initRender函数执行完毕后，是这样一段代码： 12345callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, 'created') callHook方法用于调用生命周期钩子函数 callHook123456789101112131415161718export function callHook (vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; try &#123; handlers[i].call(vm) &#125; catch (e) &#123; handleError(e, vm, `$&#123;hook&#125; hook`) &#125; &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125; popTarget() &#125; 这里的pushTarge和popTarget是为了避免在某些生命周期中使用props数据导致收集冗余的依赖。调用钩子方法时，使用call方法指定了其执行上下文，即把this指向为vm vm._hasHookEvent是在initEvents函数中定义的，它的作用是判断是否存在生命周期钩子的事件侦听器，初始化值为false代表没有，当组件检测到存在生命周期钩子的事件侦听器时，会将vm._hasHookEvent设置为true，那么什么是生命周期钩子事件侦听器呢？ 123456&lt;child @hook:beforeCreate=\"handleChildBeforeCreate\" @hook:created=\"handleChildCreated\" @hook:mounted=\"handleChildMounted\" @hook:生命周期钩子/&gt; 如上代码可以使用hook:加生命周期钩子名称的方式来监听组件相应的生命周期事件。这是Vue官方文档上没有体现的，但你确实可以这么用，不过除非你对Vue非常了解，否则不建议使用。 initState函数包括了：initProps、initMethods、initData、initComputed、initWatch，所以当beforeCreated钩子被调用时，所有与props、methods、data、computed以及watch相关的内容都不能使用，当然inject/provide也是不可用的。作为对立面，created钩子恰好是等待initInjections、initState、initProvide执行完毕后才被调用的，所以在created钩子中，是完全能够使用上面提到的内容。但由于此时还没有任何的挂载操作，所以在created中是不能够访问DOM的。 Vue初始化之initState12345callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, 'created') 可以看到在initState函数执行之前，先执行了initInjections函数，也就是说inject选项要更早被初始化，不过由于初始化 inject 选项的时候涉及到 defineReactive 函数，并且调用了 toggleObserving 函数操作了用于控制是否应该转换为响应式属性的状态标识 observerState.shouldConvert，所以我们决定先讲解 initState，之后再来讲解 initInjections 和 initProvide，这才是一个合理的顺序，并且从 Vue 的时间线上来看 inject/provide 选项确实是后来才添加的。 initState123456789101112131415export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 往实例上添加了_watchers属性，用于存储所有该组件实例的watcher对象 可以看到props的初始化先于data，这就是为什么我们能够使用props来初始化data的原因 下一篇：揭开数据响应系统的面纱","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue选项的合并","slug":"Vue选项的合并","date":"2019-03-27T05:35:09.000Z","updated":"2019-03-28T05:46:26.186Z","comments":true,"path":"2019/03/27/Vue选项的合并.html","link":"","permalink":"http://yoursite.com/2019/03/27/Vue选项的合并.html","excerpt":"","text":"上一章节我们了解了Vue对选项的规范，接下来才是真正的合并阶段，我们继续看mergeOptions函数的代码，接下来的一段代码如下： 123456789101112131415const options = &#123;&#125;let keyfor (key in parent) &#123; mergeField(key)&#125;for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125;&#125;function mergeField(key) &#123; const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key)&#125;return options 这段代码的作用是，针对不同的选项，例如components、props、data、filters，采取不同的合并策略进行合并，其中strast的声明在本文件顶部进行了声明，初始化为config.optionsMergeStrategies，它的值现在还是一个空对象，在后续的代码中将往上添加各种合并策略函数。如果你要使用自定义合并策略，只需要在Vue.config.optionsMergeStrategies添加与自定义选项同名的函数就行。这就是Vue文档中提过的全局配置：optionMergeStrategies 选项 el、propsData 的合并策略1234567891011/** * Options with restrictions */if (process.env.NODE_ENV !== 'production') &#123; strats.el = strats.propsData = function(parent, child, vm, key) &#123; if (!vm) &#123; warn(`option \"$&#123;key&#125;\" can only be used during instance ` + 'creation with the `new` keyword.') &#125; return defaultStrat(parent, child) &#125;&#125; el、props采用的合并策略是默认的合并策略： 默认合并策略123456/** * Default strategy. */const defaultStrat = function(parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125; 默认合并策略：如果子选项是 undefined，则使用父选项，否则使用子选项 这里有一点需要注意，那就是对vm是否存在进行判断，如果不存在，在非生产环境会给予错误提示，我们都知道当前这个vm是由mergeOptions中的vm传过来的，而mergeOptions的vm来自于_init方法，_init方法是在Vue构造函数中被调用，所以当我们通过new操作符创建Vue实例时，这个vm是一定存在的。那么说明，在某种情况下，vm可能不存在，也就是mergeOptions方法除了在_init方法被调用，还在其它地方也被调用了。这个地方就是src/core/global-api/extend.js中的Vue.extend方法，其中有这么一段代码： 1Sub.options = mergeOptions(Super.options, extendOptions) 可以看到，当我们通过Vue.extend创建子类的时候mergeOptions会被调用，此时策略函数就拿不到第三个参数，所以最终能得到的结论是：如果策略函数中拿不到vm参数，那么处理的就是子组件选项（调用Vue.extend传入的选项参数） 选项 data 的合并策略123456789101112strats.data = function(parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== 'function') &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm) return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125; 如果处理的是子组件选项： 如果 data 不存在或 data 不为一个函数，给予错误提示，并返回父 data。我们都知道为了防止不同组件的共享一个 data，所以子组件的 data 选项必须要为一个返回 object 的函数 否则，调用 mergeDataOrFn 方法，传入父 data 选项、子 data 选项 如果处理的不是子组件选项，调用 mergeDataOrFn 方法，传入父 data 选项、子 data 选项、vm mergeDataFn123456789101112131415161718192021222324252627282930313233/** * Data */export function mergeDataOrFn(parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; // in a Vue.extend merge, both should be functions if (!childVal) &#123; return parentVal &#125; if (!parentVal) &#123; return childVal &#125; // when parentVal &amp; childVal are both present, // we need to return a function that returns the // merged result of both functions... no need to // check if parentVal is a function here because // it has to be a function to pass previous merges. return function mergedDataFn() &#123; return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal) &#125; &#125; else &#123; return function mergedInstanceDataFn() &#123; // instance merge const instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal const defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125; &#125;&#125; 如果处理的是子组件选项： 子选项不存在，则使用父选项 父选项不存在，则使用子选项 12345678910// Vue不存在data选项，所以使用子选项const ParentComponent = Vue.extend(&#123; data() &#123; return &#123; a: 1 &#125; &#125;&#125;)// ParentComponent存在data选项，而子选项不存在，使用父选项const childCompoent = ParentComponent.extend(&#123;&#125;) 子选项与父选项都存在，则返回mergedDataFn函数 我们可以发现mergeDataorFn函数在处理子组件选项时返回的总是一个函数，这也就是间接导致strats.data策略函数在处理子组件选项时返回的也总是一个函数 如果处理的不是子组件选项：返回mergedInstanceDataFn函数 mergeDataorFn和mergedInstanceDataFn中的代码类似，都是调用mergeData方法，传入父 data 以及子 data，如果data是个function，则调用该function生成一个 data 对象。TODO:这里有个疑问，当处理的是子组件的选项时，感觉不需要再判断childVal和parentVal是否是function了，因为它们一定是function，这在strats.data中已经判断了的。 我们接着看mergeData方法，它才是终极的合并策略，其源码如下： 1234567891011121314151617181920212223/** * Helper that recursively merges two data objects together. */function mergeData(to: Object, from: ?Object): Object &#123; if (!from) return to let key, toVal, fromVal const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from) for (let i = 0; i &lt; keys.length; i++) &#123; key = keys[i] // in case the object is already observed... if (key === '__ob__') continue toVal = to[key] fromVal = from[key] if (!hasOwn(to, key)) &#123; set(to, key, fromVal) &#125; else if (toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal)) &#123; mergeData(toVal, fromVal) &#125; &#125; return to&#125; mergeData的参数to代表的是childData，from代表的是parentData。这里值得注意的几点有： mergeData的函数目的是把parentData的属性添加到childData上。如果parentData上的属性不存在于childData上，则调用set函数把这个属性添加到childData上；如果parentData上的属性存在于childData中且都为纯对象，则递归调用mergeData进行深度合并。 Object.keys无法遍历出symbol属性，而Reflect.ownKeys可以，Reflect是一个内置的对象，它提供拦截 JavaScript 操作的方法。 如果key为__ob__，TODO: 上面提到了一个set函数，这个函数来自于src/core/observe/index.js，实际上这个set函数就是Vue暴露给我的全局 APIVue.set，TODO:。 最后我们对大家经常会产生疑问的地方做一些补充： 一、为什么最终strats.data会被处理成一个函数这是因为，通过函数返回数据对象，保证了每个组件实例都有一个唯一的数据副本，避免了组件间数据互相影响。 二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据这个问题是什么意思呢？我们知道在合并阶段strats.data将被处理成一个函数，但是这个函数并没有被执行，而是到了后面初始化的阶段才执行的，这个时候才会调用mergeData对数据进行合并处理，那么这么做的目的是什么呢？ 其实这么做是有原因的，后面讲到Vue的初始化的时候，大家就会发现inject和props这两个的选项的初始化是优先于data选项的，这就保证了我们能够使用props初始化data中的数据，如下： 1234567891011121314151617181920212223// 子组件：使用 props 初始化子组件的 childDataconst Child = &#123; template: '&lt;span&gt;&lt;/span&gt;', data() &#123; return &#123; childData: this.parentData &#125; &#125;, props: ['parentData'], created() &#123; // 这里将输出 parent console.log(this.childData) &#125;&#125;var vm = new Vue(&#123; el: '#app', // 通过 props 向子组件传递数据 template: '&lt;child parent-data=\"parent\" /&gt;', components: &#123; Child &#125;&#125;) 如上例所示，子组件的数据childData的初始值就是parentData这个props，而之所以能够这样做的原因有两个： 由于props的初始化先于data选项的初始化 data选项是在初始化的时候才求值的，你也可以理解为在初始化的时候才使用mergeData进行数据合并 三、你可以这么做1234567891011data (vm) &#123; return &#123; childData: vm.parentData &#125;&#125;// 或者使用更简单的解构赋值data (&#123; parentData &#125;) &#123; return &#123; childData: parentData &#125;&#125; data 函数的参数实际上就是当前实例对象。那么这个参数是在哪里传进来的呢？其实有两个地方，其中一个地方我们前面见过了，如下面这段代码： 1234return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal)// 和const instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childValconst defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal 当然仅仅在这里这么做是不够的，比如mergeDataFn前面的代码： 123456if (!childVal) &#123; return parentVal&#125;if (!parentVal) &#123; return childVal&#125; 在这段代码中，直接将parentVal或childVal返回了，我们知道这里的parentVal和childVal就是data数，由于被直接返回，所以并没有指定其运行的作用域，且也没有传递当前实例作为参数，所以我们必然还是在其他地方做这些事情，而这个地方就是我们说的第二个地方，它在哪里呢？当然是初始化的时候，后面我们会讲到的，如果这里大家没有理解也不用担心。 生命周期钩子选项的合并策略Vue生命周期钩子1const LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'] 123456789101112131415161718192021/** * Hooks and props are merged as arrays. */function mergeHook(parentVal: ?Array&lt;Function&gt;, childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123; const res = childVal ? (parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal]) : parentVal return res ? dedupeHooks(res) : res&#125;function dedupeHooks(hooks) &#123; const res = [] for (let i = 0; i &lt; hooks.length; i++) &#123; if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]) &#125; &#125; return res&#125;LIFECYCLE_HOOKS.forEach(hook =&gt; &#123; strats[hook] = mergeHook&#125;) 整个函数体由三组三目运算符组成： 1234567return (是否有 childVal，即判断组件的选项中是否有对应名字的生命周期钩子函数) ? 如果有 childVal 则判断是否有 parentVal ? 如果有 parentVal 则使用 concat 方法将二者合并为一个数组 : 如果没有 parentVal 则判断 childVal 是不是一个数组 ? 如果 childVal 是一个数组则直接返回 : 否则将其作为数组的元素，然后返回数组 : 如果没有 childVal 则直接返回 parentVal 这里我们以created钩子为例，演示一下钩子函数的合并过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// fromnew Vue(&#123; created: function () &#123; console.log('created') &#125;&#125;)// tooptions.created = [ function () &#123; console.log('created') &#125;]// fromconst Parent = Vue.extend(&#123; created: function () &#123; console.log('parentVal') &#125;&#125;)const Child = new Parent(&#123; created: function () &#123; console.log('childVal') &#125;&#125;)// tooptions.created = [ created: function () &#123; console.log('parentVal') &#125;, created: function () &#123; console.log('childVal') &#125;]// fromconst createFnconst Parent = Vue.extend(&#123; created: function () &#123; console.log('parentVal') &#125;&#125;)const Child = new Parent(&#123; created: function () &#123; console.log('childVal') &#125;&#125;) 这里有个地方需要注意，那就是dedupeHooks函数做的事情： 1234567891011121314151617181920function createdFn() &#123; console.log(this.name) // 'ChildComponent'&#125;const ParentComponent = Vue.extend(&#123; data: function() &#123; return &#123; name: 'ParentComponent' &#125; &#125;, created: createdFn&#125;)const ChildComponent = new ParentComponent(&#123; data: function() &#123; return &#123; name: 'ChildComponent' &#125; &#125;, created: createdFn&#125;) 如果两个 created 函数引用的是同一个函数，则只会调用一次，而调用时绑定的this作用域是最后引用的组件，具体需要查看调用方法的实现 TODO: 通过钩子函数的合并代码，我们能发现还有一个地方官方文档没有提及的就是钩子函数我们能够传入数组，例如： 12345678910111213new Vue(&#123; created: [ function() &#123; console.log('first') &#125;, function() &#123; console.log('second') &#125;, function() &#123; console.log('third') &#125; ]&#125;) 资源（assets）选项的合并策略资源（assets）1export const ASSET_TYPES = ['component', 'directive', 'filter'] 1234567891011121314151617181920/** * Assets * * When a vm is present (instance creation), we need to do * a three-way merge between constructor options, instance * options and parent options. */function mergeAssets(parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): Object &#123; const res = Object.create(parentVal || null) if (childVal) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; assertObjectType(key, childVal, vm) return extend(res, childVal) &#125; else &#123; return res &#125;&#125;ASSET_TYPES.forEach(function(type) &#123; strats[type + 's'] = mergeAssets&#125;) assets的合并策略：首先以parentVal为原型创建一个对象赋给res，然后判断childVal是否存在，如果存在且为纯对象，则调用extend方法进行合并，然后返回；如果childVal不存在，则直接返回res 以components为例，假设我们有以下代码： 123456var v = new Vue(&#123; el: '#app', components: &#123; ChildComponent: ChildComponent &#125;&#125;) 则合并后为： 123456789res = &#123; ChildComponent // 原型 __proto__: &#123; KeepAlive, Transition, TransitionGroup &#125;&#125; 所以这就是为什么我们不用显示地注册组件就能够使用一些内置组件的原因，同时这也是内置组件的实现方式，通过Vue.extend创建出来的子类也是一样的道理，一层一层地通过原型进行组件的搜索。 选项 watch 的合并策略12345678910111213141516171819202122232425262728/** * Watchers. * * Watchers hashes should not overwrite one * another, so we merge them as arrays. */strats.watch = function(parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): ?Object &#123; // work around Firefox's Object.prototype.watch... if (parentVal === nativeWatch) parentVal = undefined if (childVal === nativeWatch) childVal = undefined /* istanbul ignore if */ if (!childVal) return Object.create(parentVal || null) if (process.env.NODE_ENV !== 'production') &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = &#123;&#125; extend(ret, parentVal) for (const key in childVal) &#123; let parent = ret[key] const child = childVal[key] if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent] &#125; ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child] &#125; return ret&#125; 这里有几点需要注意： 判断了parentVal和childVal是否等于nativeWatch，如果是，则重置为undefined。这么做的原因是因为在firefox浏览器中，Object.prototype拥有原生的watch函数。 被处理后的watch选项下的每个键值，有可能是一个数组，也有可能是一个函数。 watch选项允许我们传入一个数组，类似于钩子函数，不同于钩子函数的地方在于对同一个函数的引用会触发两次调用，如下： 1234567891011121314151617181920212223242526function watchFn(newVal) &#123; console.log(this, newVal) // 会打印两次，this都指向ChildComponent&#125;const ParentComponent = Vue.extend(&#123; data: function() &#123; return &#123; name: 'ParentComponent' &#125; &#125;, watch: &#123; name: watchFn &#125;&#125;)const ChildComponent = new ParentComponent(&#123; data: function() &#123; return &#123; name: 'ChildComponent' &#125; &#125;, watch: &#123; name: watchFn &#125;&#125;)ChildComponent.name = '222' 选项props、method、inject、computed的合并策略123456789101112131415161718192021/** * Other object hashes. */strats.props =strats.methods =strats.inject =strats.computed = function ( parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): ?Object &#123; if (childVal &amp;&amp; process.env.NODE_ENV !== 'production') &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = Object.create(null) extend(ret, parentVal) if (childVal) extend(ret, childVal) return ret&#125; 对于props、method、inject、computed这四个选项有一个共同点，就是它们的结构都是纯对象，虽然我们在书写props或者inject选项的时候可能是一个数组，但是在Vue选项的规范化这一节我们知道，Vue内部都将其规范化为了一个对象 选项provide的合并策略最后一个选项的合并策略，就是provide选项的合并策略，只有一句代码，如下： 1strats.provide = mergeDataOrFn 也就是provide选项的合并策略与data选项的合并策略相同，都是使用mergeDataOrFn函数 选项处理小结现在我们了解了 Vue 中是如何合并处理选项的，接下来我们稍微做一个总结： 对于 el、propsData选项使用默认的合并策略defaultStrat。 对于 data 选项，使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象。 对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行 对于 directives、filters 以及 components 等资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。 对于 watch 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行。 对于 props、methods、inject、computed 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。 对于 provide 选项，其合并策略使用与 data 选项相同的 mergeDataOrFn 函数。 最后，以上没有提及到的选项都将使默认选项 defaultStrat。 最最后，默认合并策略函数 defaultStrat 的策略是：只要子选项不是 undefined 就使用子选项，否则使用父选项。 至此，我们大概介绍完了 Vue 对选项的处理，但留心的同学一定注意到了，options.js 文件的代码我们都基本逐行分析，唯独剩下一个函数我们始终没有提到，它就是 resolveAsset 函数。这个函数我们暂且不在这里讲，后面随着我们的深入，自然会再次碰到它，到那个时候应该是讲它的最好时机。 再看mixins和extends在Vue选项的规范化一节中，我们讲到了mergeOptions函数中的如下这段代码： 1234567891011121314// Apply extends and mixins on the child options,// but only if it is a raw options object that isn't// the result of another mergeOptions call.// Only merged options has the _base property.if (!child._base) &#123; if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm) &#125; if (child.mixins) &#123; for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm) &#125; &#125;&#125; 我们知道mixins在Vue中用于解决代码复用的问题，比如混入created生命周期钩子，用于打印一句话： 123456789101112const consoleMixin = &#123; created () &#123; console.log('created:mixins') &#125;&#125;new Vue (&#123; mixins: [consoleMixin], created () &#123; console.log('created:instance') &#125;&#125;) 运行以上代码，将打印两句话： 12// created:mixins// created:instance 这是因为mergeOptions函数在处理mixins选项的时候递归调用了mergeOptions函数将mixins合并到了parent中，并将合并后生成的新对象作为新的parent： 12345if (child.mixins) &#123; for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm) &#125;&#125; 上例中我们只涉及到created生命周期钩子的合并，所以会使用生命周期钩子的合并策略函数进行处理，现在我们已经知道mergeOptions会把生命周期选项合并为一个数组，所以所有的生命周期钩子都会被执行。那么不仅仅是生命周期钩子，任何写在mixins中的选项，都会使用mergeOptions中相应的合并策略进行处理，这就是mixins的实现方式。 对于extends选项，与mixins相同，甚至由于extends选项只能是一个对象，而不能是数组，反而要比mixins的实现更为简单，连遍历都不需要。 下一篇：Vue的初始化之开篇","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue选项的规范化","slug":"Vue选项的规范化","date":"2019-03-26T03:25:26.000Z","updated":"2019-03-27T05:46:16.391Z","comments":true,"path":"2019/03/26/Vue选项的规范化.html","link":"","permalink":"http://yoursite.com/2019/03/26/Vue选项的规范化.html","excerpt":"","text":"这节主要是对 mergeOptions 方法进行说明，根据core/instance/init.js顶部的引用关系可知，mergeOptions函数来自于src/core/util/options.js文件，事实上不仅仅是mergeOptions函数，整个文件所做的一切都是为了一件事：选项的合并 弄清楚传递给 mergeOptions 函数的三个参数首先，我们需要搞清楚一件事，就是如下代码中传递给mergeOptions函数的三个参数到底是什么 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) 第一个参数是通过调用resolveConstructorOptions函数得到的，并将vm.constructor作为参数传递进去，这个函数声明在src/core/instance/init.js文件中，如下： resolveConstructorOptions1234567891011121314151617181920212223export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options if (Ctor.super) &#123; const superOptions = resolveConstructorOptions(Ctor.super) const cachedSuperOptions = Ctor.superOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed, // need to resolve new options. Ctor.superOptions = superOptions // check if there are any late-modified/attached options (#4976) const modifiedOptions = resolveModifiedOptions(Ctor) // update base extend options if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125; 声明options变量，初始化为当前实例构造函数的options，在这个例子中Ctor是Vue（如果是实例化通过Vue.extend创建的子类，那么这里的Ctor就不是Vue，而是该子类），然后返回options变量 如果Ctor.super存在（该实例是通过实例化Vue.extend创建的子类实现的），则执行if判断语句里面的代码 该函数的作用就是用来获取当前实例构造者的options属性（在这个例子中就是Vue.options，如下） Vue.options12345678910111213Vue.options = &#123; components: &#123; KeepAlive Transition, TransitionGroup &#125;, directives:&#123; model, show &#125;, filters: Object.create(null), _base: Vue&#125; 第二个参数就是我们调用Vue构造函数传进来的参数 123456&#123; el: '#app', data: &#123; test: 1 &#125;&#125; 第三个参数vm是实例对象本身 检查组件名称是否符合要求打开src/core/util/options.js，找到mergeOptions方法，这个方法上面有一段注释： 1234/** * Merge two option objects into a new one. * Core utility used in both instantiation and inheritance. */ 合并两个对象为一个对象，这个函数不仅仅在实例化对象（即_init方法中）的时候用到，在继承（Vue.extend）中也有用到，所以这个函数是一个用来合并两个选项对象为一个新对象的通用程序。 开始的一段代码如下， 123if (process.env.NODE_ENV !== 'production') &#123; checkComponents(child)&#125; 在非生产环境下，会以child对象（构造实例时传入的options）为参数，调用checkComponents方法，该方法是用来校验组件名是否符合要求的，组件名的要求如下 组件的名称需要满足正则表达式：/^[a-zA-Z][\\\\-\\\\.0-9_a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]*$/ 要满足：条件isBuiltInTag(name) || config.isReservedTag(name)不成立 isBuitlInTag检测是否是内置标签（slot、component） config.isReservedTag检测是否是保留标签，isReservedTag方法在src/platform/web/runtime/index.js中被初始化，通过查看可知在Vue中html标签和部分SVG标签被认为是保留的 允许合并另一个实例构造者的选项我们继续看代码，接下来的一段代码同样是一个if语句块 123if (typeof child === 'function') &#123; child = child.options&#125; 这说明child参数除了是普通的选项对象外，还可以是一个函数，如果是函数的话就取该函数的options静态属性作为新的child。Vue和通过Vue.extend创造出来的子类拥有options属性。所以这就允许我们在进行选项合并的时候，去合并一个Vue实例构造者的选项了。 规范化选项（props, inject, directives）接着看代码，接下来是三个用来规范化选项的函数调用，因为Vue中拥有多种使用方法的选项有很多，例如props，即可以传Array也可以传Object，为了在选项合并的时候能够统一处理，所以需要将其规范成同一种方式： 123normalizeProps(child, vm)normalizeInject(child, vm)normalizeDirectives(child) normalizeProps: 将props统一规范为对象的形式 props规范化12345678910111213141516171819202122232425262728293031323334353637383940414243444546// from&#123; props: ['demo-props'] // 非字符串将会报错&#125;// to&#123; props: &#123; demoProps: &#123; type: null &#125; &#125;&#125;// from&#123; props: &#123; DemoProps: &#123; type: Number, default: 1 &#125; &#125;&#125;// to&#123; props: &#123; demoProps: &#123; type: Number, default: 1 &#125; &#125;&#125;// from&#123; props: &#123; DemoProps: Number &#125;&#125;// to&#123; props: &#123; demoProps: &#123; type: Number &#125; &#125;&#125; normalizeInject: 将inject统一规范为对象的形式 inject规范化12345678910111213141516171819202122232425262728293031// from&#123; inject: ['data1', 'data2']&#125;// to&#123; inject: &#123; 'data1': &#123; from: 'data1' &#125; 'data2': &#123; from: 'data2' &#125; &#125;&#125;// fromlet data1 = 'data1'&#123; data1, d2: 'data2', data3: &#123; someProperty: 'someValue' &#125;&#125;// to&#123; data1: &#123; from: 'data1' &#125;, d2: &#123; from: 'data2' &#125;, data3: &#123; from: 'data3', someProperty: 'someValue' &#125;&#125; normalizeDirectives：将directives统一规范为对象的形式 12345678910111213141516171819202122232425262728293031// from&#123; directives: &#123; test1: function (el) &#123; console.log('v-test1') &#125;, test2: &#123; bind: function (el) &#123; console.log('v-test2') &#125; &#125; &#125;&#125;// to&#123; directives: &#123; test1: &#123; bind: function (el) &#123; console.log('v-test1') &#125;, update: function (el) &#123; console.log('v-test1') &#125; &#125;, test2: &#123; bind: function (el) &#123; console.log('v-test2') &#125; &#125; &#125;&#125; 处理 extends 和 mixins规范化props、inject、directives之后的一段代码是： 1234567891011121314// Apply extends and mixins on the child options,// but only if it is a raw options object that isn't// the result of another mergeOptions call.// Only merged options has the _base property.if (!child._base) &#123; if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm) &#125; if (child.mixins) &#123; for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm) &#125; &#125;&#125; 递归调用mergeOptions方法，将child.exnteds和child.mexins合并到parent上，直到child为Vue时，只有Vue上有_base属性，其直为Vue 下一篇：Vue选项的合并","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"以一个例子为线索","slug":"以一个例子为线索","date":"2019-03-21T08:37:16.000Z","updated":"2019-03-26T03:25:46.572Z","comments":true,"path":"2019/03/21/以一个例子为线索.html","link":"","permalink":"http://yoursite.com/2019/03/21/以一个例子为线索.html","excerpt":"","text":"假设我们有如下模板： 1&lt;div id=\"app\"&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt; 和这样一段 js 代码 123456var vm = new Vue(&#123; el: '#app', data: &#123; test: 1 &#125;&#125;) 这段js代码很简单，我们只是简单的调用了Vue，传递了两个选项el和data。这段代码的最终效果就是在页面中渲染如下的DOM： 1&lt;div id=\"app\"&gt;1&lt;/div&gt; 其中被替换成了1，并且当我们尝试修改data.set的时候 123vm.$data.test = 2// 或vm.test = 2 那么页面的DOM也会随之变化为： 1&lt;div id=\"app\"&gt;2&lt;/div&gt; 我们从new Vue()的操作开始分析，从Vue 构造函数这章中我们得知Vue构造函数定义在src/core/instance/index.js中 123456function Vue(options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 一目了然，这里首先进行了一个判断，在非生产环境不通过new操作符执行Vue函数时，会给予一个警告，然后调用了_init方法，_init方法是在initMixin方法中添加到Vue.prototype上的，initMixin方法是在src/core/instance/init.js中声明的，并把 options 作为参数传入 123456options = &#123; el: '#app', data: &#123; test: 1 &#125;&#125; 然后我们来看看_init方法的具体代码 123const vm: Component = this// a uidvm._uid = uid++ 把当前实例对象赋给变量 vm 往 vm 实例上添加了一个唯一标识_uid，其值为uid，uid是在initMixin上发定义的初始化为 0，每次创建一个Vue实例后，uid的值便会加 1 性能追踪代码12345678910111213141516let startTag, endTag/* istanbul ignore if */if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag)&#125;// 中间的代码省略.../* istanbul ignore if */if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)&#125; config.performance来自于src/core/config.js，Vue提供了全局配置Vue.config.performance，我们可以通过将其设置为true，即可开启性能追踪，你可以追踪四个场景的性能： 组件初始化（component init），也就是上面的代码 编译（compiler），将模板（template）编译成渲染函数 渲染（render），其实就是渲染函数执行并且生成虚拟 DOM（vnode）的性能 打补丁，将虚拟 DOM 渲染成真实 DOM 的性能 mark与measure的定义来自于src/core/util/perf.js，实际上调用的 window.performance.mark 与 window.performance.measure src/core/util/perf.js12345678910111213141516export let markexport let measureif (process.env.NODE_ENV !== 'production') &#123; const perf = inBrowser &amp;&amp; window.performance /* istanbul ignore if */ if (perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures) &#123; mark = tag =&gt; perf.mark(tag) measure = (name, startTag, endTag) =&gt; &#123; perf.measure(name, startTag, endTag) perf.clearMarks(startTag) perf.clearMarks(endTag) // perf.clearMeasures(name) &#125; &#125;&#125; window.performance demo12345678910111213const perf = window.performanceconst startTag = 'perf-start'const endTag = 'perf-end'perf &amp;&amp; perf.mark(startTag)for (let i = 0; i &lt; 10000; i++) &#123;&#125;if (perf) &#123; perf.mark(endTag) perf.measure('performance test', startTag, endTag) console.log(perf.getEntries())&#125; 在Chorme中可通过Performance Tab下的Timings查看记录的性能 性能追踪中间的代码12345678910111213141516171819202122232425262728293031// a flag to avoid this being observedvm._isVue = true// merge optionsif (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options)&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm )&#125;/* istanbul ignore else */if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm)&#125; else &#123; vm._renderProxy = vm&#125;// expose real selfvm._self = vminitLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, 'created') 上面的代码是性能追踪代码中间的代码，主要做了以下几件事： 在Vue实例上增加了_isVue属性，用来表示一个对象是否是Vue实例。这样可以避免被响应系统观测（其实在其它地方也有用到，但是宗旨是一样的） 判断options._isComponent属性是否存在（该属性是调用Vue.component方法时，追加的一个内部属性），如果存在，TODO:，如果不存在，往当前实例上追加$options属性（在上面代码中一系列init的初始化方法中用到） 调用了一系列的init初始化方法 下一篇：Vue选项的规范化","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"了解Vue这个项目","slug":"了解Vue这个项目","date":"2019-03-20T12:59:45.000Z","updated":"2019-03-26T03:22:59.370Z","comments":true,"path":"2019/03/20/了解Vue这个项目.html","link":"","permalink":"http://yoursite.com/2019/03/20/了解Vue这个项目.html","excerpt":"","text":"写在前面最近在学习Vue源码，学习的路线主要是参考Vue技术内幕来的，阅读的过程中按照讲解一步步从浅入深，感觉自己还是跟的上的，但是当看完了一半的文章后，回过来想想又感觉自己什么都不懂，再往下读下去，我认为会非常吃力，并且最后的结果很可能是对于某一个知识点自己能稍微说的上来，但是对于整体的架构，某行具体的代码，为什么要这么做，这么做是为了解决什么样的问题等等一无所知，同时也为了以后能有个贯穿整体的复习资料再加上原文有些图片丢失了= =，就决定读完一章，便自己总结一下本章的内容，可能很多东西会跟原文的内容一致，毕竟有蝴蝶效应，但是聊胜于无，毕竟记录下来了，就相当于以自己的思路贯穿了一遍。 立个Flag果然，很多东西不定一个目标是无法达到自己的想要的目的，学习更是如此，每天的工作量不同导致自己看文章拖泥带水，有空的时候看看，没空的时候就不看，说实话，时间都是有的，没空只是安慰自己的借口，工作很累，下班了想要好好休息休息，我总是这么想，导致自己学东西特别的慢，不想利用自己业余时间去学习这个想法是阻碍我前进的根本原因，所以在这里立一个flag，一周之内也就是下周三（2019.3.27号）之前完成Vue源码的阅读，并产出相关的读书记录，希望这个flag能有用吧= = Vue目录分析123456789101112131415161718192021222324252627282930313233343536373839├── scripts ------------------------------- 构建相关的文件，一般情况下我们不需要动│ ├── git-hooks ------------------------- 存放git钩子的目录│ ├── alias.js -------------------------- 路径别名配置│ ├── config.js ------------------------- 生成rollup配置的文件│ ├── build.js -------------------------- 对 config.js 中所有的rollup配置进行构建│ ├── ci.sh ----------------------------- 持续集成运行的脚本│ ├── release.sh ------------------------ 用于自动发布新版本的脚本├── dist ---------------------------------- 构建后文件的输出目录├── examples ------------------------------ 存放一些使用Vue开发的应用案例├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)├── packages ------------------------------ 存放独立发布的包的目录├── test ---------------------------------- 包含所有测试文件├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码│ ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数│ ├── core ------------------------------ 存放通用的，与平台无关的代码│ │ ├── observer ---------------------- 响应系统，包含数据观测的核心代码│ │ ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码│ │ ├── instance ---------------------- 包含Vue构造函数设计相关的代码│ │ ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── components -------------------- 包含抽象出来的通用组件│ ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码│ ├── platforms ------------------------- 包含平台特有的相关代码，不同平台的不同构建的入口文件也在这里│ │ ├── web --------------------------- web平台│ │ │ ├── entry-runtime.js ---------- 运行时构建的入口，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意│ │ │ ├── entry-runtime-with-compiler.js -- 独立构建版本的入口，它在 entry-runtime 的基础上添加了模板(template)到render函数的编译器│ │ │ ├── entry-compiler.js --------- vue-template-compiler 包的入口文件│ │ │ ├── entry-server-renderer.js -- vue-server-renderer 包的入口文件│ │ │ ├── entry-server-basic-renderer.js -- 输出 packages/vue-server-renderer/basic.js 文件│ │ ├── weex -------------------------- 混合应用│ ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包│ ├── shared ---------------------------- 包含整个代码库通用的代码├── package.json -------------------------- 不解释├── yarn.lock ----------------------------- yarn 锁定文件├── .editorconfig ------------------------- 针对编辑器的编码风格配置文件├── .flowconfig --------------------------- flow 的配置文件├── .babelrc ------------------------------ babel 配置文件├── .eslintrc ----------------------------- eslint 配置文件├── .eslintignore ------------------------- eslint 忽略配置├── .gitignore ---------------------------- git 忽略配置 Vue的不同构建输出打开文件scripts/config.js，其中定义了builds对象，builds对象针对平台、环境、构建输出的模块方式、版本、使用方的不同进行了不同的配置，总结为： 构建平台：web（浏览器）、web-server（服务器）、weex（开发原生应用程序的框架）。 版本：运行时版本、编译器、完整版本（运行时版本+编译器）。编译器提供了能够在运行时把template编译成render函数的能力，运行时版本比完整版本体积大约小于30%，同时提高了性能。 环境：development、production。（TODO:具体的差别） 模块：CommonJS、UMD、ES Module。UMD使得你可以直接通过&lt;script&gt;标签引用，而CommonJS形式的模块就是为webpack 1和browserify提供的，它们在加载模块的时候不能直接加载ES Module，而Webpack 2和Rollup是可以直接加载ES Module的，所以就有了es形式的模块输出。 使用方：Bundlers（打包工具，例如Webpack，Browserify等）、Browser（浏览器） TODO:下方列出了所有的构建项以及它们的大致区别，当然也不仅仅只是这些简单的区别，具体的区别还需要进一步分析。 构建名称 平台 版本 环境 模块 使用方 web-runtime-cjs-dev web 运行时版 development CommonJS Bundlers web-runtime-cjs-prod web 运行时版 production CommonJS Bundlers web-full-cjs-dev web 完整版 development CommonJS Browser web-full-cjs-prod web 完整版 production CommonJS Browser web-runtime-esm web 运行时版本 不区分 ES Module Bundlers web-full-esm web 完整版 不区分 ES Module Bundlers web-full-esm-browser-dev web 完整版 development ES Module Browser web-full-esm-browser-prod web 完整版 production ES Module Browser web-runtime-dev web 运行时版 development UMD Browser web-runtime-prod web 运行时版 production UMD Browser web-full-dev web 完整版 development UMD Browser web-full-prod web 完整版 production UMD Browser web-compiler web 编译器 不区分 CommonJS Bundlers web-compiler-browser web 编译器 development UMD Browser web-server-renderer-dev web-server 不区分 development CommonJS 不区分 web-server-renderer-prod web-server 不区分 production CommonJS 不区分 web-server-renderer-webpack-server-plugin web-server 不区分 不区分 CommonJS Webpack Server web-server-renderer-webpack-client-plugin web-server 不区分 不区分 CommonJS Webpack Client weex-factory weex 运行时版 不区分 CommonJS 不区分 weex-framework weex 运行时版 不区分 CommonJS 不区分 weex-compiler weex 编译器 不区分 CommonJS Weex’s Webpack Loader package.jsonpackage.json中的一些字段和构建命令说明如下： main：运行时版本，cjs模块，用于webpack 1或browserify module：运行时版本，es模块，用于webpack 2+或Rollup dev：构建完整版umd模块的Vue dev:cjs：构建运行时cjs模块的Vue dev:esm：构建运行时es模块的Vue dev:ssr：构建web-server-renderer包 dev:compiler：构建Compiler包 12345678910111213141516171819202122232425262728293031323334&#123; \"main\": \"dist/vue.runtime.common.js\", \"module\": \"dist/vue.runtime.esm.js\", \"scripts\": &#123; \"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\", \"dev:cjs\": \"rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev\", \"dev:esm\": \"rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm\", \"dev:test\": \"karma start test/unit/karma.dev.config.js\", \"dev:ssr\": \"rollup -w -c scripts/config.js --environment TARGET:web-server-renderer\", \"dev:compiler\": \"rollup -w -c scripts/config.js --environment TARGET:web-compiler \", \"dev:weex\": \"rollup -w -c scripts/config.js --environment TARGET:weex-framework\", \"dev:weex:factory\": \"rollup -w -c scripts/config.js --environment TARGET:weex-factory\", \"dev:weex:compiler\": \"rollup -w -c scripts/config.js --environment TARGET:weex-compiler \", \"build\": \"node scripts/build.js\", \"build:ssr\": \"npm run build -- web-runtime-cjs,web-server-renderer\", \"build:weex\": \"npm run build -- weex\", \"test\": \"npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr &amp;&amp; npm run test:weex\", \"test:unit\": \"karma start test/unit/karma.unit.config.js\", \"test:cover\": \"karma start test/unit/karma.cover.config.js\", \"test:e2e\": \"npm run build -- web-full-prod,web-server-basic-renderer &amp;&amp; node test/e2e/runner.js\", \"test:weex\": \"npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.js\", \"test:ssr\": \"npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.js\", \"test:sauce\": \"npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2\", \"test:types\": \"tsc -p ./types/test/tsconfig.json\", \"lint\": \"eslint src scripts test\", \"flow\": \"flow check\", \"sauce\": \"karma start test/unit/karma.sauce.config.js\", \"bench:ssr\": \"npm run build:ssr &amp;&amp; node benchmarks/ssr/renderToString.js &amp;&amp; node benchmarks/ssr/renderToStream.js\", \"release\": \"bash scripts/release.sh\", \"release:weex\": \"bash scripts/release-weex.sh\", \"release:note\": \"node scripts/gen-release-note.js\", \"commit\": \"git-cz\" &#125;&#125; 下一篇：Vue构造函数","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"通过Vue源码学到的知识","slug":"通过Vue源码学到的知识","date":"2019-03-20T12:20:35.000Z","updated":"2019-03-27T12:42:59.548Z","comments":true,"path":"2019/03/20/通过Vue源码学到的知识.html","link":"","permalink":"http://yoursite.com/2019/03/20/通过Vue源码学到的知识.html","excerpt":"","text":"src/shared/util.js: camelizeRE123456const camelizeRE = /-(\\w)/gexport const camelize = cached( (str: string): string =&gt; &#123; return str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : '')) &#125;) String.prototype.replace方法第二个参数可以传一个 CallbackFunction，其返回值将会替换匹配到的字符串 如果第一个参数为字符串：Callback 的参数为（第一个匹配到的字符串，匹配到的字符串的起始索引，字符串本身） 如果第一个参数为正则表达式：Callback 的参数为（匹配到的字符串，…所有捕获组，匹配到的字符串的起始索引, 字符串本身） src/core/util/options.js validateComponentName12345678export function validateComponentName(name: string) &#123; if (!new RegExp(`^[a-zA-Z][\\\\-\\\\.0-9_$&#123;unicodeLetters&#125;]*$`).test(name)) &#123; warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.') &#125; if (isBuiltInTag(name) || config.isReservedTag(name)) &#123; warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name) &#125;&#125; 声明一个字符串时如果字符串中包含单\\，实际上会被去除，\\\\的意思才表示\\ 声明正则表达式时包含单\\，会报错 正则表达式定义范围时[]，里面的类似于*.等字符不进行转义处理与进行转义处理的效果是一致的，而\\w必须进行转义处理 1234567// abcd\\let a = '\\abcd\\\\'// errorlet reg = /abcde\\/// reg1的效果与reg2的效果一致let reg1 = /[.*]/let reg1 = /[\\.\\*]/ 调用Object.defineProperty时，只设置get不设置set，则其相当于readonly window.performance的运用，在Chrome devtool中的Performance -&gt; Timing中可以看到性能记录信息 12345678910111213const perf = window.performanceconst startTag = 'perf-start'const endTag = 'perf-end'perf &amp;&amp; perf.mark(startTag)for (let i = 0; i &lt; 10000; i++) &#123;&#125;if (perf) &#123; perf.mark(endTag) perf.measure('performance test', startTag, endTag) console.log(perf.getEntries())&#125; Object.keys与Reflect.ownKeys都是遍历对象自身的属性，但是Object.keys无法遍历出Symbol属性且受enumerable影响，而Reflect.ownKeys可以遍历出Sumbol属性且不受enumerable影响","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue构造函数","slug":"Vue构造函数","date":"2019-03-20T12:19:50.000Z","updated":"2019-03-26T03:23:54.201Z","comments":true,"path":"2019/03/20/Vue构造函数.html","link":"","permalink":"http://yoursite.com/2019/03/20/Vue构造函数.html","excerpt":"","text":"Vue构造函数的原型以npm run dev为切入点，查看package.json中的dev script 1\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\" 找到scripts下的config.js，builds对象中包含了不同的构建配置，具体有哪些配置以及它们之间有什么不同请阅读了解Vue这个项目，查找构建目标web-full-dev对应的配置，其对应的入口文件为web/entry-runtime-with-compiler.js，web所指向的目录在路径别名配置文件scripts/alias.js中，其指向的是src/platforms/web目录 1234567891011const builds = &#123; // Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, ... 打开src/platforms/web/entry-runtime-with-compiler.js目录，有这么一句import Vue from &#39;./runtime/index&#39;，依次向上查找到声明Vue的文件为src/core/instance/index.js，查找路径为下： src/platforms/web/entry-runtime-with-compiler.js：import Vue from ‘./runtime/index’ src/platforms/web/runtime/index.js：import Vue from ‘core/index’（core指的是src/core，请查看别名文件scripts/alias.js） src/core/index.js：import Vue from ‘./instance/index’ src/core/instance/index.js：End src/core/instance/index.js文件的内容如下图，其中所调用的各个方法的作用为： src/core/instance/index.js1234567891011121314151617181920212223import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue initMixin 定义了方法：Vue.prototype._init，该方法是内部初始化的一个方法，在Vue构造函数中被调用 12345export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; // ... _init 方法的函数体，此处省略 &#125;&#125; stateMixin 定义了属性：Vue.prototype.$data代理了Vue实例的_data属性，Vue.prototype.$props代理了Vue实例的_props属性，在非生产环境修改_data和_props会给予错误提示，属性介绍 123456789101112131415161718const dataDef = &#123;&#125;dataDef.get = function () &#123; return this._data &#125;const propsDef = &#123;&#125;propsDef.get = function () &#123; return this._props &#125;if (process.env.NODE_ENV !== 'production') &#123; dataDef.set = function (newData: Object) &#123; warn( 'Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this ) &#125; propsDef.set = function () &#123; warn(`$props is readonly.`, this) &#125;&#125;Object.defineProperty(Vue.prototype, '$data', dataDef)Object.defineProperty(Vue.prototype, '$props', propsDef) 定义了方法：Vue.prototype.$set，Vue.prototype.$delete，Vue.prototype.$watch，方法介绍 12345678910Vue.prototype.$set = setVue.prototype.$delete = delVue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object): Function &#123; // ...&#125; eventsMixin 定义了方法：Vue.prototype.$on，Vue.prototype.$once，Vue.prototype.$off，Vue.prototype.$emmit，方法介绍 1234Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123;&#125;Vue.prototype.$once = function (event: string, fn: Function): Component &#123;&#125;Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123;&#125;Vue.prototype.$emit = function (event: string): Component &#123;&#125; lifecycleMixin 定义了方法：Vue.prototype._update（内部使用），Vue.prototype.$forceUpdate，Vue.prototype.$destory，方法介绍 123Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;&#125;Vue.prototype.$forceUpdate = function () &#123;&#125;Vue.prototype.$destroy = function () &#123;&#125; renderMixin 以Vue.prototype为参数调用了src/core/instance/render-helpers/index.js中的installRenderHelpers方法 12345678910111213141516171819export function installRenderHelpers (target: any) &#123; target._o = markOnce target._n = toNumber target._s = toString target._l = renderList target._t = renderSlot target._q = looseEqual target._i = looseIndexOf target._m = renderStatic target._f = resolveFilter target._k = checkKeyCodes target._b = bindObjectProps target._v = createTextVNode target._e = createEmptyVNode target._u = resolveScopedSlots target._g = bindObjectListeners target._d = bindDynamicKeys target._p = prependModifier&#125; 定义了方法：Vue.prototype.$nextTick、Vue.prototype._render（内部使用），方法介绍 12Vue.prototype.$nextTick = function (fn: Function) &#123;&#125;Vue.prototype._render = function (): VNode &#123;&#125; Vue 构造函数的静态属性和方法（全局API）按照查找Vue构造函数时的文件路径回溯，打开src/core/index.js文件，其内容如下： 1234567891011121314151617181920212223242526import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 调用src/core/global-api/index.js中的initGlobalAPI方法 定义了属性Vue.config，代理了src/core/config.js导出的对象，并且在非生产环境修改时给予错误提示。属性介绍 src/core/config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export default (&#123;/*** Option merge strategies (used in core/util/options)*/optionMergeStrategies: Object.create(null),/*** Whether to suppress warnings.*/silent: false,/*** Show production mode tip message on boot?*/productionTip: process.env.NODE_ENV !== 'production',/*** Whether to enable devtools*/devtools: process.env.NODE_ENV !== 'production',/*** Whether to record perf*/performance: false,/*** Error handler for watcher errors*/errorHandler: null,/*** Warn handler for watcher warns*/warnHandler: null,/*** Ignore certain custom elements*/ignoredElements: [],/*** Custom user key aliases for v-on*/// $flow-disable-linekeyCodes: Object.create(null),/*** Check if a tag is reserved so that it cannot be registered as a* component. This is platform-dependent and may be overwritten.*/isReservedTag: no,/*** Check if an attribute is reserved so that it cannot be used as a component* prop. This is platform-dependent and may be overwritten.*/isReservedAttr: no,/*** Check if a tag is an unknown element.* Platform-dependent.*/isUnknownElement: no,/*** Get the namespace of an element*/getTagNamespace: noop,/*** Parse the real tag name for the specific platform.*/parsePlatformTagName: identity,/*** Check if an attribute must be bound using property, e.g. value* Platform-dependent.*/mustUseProp: no,/*** Perform updates asynchronously. Intended to be used by Vue Test Utils* This will significantly reduce performance if set to false.*/async: true,/*** Exposed for legacy reasons*/_lifecycleHooks: LIFECYCLE_HOOKS&#125;: Config) 定义了Vue.util，该对象下有4个属性：warn、extend、mergeOptions、defineReactive。这4个属性来自src/core/util/index.js。 123456789// exposed util methods.// NOTE: these are not considered part of the public API - avoid relying on// them unless you are aware of the risk.Vue.util = &#123; warn, extend, mergeOptions, defineReactive&#125; 这里有一段注释，大概意思是 Vue.util 以及 util 下的四个方法都不被认为是公共API的一部分，要避免依赖他们，但是你依然可以使用，只不过风险你要自己控制。并且，在官方文档上也并没有介绍这个全局API，所以能不用尽量不要用。 定义了Vue.set、Vue.delete、Vue.nextTick、Vue.observable、Vue.options，属性介绍 123456789101112131415161718Vue.set = setVue.delete = delVue.nextTick = nextTick// 2.6 explicit observable APIVue.observable = &lt;T&gt;(obj: T): T =&gt; &#123; observe(obj) return obj&#125;Vue.options = &#123; components: &#123; KeepAlive &#125;, directives: Object.create(null), filters: Object.create(null), _base: Vue&#125; 调用了以下方法，全局API介绍 initUse：定义了Vue.use initMixin：定义了Vue.mixin initExtend：定义了Vue.cid、Vue.extend initAssetRegisters：定义了Vue.compontent、Vue.directive、Vue.filter 定义了Vue.$isServer、Vue.$ssrContext、Vue.version（VERSION在scripts/config.js中定义） Vue 平台化的包装这节主要说了几件事 src/core目录下存放的是与平台无关的代码 src/platforms下的目录作用是针对web和weex平台进行不同的包装，例如Vue.config（代理的是core/config.js导出的对象，上文有说到）的默认属性，因平台的不同，其属性会被覆盖，例如：src/platforms/runtime/index.js中干了几件事： 设置平台化的Vue.config 在Vue.options中混合了两个指令（directives），分别是model和show 在Vue.options中混合了两个组件（components），分别是Transition和TransitionGroup 在Vue.prototype上添加了两个方法：__patch和$mount with compiler 运行时版的入口文件src/platforms/web/entry-runtime.js导出的Vue就到./runtime/index.js为止，Vue构造函数和原型包含的属性和方法就是上面所有的内容 完整版导出的Vue在运行时版上多了个compiler，具体查看src/platforms/web/entry-runtime-with-compiler.js，这个文件对Vue的影响有两个： 重写了Vue.prototype.$mount的方法 增加了Vue.compile全局API 下一篇：以一个例子为线索","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"原理","slug":"框架/Vue/原理","permalink":"http://yoursite.com/categories/框架/Vue/原理/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"VueConstructor","slug":"VueConstructor","permalink":"http://yoursite.com/tags/VueConstructor/"}]},{"title":"vscode+typescript问题记录","slug":"vscode-typescript问题记录","date":"2019-03-19T13:14:55.000Z","updated":"2019-03-19T13:52:50.388Z","comments":true,"path":"2019/03/19/vscode-typescript问题记录.html","link":"","permalink":"http://yoursite.com/2019/03/19/vscode-typescript问题记录.html","excerpt":"","text":"ESLintVSCode的ESLint扩展支持.ts,.tsx文件command+shift+p调出命令面板，选择Open Settings(JSON)，在配置中加入以下内容","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"typescript","slug":"编程语言/typescript","permalink":"http://yoursite.com/categories/编程语言/typescript/"},{"name":"问题积累","slug":"编程语言/typescript/问题积累","permalink":"http://yoursite.com/categories/编程语言/typescript/问题积累/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"vsoce","slug":"vsoce","permalink":"http://yoursite.com/tags/vsoce/"}]},{"title":"vue+typescript问题记录","slug":"vue-typescript问题记录","date":"2019-03-19T13:14:42.000Z","updated":"2019-03-19T13:44:50.803Z","comments":true,"path":"2019/03/19/vue-typescript问题记录.html","link":"","permalink":"http://yoursite.com/2019/03/19/vue-typescript问题记录.html","excerpt":"","text":"文件包含import或export即为模块问题描述 因为需要在Vue构造函数下追加一些属性而又想把所有Vue相关的类型声明放在一个文件里，所以就直接在shims-vue.d.ts文件中加入了额外的声明，结果发现引入.vue文件时，提示无法找到该模块。 原因产生这个问题的原因是因为在ts中，只要最顶层中含有import或者export语法，该文件即为一个模块，如果没有，则声明默认定义在全局作用域下。正因为我们在shims-vue.d.ts中用了import的语法，导致该文件变成了一个模块，所以就导致*.vue的模块声明语句没有在全局作用域中生效。 解决方案需要声明在全局作用域下的模块单独放在一个文件，在本案例中，把module ‘*.vue’的声明单独放在shims-vue.d.ts中，其它不需要声明在全局作用域下的，例如本案例中扩展Vue构造函数的声明放在另一个文件即可，如下所示：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"typescript","slug":"编程语言/typescript","permalink":"http://yoursite.com/categories/编程语言/typescript/"},{"name":"问题积累","slug":"编程语言/typescript/问题积累","permalink":"http://yoursite.com/categories/编程语言/typescript/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"}]},{"title":"Velocity语法","slug":"Velocity语法","date":"2019-03-12T05:55:09.000Z","updated":"2019-03-12T07:18:12.244Z","comments":true,"path":"2019/03/12/Velocity语法.html","link":"","permalink":"http://yoursite.com/2019/03/12/Velocity语法.html","excerpt":"","text":"Velocity基本语法介绍判断语句1234567#if($condition) ...#elseif($condition) ...#else ...#end 运算符 比较符：== != &gt; &gt;= &lt; &lt;= 逻辑运算符：&amp;&amp; || ! 运算符：+ - * / % 常用判断 判断是否为null #if(( !$condition) &amp;&amp; (“$!condition” == “”) ) 使用NULL工具：#if( $null.isNull($condition) ) 使用#ifnull() 或 #ifnotnull()，要使用这个特性必须在velocity.properties文件中加入： 12userdirective = org.apache.velocity.tools.generic.directive.Ifnulluserdirective = org.apache.velocity.tools.generic.directive.Ifnotnull 判断是否为true：#if( $condition == true ) 判断是否为null或false：#if( !$condition ) 判断是否为空字符串：#if( $condition == “” ) 判断是否为null或者空字符串：#if( “$!condition” === “” ) 判断是否是一个数字：#if( $condition == 123 ) Velocity中的==可以直接比较数值，字符串以及其它对象，如果==两侧的对象是不同的类的对象，在比较前会用toString()转换后再比较。所以当$condition的值为123或”123”时，条件都为真 循环语句123#foreach($val in $arr)...#end $velocityCount和$foreach.count可以获得当前循环次数，初始值为1 $foreach.hasNext用来判断是否存在下一次循环 #break用于用于跳出循环，经测试，在jello框架里无效 当$arr为对象的时候：$val取到的是value，如果需要在遍历对象的过程中，同时取到对象的keys，可以使用entrySet() 或 keySet()方法 1234567#foreach($item in $!obj.entrySet()) $!item.key: $!item.value#end#foreach($key in $!obj.keySet()) $key: $obj.get($key)#end 注意：这种集合的遍历是无序的，即遍历顺序可能不同于$obj中元素定义的顺序 Range Operator1234567#foreach($foo in [1..5]) $foo#end#foreach($bar in [2..-2]) $bar#end 以上输出为： Example1：1 2 3 4 5Example2：2 1 0 -1 -2 Example2，经测试，在jello框架中不能包含负数 字符串$str.charAt(index) 获取指定下标的字符 $str.substring(begin, end) end不填，截取begin到字符串末尾，不改变原值 $str.length() 返回字符串的长度 $str.toUpperCase() 把字符串转换为大写 $str.toLowerCase() 把字符串转换为小写 $str.replace(old, new) 替换字符串中指定的子串 $str.indexOf($substr) 从字符串头部开始检索是否存在某个子串 $str.lastIndexOf($substr) 从字符串尾部开始检索是否存在某个子串 字符串拼接：$str + $str1 或 ${str}oo${str1}： 例如： 12345#set($str = “AA”)#set($str1 = “BB”)#set($str2 = $str + $str1) 则${str}oo${str1}的结果为：AAooBB 字符串转数字： 12345#set( $intString = “9” )#set( $Integer = 0 )$Integer.parseInt($intString) 同理： 12345#set( $doubleString = “12.3” )#set( $Double = 0.0 )$Double.parseDouble( $doubleString ) 数组$arr.size() 返回数组长度 $arr.isEmpty() 判断数组是否为空 $arr.get(index)或$arr[index] 返回数组中指定下标index的值 $arr.set(1, “test”) 设置数组中指定下标的值 $arr.add($param) 增加元素 宏宏的定义：#macro(宏的名称 $参数1 $参数2) 语句体 #end 宏的调用：#macro($参数1 $参数2)//参数之间用空格隔开 例子: 123456789#macro (tablerows $color $somelist) #foreach($something in $somelist) &lt;tr&gt;&lt;td bgColor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt; #end#end 调用： 12345678#set($color = “blue”)#set($arr = [“a”, “b”, “c”, “d”])&lt;table&gt;#tablerows($color $arr)&lt;/table&gt; 参考文档 http://www.blogjava.net/alexwan/archive/2008/06/07/206473.html http://velocity.apache.org/engine/devel/user-guide.html#variables http://wiki.apache.org/velocity/VelocityNullSupport http://wiki.apache.org/velocity/CheckingForNull","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"Velocity","slug":"编程语言/Velocity","permalink":"http://yoursite.com/categories/编程语言/Velocity/"}],"tags":[{"name":"velocity","slug":"velocity","permalink":"http://yoursite.com/tags/velocity/"}]},{"title":"js-继承的5种方式","slug":"js-继承的5种方式","date":"2019-03-11T08:50:40.000Z","updated":"2019-03-11T10:25:56.134Z","comments":true,"path":"2019/03/11/js-继承的5种方式.html","link":"","permalink":"http://yoursite.com/2019/03/11/js-继承的5种方式.html","excerpt":"","text":"原型基础123456789function Animal (name) &#123; this.name = name&#125;Animal.prototype.say = function (something) &#123; console.log(`$&#123; this.name &#125; is say something`)&#125;const animal = new Animal('animal') 往原型上增加属性和方法的原因：如果所有属性和方法都添加在实例上，那么每创建一个实例对象，其都有很多重复的属性和方法，需要耗费大量的内存，且降低了运行效率 构造函数Animal，其原型链为：Animal =&gt; Animal.prototype =&gt; Object的实例 =&gt; null，Animal.prototype.proto.proto === null 实例对象的consturctor属性（实际上这个属性不在实例对象本身上，而是在构造函数的原型上）指向构造函数 prototype对象的isPrototypeOf方法用来判断是否是某个对象的原型 实例对象的hasOwnProperty方法判断某个属性是否是实例对象本身的属性 in操作符用于判断某个属性是否存在于实例对象或其原型上 instanceof用于判断某个对象是否是某个构造函数的实例 animal.proto === A.prototype 构造函数的5种继承方法","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"js","slug":"面试题/js","permalink":"http://yoursite.com/categories/面试题/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"},{"name":"extends","slug":"extends","permalink":"http://yoursite.com/tags/extends/"}]},{"title":"TypeScript笔记","slug":"TypeScript笔记","date":"2019-03-09T07:43:06.000Z","updated":"2019-03-11T08:07:07.188Z","comments":true,"path":"2019/03/09/TypeScript笔记.html","link":"","permalink":"http://yoursite.com/2019/03/09/TypeScript笔记.html","excerpt":"","text":"TypeScript入门教程 null和undefined是所有类型的子类型，也就说null和undefined类型的变量可以赋值给任意类型的变量，而void类型的变量却不行。 在any类型的变量上访问任何属性或者调用任何方法都是允许的，声明一个变量为any后，对它的任何操作，返回的内容的类型都是任意值。 变量如果在声明的时候，未指定其类型，那么它会被识别为any类型。 当TypeScript不确定一个联合类型的变量是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性和方法。 12345function getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 赋值的时候，变量的形状必须与接口的形状保持一致。 接口一旦定义了索引签名，那么确定属性和可选属性的类型都必须是它的类型的子集。 123456interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'. 只读属性的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 1234567891011121314151617interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.// Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 调用函数时，输入多余的（或者少于要求的）参数，是不被允许的，可以使用可选参数。 可选参数后面不允许再出现必须参数了。 TypeScript会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制了。 当发生函数重载的时候，TypeScript会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 123456function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.// Type 'number' is not comparable to type 'boolean'. declare var a 与 var a的区别在于declare并没有对变量a进行声明，在编译结果中会被删除，而var a声明了这个变量。 1234567891011121314decalre var a // 说明在某处已经声明过改变量a = 1 // 对变量重新进行赋值// 上述代码编译结果a = 1// -----------var aa = 1// 上述代码编译结果var aa = 1 只有function、class和interface可以直接默认导出，其它的变量需要先定义出来，再默认导出 1234567export default enum Directions &#123;// ERROR: Expression expected. Up, Down, Left, Right&#125; 当为元组类型的变量添加越界的元素时，它的类型会被限制为元组每个类型的联合类型。 枚举项有两种类型：常数项和计算所得项。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错 1234enum Color &#123;Red = \"red\".length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer. 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。 12345678910declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 上述代码编译为：var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"TypeScript","slug":"编程语言/TypeScript","permalink":"http://yoursite.com/categories/编程语言/TypeScript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"git结合beyond-compare","slug":"git结合beyond-compare","date":"2019-03-08T07:10:44.000Z","updated":"2019-03-08T07:14:00.514Z","comments":true,"path":"2019/03/08/git结合beyond-compare.html","link":"","permalink":"http://yoursite.com/2019/03/08/git结合beyond-compare.html","excerpt":"","text":"beyond compare 无限试用for mac 应用程序 -&gt; beyond cmpare右击显示包内容 -&gt; contents -&gt; macos 在当前目录下新建文件BCompare.sh，把原来的BCompare重命名为BCompare.real 编辑BCompare.sh，输入以下代码: 123#!/bin/bashrm \"/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat\"\"`dirname \"$0\"`\"/BCompare.real $@ 右击BCompare.sh -&gt; 显示简介 -&gt; 删除文件名后缀.sh .gitconfig配置.gitconfig位于user下, shift + comand + . 显示隐藏文件 12345678910111213141516[alias] dift = &quot;difftool --dir-diff --no-symlinks&quot;[diff] tool = bcomp[difftool] prompt = false[difftool &quot;bcomp&quot;] trustExitCode = true cmd = &quot;/usr/local/bin/bcomp&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot;[merge] tool = bcomp[mergetool] prompt = false[mergetool &quot;bcomp&quot;] trustExitCode = true cmd = &quot;/usr/local/bin/bcomp&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; \\&quot;$BASE\\&quot; \\&quot;$MERGED\\&quot; git dift origin/dev：当前分支与远程dev分支进行比较","categories":[{"name":"其它技术","slug":"其它技术","permalink":"http://yoursite.com/categories/其它技术/"},{"name":"git","slug":"其它技术/git","permalink":"http://yoursite.com/categories/其它技术/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"beyond compare","slug":"beyond-compare","permalink":"http://yoursite.com/tags/beyond-compare/"}]},{"title":"Jekins构建结果与本地构建结果Vue版本不同","slug":"Jekins构建结果与本地构建结果Vue版本不同","date":"2019-03-08T07:00:30.000Z","updated":"2019-03-08T07:09:09.434Z","comments":true,"path":"2019/03/08/Jekins构建结果与本地构建结果Vue版本不同.html","link":"","permalink":"http://yoursite.com/2019/03/08/Jekins构建结果与本地构建结果Vue版本不同.html","excerpt":"","text":"背景项目迁移到jenkins，通过jenkins进行构建，部署后发现页面报错，但是本地构建出来代码部署后是正常的，报错如下： 问题排查过程 注释webpack插件UglifyJsPlugin插件，不进行代码压缩 对比本地代码与jenkins构建出来的代码，构建输出目录结构如下： 对比结果 app.js中只存在一些变量名和Path的不一致，不会产生错误 manifest.js完全一致 vendor.js中Vue的版本不一致，jenkins构建出来的Vue版本是2.5.20，本地构建出来的Vue版本是2.5.21，推测是由此产生的错误 用本地构建出的vendor.js替换jenkins构建出的vendor.js，部署到ftp上，发现问题解决了，确认推测是正确的 对比两个Vue版本代码的不同，发现是以下代码影响的： 分析：rendList是v-for的实现方法，在Vue2.5.20中，当入参val属于类型: Array, String, Number, Object（非null）时初始化变量ret为数组并进行相应的处理，然后判断ret变量不为undefined和null时，给ret变量添加属性_isVList为true，然后将ret变量返回，ret的类型可能为undefined, Array，当返回undefined时，对undefined进行一些数组的操作就会发生错误，而控制台所报的错误就是因为取了undefined.length导致的，在Vue2.5.21版本修复了这个Bug，如果ret变量为undefined或null时，初始化ret为[]，这样确保rendList的返回值类型始终为Array 解决方法由上可知，产生改问题的原因如下： 直接原因： Vue2.5.20版本中存在代码漏洞 根本原因：jenkins服务器安装的Vue版本不正确，而为什么jenkins服务器安装的vue版本和本地安装的不一致，需要进一步排查，已经排除是node版本导致的原因 因此，只要把package.json中vue依赖的版本号固定为2.5.21（注意：vue-template-compiler版本需要跟vue版本保持一致），问题就可以解决了，如下图：","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"},{"name":"Webpack","slug":"打包工具/Webpack","permalink":"http://yoursite.com/categories/打包工具/Webpack/"},{"name":"问题积累","slug":"打包工具/Webpack/问题积累","permalink":"http://yoursite.com/categories/打包工具/Webpack/问题积累/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"动态加载模块","slug":"动态加载模块","date":"2019-03-08T06:59:10.000Z","updated":"2019-03-08T07:08:18.598Z","comments":true,"path":"2019/03/08/动态加载模块.html","link":"","permalink":"http://yoursite.com/2019/03/08/动态加载模块.html","excerpt":"","text":"背景项目本地开发通过mockjs进行数据模拟，它是通过重写XMLHttpRequest对象来拦截请求，从而达到纯前端mock，在webpack入口文件main.js中通过require引入mock文件，以下是mock文件和main.js的代码： mock file: main.js: Bug描述上线后，发现在部分android手机和少数ios手机上无法加载出页面 问题排查 通过抓包排除接口&amp;数据问题 页面注入vConsole发现控制台输出脚本错误，无法识别const关键字 在构建出的js中定位const关键字，如下图： 可以得出问题表面原因是因为某些机型浏览器版本较低，无法识别ES6语法 问题分析通过查看构建后的js与分析发现了三个问题： const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？ 为何该const语法没有经过babel转译成ES5语法？ 为何打包出的js没有进行压缩？ 问题一const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？ webapck构建过程：webpack在构建的时候，会从所有入口文件开始递归查找代码中的require语法和import语法，并生成一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的bundle，而动态require模块webpack也是能够支持的，但会导致所有可能用到的模块都包含在bundle中（详见），如果代码中依赖条件表达式动态require模块，类似上面的main.js那样，又不想把不需要的模块打包到bundle中，需要遵循以下要求： 条件表达式中不允许出现变量 条件表达式不允许执行函数调用 只能进行一些常量的运算，如下： 12345678910111213141516171819// module.js会被打包进bundleif (1 + 1 === 2) &#123; require('./module.js')&#125;// module.js会被打包进bundleif (true) &#123; require('./module.js')&#125;// module.js不会被打包进bundleif (1 &gt; 2) &#123; require('./module.js')&#125;// module.js不会被打包进bundleif (1 !== 1) &#123; require('./module.js')&#125; webapck集成的DefinePlugin插件允许创建一个在编译时可以配置的全局常量（详见） 问题1的原因正是因为违背了上述原则2，调用了字符串的match函数，而我们在webpack配置使用DefinePlugin插件，创建了一个全局常量process.env，从而规避了原则1 12345678910111213// main.jsif (!process.env.NODE_ENV.match(/production|test/)) &#123; require('../mock/index')&#125;// webpack配置&#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env': env &#125;) ]&#125; 因此我们可以把main.js文件中的代码改成以下内容，达到非开发环境不把mock文件打包到bundle中 123if (process.env.NODE_ENV === 'development') &#123; require('../mock/index')&#125; 问题二为何该const语法没有经过babel转译成ES5语法？ 原因是在webpack的配置中，配置了只对src，test目录下的文件执行babel转译（详见），而mock文件不在这些目录下，所以没有进行转译 问题三为何打包出的js没有进行压缩？ 我们对项目进行构建，UglifyJsWebpackPlugin插件会报出如下错误： 错误问题指向的是打包后的const语法，原因是因为UglifyJsWebpackPlugin不支持ES6语法，所以在treeshaking的时候，遇到const语法，就发生错误了，终止了插件的执行，从而也无法执行后续的压缩步骤，但这并不影响其它插件的功能，webpack也无法感知到这个插件在执行过程中出现了错误，所以构建结果仍然是成功的 总结 运用条件表达式动态加载模块，除非条件表达式中不出现变量、函数调用，只进行一些常量的运算，那么条件为false的时候该模块是不会打包进bundle中的，否则无论条件为false还是true，始终会把该模块打包进bundle，只不过在条件为false的情况下不执行代码罢了 可以运用DefinePlugin添加运行时的全局常量 可以通过配置babel-loader的include选项对指定文件夹下的文件进行转译 UglifyJsWebpackPlugin不支持ES6语法 webpack无法感知插件运行过程中出现的错误，需要构建完成对构建的结果进行check，例如通过eslint对dist文件进行检查，是否有非ES5的代码","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"},{"name":"Webpack","slug":"打包工具/Webpack","permalink":"http://yoursite.com/categories/打包工具/Webpack/"},{"name":"问题积累","slug":"打包工具/Webpack/问题积累","permalink":"http://yoursite.com/categories/打包工具/Webpack/问题积累/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"滚动穿透问题","slug":"滚动穿透问题","date":"2019-03-08T06:52:10.000Z","updated":"2019-03-08T06:53:31.953Z","comments":true,"path":"2019/03/08/滚动穿透问题.html","link":"","permalink":"http://yoursite.com/2019/03/08/滚动穿透问题.html","excerpt":"","text":"目的当页面中有弹层时，禁止body的滚动 解决方案 给body或html增加overflow: hidden pc端：可行 ios：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度 android：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度 mask增加touchmove.prevent，滚动元素增加prevent.stop pc端：不可行，仍然会滚动穿透 ios：不可行，仍然会滚动穿透 android: 不可行，仍然会滚动穿透 给body增加fixed，打开弹层时记录滚动条位置，弹层消失时滚动到记录位置 pc端：可行 ios：当你从滚动容器滑动到容器之外时，或从底部下拉起控制中心，会导致容器进入短暂的无法滚动状态，等待一段时间后自动恢复，推测是ios的页面回弹效果影响的 android: 可行 12345.modal-open &#123; position: fixed; width: 100%; overflow: hidden;&#125; 12345678910111213141516const ModalHelper = (function (bodyCls) &#123; let scrollTop return &#123; // 弹出之后记录保存滚动位置，并且给body添加.modal-open afterOpen: function () &#123; scrollTop = document.scrollingElement.scrollTop document.body.classList.add(bodyCls) document.body.style.top = -scrollTop + 'px' &#125;, // 关闭时将.modal-open移除并还原之前保存滚动位置 beforeClose: function () &#123; document.body.classList.remove(bodyCls) document.scrollingElement.scrollTop = scrollTop &#125; &#125;;&#125;)('modal-open') 监听滚动容器的touchmove事件，当检测到已经处于最底部，却还意图往下滚动时，阻止默认事件（处于最顶部时同理） pc端：不支持touch事件 ios：可行，解决了页面反弹问题 android: 不可行，阻止默认事件没生效，仍会滚动穿透 12345678910111213141516171819202122232425262728293031323334353637383940// 记录开始滑动的坐标，用于判断滑动方向let startY = 0// 记录滑动状态：0：未开始，1：已开始，2：滑动中let scrollStatus = 0// 以下所有事件均绑定在滚动容器元素上function touchstartHandler (e) &#123; status = 1 startY = e.targetTouches[0].pageY&#125;function touchmoveHandler (e) &#123; if (status !== 1) return status = 2 let t = e.currentTarget let py = e.targetTouches[0].pageY // 内容可视高度 let ch = t.clientHeight // 内容滚动高度 let sh = t.scrollHeight // 当前滚动高度 let st = t.scrollTop // 已经到头部尽头了还要向上滑动，阻止它 if (st === 0 &amp;&amp; startY &lt; py) &#123; e.preventDefault() &#125; // 已经到低部尽头了还要向下滑动，阻止它 if ((st === sh - ch) &amp;&amp; startY &gt; py) &#123; e.preventDefault() &#125;&#125;function touchendHandler (e) &#123; status = 0&#125; 不用自带滚动条，使用transform+overflow:hidden，监听touchmove事件自实现滚动效果 总结针对网页需要适配的端的不同，可采用不同的解决方案： PC端： 上述1、3 移动端：由上可见，单独的任何一种方法都无法完美适配android和ios，因此需要合并上述方法3、4以达到完美适配（Tip：在测试过程中，发现上述方法3在ios下的某些app中弹出弹层时页面会闪动，且页面弹层会消失，拖动页面才出现，如果要适配的app出现此类问题，最好区分android和ios环境分别采用上述3、4的方法，或者采用上述1、4合并（但是要把body或html的高度设置为屏幕的高度））","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"问题积累","slug":"移动端开发/问题积累","permalink":"http://yoursite.com/categories/移动端开发/问题积累/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"滚动穿透","slug":"滚动穿透","permalink":"http://yoursite.com/tags/滚动穿透/"}]},{"title":"input之type=number","slug":"input之type-number","date":"2019-03-08T06:51:56.000Z","updated":"2019-03-11T10:27:03.371Z","comments":true,"path":"2019/03/08/input之type-number.html","link":"","permalink":"http://yoursite.com/2019/03/08/input之type-number.html","excerpt":"","text":"业务需求页面中存在输入框，点击输入框需要弹出数字键盘，且只能输入合法数字 解决方案 自己开发一个键盘组件 input type=”number” input type=”number”存在的问题（只调查了部分机型，不一定完全准确） 机型 键盘类型 表现 输入限制 ios 自带键盘 调起带数字的特殊符号键盘，可以切换成英文键盘 可以输入任何字符，输入的不是合法的数字，则取到的value为空 ios 非自带键盘 调起数字键盘，可以切换成英文键盘 可以输入任何字符，输入的不是合法的数字，则取到的value为空 android 自带键盘 调起纯数字键盘，可以切换成英文键盘 可以输入数字，-、小数点，输入的不是合法的数字时，取到的value为空 android 非自带键盘 调起纯数字键盘，可以切换成英文键盘 可以输入数字，-、小数点和e，输入的不是合法的数字或带有e时，取到的value为空 由上表可知，尽管input设置了type=”number”，但是在不同的机型与输入法下，所弹出的键盘和能输入的字符是不同的，并不能保证用户输入的是合法的数字，所以我们要对用户的输入进行限制。通过监听input事件，在用户进行输入后，进行正则校验替换非法字符，但是设置了type=”number”后，如果用户输入的不是合法的数字，取到的value为空，根本无法进行合法性校验与替换操作，在Android下还好，它已经帮我们限制了英文、符号等非法字符的输入，用户的输入得到了一定的保证，我们可以在input的blur事件中进行最终的合法性校验，并给予用户一定的提示。但是在ios下，用户可以输入任意的字符，也就是说用户输入非法的字符的可能性提高了很多，若同样在blur事件中进行校验与替换操作，给用户带来的体验过差，所以在ios下使用type=”number”并不可行 那么在ios下是否有其它调起纯数字键盘的方法答案是肯定的，以下两种方法可以调起纯数字键盘，但是调起来的数字键盘是不带小数点的，如果需要输入小数的话，这种方法是不可行的 type=”tel” pattern=”[0-9]*” 如果是webview，调用native的事件貌似可以，但需要native人员的支持 思考综上所诉，type设置为number的方法是不可行的，无法实现我们对用户的输入进行实时的控制，但是把type设置为text，每次调起的都是英文键盘，用户还得切换一下键盘，才能愉快的进行输入，这个体验实在是太糟糕了，如果你的页面只有一个输入框，用户或许还能勉为其难的接受，但是如果存在多个，每次用户进行输入都得切换以下，可能砸手机的心态都有了😡，可见，把type设置为text的方法更加不可行 回到我们的需求 弹出数字键盘 限制用户输入 首先要满足弹出数字键盘，就必须设置type=”number”，但是设置了type=”number”之后，该怎么限制用户的输入呢？把type设回text就行了，于是有了以下处理方案： 1234567891011121314151617181920212223&lt;template&gt; &lt;input type=\"number\" :model=\"price\" @focus=\"focusHandler($event)\" @blur=\"blurHandler($event)\"/&gt;&lt;/template&gt;&lt;script&gt; export default &#123; watch: &#123; price: function () &#123; const newPrice = // 正则替换操作 return newPrice &#125; &#125;, methods: &#123; blurHandler (e) &#123; e.target.type = 'number' &#125;, focusHandler (e) &#123; setTimeOut(() =&gt; &#123; e.target.type = 'text' &#125;, 100) &#125; &#125; &#125;&lt;/script&gt; 在输入框获取焦点，弹起了数字键盘后，再把input的type设回text，这样当用户输入的是非数字字符时，也能获取到正常的value值了，然后进行合法性校验和替换，在失去焦点的时候，再把type设回number，以防下次点击的时候弹出非数字键盘，经过测试这种实现方法在ios下操作正常，但是在android下根本无法弹出键盘，于是有了下面的解决方案 最终方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div class=\"demo\"&gt; &lt;input type=\"number\" class=\"demo--input\" v-model=\"realValue\" @focus=\"inputFocusHandler($event)\" @blur=\"inputBlurHandler($event)\" @input=\"inputHandler\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"DemoInput\", props: &#123; &#125;, data() &#123; return &#123; realValue: \"\" &#125; &#125;, computed: &#123; &#125;, created() &#123; &#125;, watch: &#123; realValue: function(newValue) &#123; let realValue = newValue.replace(/[^0-9.]|(^\\.)/g, \"\") if (realValue.charAt(realValue.length - 1) === \".\") &#123; let tempValue = realValue.slice(0, -1) this.realValue = /\\./g.test(tempValue) ? tempValue : realValue return &#125; this.realValue = realValue &#125; &#125;, methods: &#123; validateValue () &#123; const &#123; realValue &#125; = this // 校验输入的是否是数字 if ( realValue !== \"\" &amp;&amp; !/^[0-9]+(\\.[0-9]+)?$/.test(realValue) ) &#123; this.realValue = \"\" alet('请输入正确的数字！') return false &#125; // 去除数字前面多余的0 if ((/\\./g).test(realValue)) &#123; this.realValue = realValue.replace(/^0+\\./, \"0.\") &#125; else &#123; this.realValue = realValue.replace(/^0+/, \"\") &#125; return true &#125;, inputBlurHandler(e) &#123; if (window.APP_TYPE === \"ios\") &#123; e.target.type = \"number\" &#125; this.validateValue() &#125;, inputHandler(e) &#123; // 长度输入限制 if (this.realValue.length &gt; 7) &#123; this.realValue = this.realValue.slice(0, 7) &#125; &#125;, inputFocusHandler(e) &#123; if (window.APP_TYPE === \"ios\") &#123; setTimeout(() =&gt; &#123; e.target.type = \"text\" &#125;, 100) &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; Tip 移动端自定义指令v-focus仍然无法实现点击某个按钮，使input自动获取焦点，在pc端可行","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"问题积累","slug":"移动端开发/问题积累","permalink":"http://yoursite.com/categories/移动端开发/问题积累/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"input","slug":"input","permalink":"http://yoursite.com/tags/input/"},{"name":"type=\"number\"","slug":"type-number","permalink":"http://yoursite.com/tags/type-number/"}]},{"title":"八种方法实现CSS页面底部固定","slug":"八种方法实现CSS页面底部固定","date":"2019-03-08T06:42:59.000Z","updated":"2019-03-08T06:44:24.595Z","comments":true,"path":"2019/03/08/八种方法实现CSS页面底部固定.html","link":"","permalink":"http://yoursite.com/2019/03/08/八种方法实现CSS页面底部固定.html","excerpt":"","text":"八种方法实现CSS页面底部固定页面布局： 12345&lt;div id=\"wrap\"&gt; &lt;header id=\"header\"&gt;header&lt;/header&gt; &lt;main id=\"main\"&gt;&lt;/main&gt; &lt;footer id=\"footer\"&gt;footer&lt;/footer&gt;&lt;/div&gt; 通用样式： 123456789101112* &#123; margin: 0; padding: 0;&#125;#header &#123; height: 50px; background: #f00;&#125;#footer &#123; height: 100px; background: yellow;&#125; 解决方案： footer高度固定+绝对定位 1234567891011121314html,body &#123; height: 100%;&#125;#wrap &#123; position: relative; min-height: 100%; box-sizing: border-box; padding-bottom: 100px;&#125;#footer &#123; position: absolute; bottom: 0; width: 100%;&#125; 主体区域设置margin负值 1234567891011121314html, body &#123; height: 100%;&#125;#wrap &#123; height: 100%;&#125;#main &#123; box-sizing: border-box; min-height: 100%; padding-top: 50px; padding-bottom: 100px; margin-top: -50px; margin-bottom: -100px;&#125; header, footer设置margin负值 123456789101112131415html, body, #wrap &#123; height: 100%;&#125;#main &#123; box-sizing: border-box; min-height: 100%; padding-top: 50px; padding-bottom: 100px;&#125;#header &#123; margin-bottom: -50px;&#125;#footer &#123; margin-top: -100px;&#125; 通过设置flex，将footer的margin-top设置为auto 12345678#wrap &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;#footer &#123; margin-top: auto;&#125; 通过calc()计算内容的高度 123#main &#123; min-height: calc(100vh - 150px);&#125; 通过设置flexbox，将主体main设置为flex 12345678#wrap &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;#main &#123; flex: 1;&#125; 使用grid布局 123456789#wrap &#123; display: grid; min-height: 100vh; grid-template-rows: auto 1fr auto;&#125;#footer &#123; grid-row-start: 3; grid-row-end: 4;&#125; display: table 12345678#wrap &#123; display: table; min-height: 100vh;&#125;#main &#123; display: table-row; height: 100%;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"CSS","slug":"编程语言/CSS","permalink":"http://yoursite.com/categories/编程语言/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"底部固定","slug":"底部固定","permalink":"http://yoursite.com/tags/底部固定/"}]},{"title":"深入理解CSS：字体度量、line-height和vertical-align","slug":"深入理解CSS：字体度量、line-height和vertical-align","date":"2019-03-08T06:42:32.000Z","updated":"2019-03-08T06:45:58.664Z","comments":true,"path":"2019/03/08/深入理解CSS：字体度量、line-height和vertical-align.html","link":"","permalink":"http://yoursite.com/2019/03/08/深入理解CSS：字体度量、line-height和vertical-align.html","excerpt":"","text":"参考文档原文： Deep dive CSS: font metrics, line-height and vertical-align - Vincent De Oliveira 译文： 深入理解 CSS：字体度量、line-height 和 vertical-align 深入研究CSS字体度量及CSS 盒子 总结概述line-height, vertical-align涉及到IFC(内联格式化上下文) line-height取值可以为数字或px，数字表示相对于font-size的倍数，默认值为normal，normal取值为1-1.2之间 font-size不同字体，设置相同的font-size，其在页面上所占据的高度是不一样的，原因在于字体本身 字体的定义规则： 字母的高度被称为“em”，在数字化字体中 em 是空间的数字化定义总量。em的大小（以下均写为: EM size）通常是 1000 单位，在 TrueType 字体中，EM size 约定是2的幂，通常是1024或2048。 根据其实际使用的单位，字体的度量可以根据一些设置来决定。注意，有些值是em-square之外的值。 在浏览器中，相对单位是用于缩放用来适应所需的 font-size 字体的设置： 一款字体会定义一个em-square：在字体设计中一个字符所在的空间容器（也被称作“EM size”或者“UPM”）），一般被设定为宽高均为1000的相对单位，也可是1024、2048相对单位 字体度量： baseline (基线): 分隔 ascent 和 descent ，默认字符底端沿 baseline 排列，如图中的P，x，Ё(为俄文字符) ascent (上升): 基线的上部分，字符最高处与 ascent 顶端可能有空白，由 font-family 决定 descent (下降): 基线的下部分，字符最低处与 descent 底端可能有空白，由 font-family 决定 xHeight (X 字高): 小写字符 x 的高度，由 font-family 决定 capHeight (顶面高度): 大些字符 P 的高度，由 font-family 决定 lineSpacing (行间距): 在浏览器中一般 lineSpacing = ascent + descent lineHeight （行高）: 默认等于 lineSpacing，受 line-height 设置影响，如果设置 line-height，lineHeight 等于 line-height。 half-leading (半行距): 如果lineHeight &gt; lineSpacing，则lineHeight 与 lineSpacing 之间会产生上下相等的空隙 (lineHeight - lineSpacing) /2 称为半行距（half-leading或 half lead strips）。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"CSS","slug":"编程语言/CSS","permalink":"http://yoursite.com/categories/编程语言/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"字体度量","slug":"字体度量","permalink":"http://yoursite.com/tags/字体度量/"},{"name":"line-height","slug":"line-height","permalink":"http://yoursite.com/tags/line-height/"},{"name":"vertical-align","slug":"vertical-align","permalink":"http://yoursite.com/tags/vertical-align/"}]},{"title":"Promise原理","slug":"Promise","date":"2019-03-08T06:29:37.000Z","updated":"2019-10-10T06:13:03.603Z","comments":true,"path":"2019/03/08/Promise.html","link":"","permalink":"http://yoursite.com/2019/03/08/Promise.html","excerpt":"","text":"笔记 如果一个promise`resolve的是一另一个promise，那么会等待这个promiseresolve或者reject后，再执行then回调或者reject`回调，如下： 1234567891011121314const p = new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve, reject) =&gt; &#123; resolve(1) &#125;)) consol.log(2)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)console.log(p)// 输出结果为Promise &#123;&lt;pending&gt;&#125;21","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"},{"name":"ES6","slug":"编程语言/JavaScript/ES6","permalink":"http://yoursite.com/categories/编程语言/JavaScript/ES6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"Promise原理","slug":"Promise原理","date":"2019-03-08T06:29:37.000Z","updated":"2019-10-10T06:07:35.930Z","comments":true,"path":"2019/03/08/Promise原理.html","link":"","permalink":"http://yoursite.com/2019/03/08/Promise原理.html","excerpt":"","text":"Promise 雏形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Promise(fn) &#123; let callbackList = [] let state = 'pending' let value = null this.then = function(onFulfilled) &#123; return new Promise(resolve =&gt; &#123; // 这里的resolve是then函数新创建的promise对应的resolve函数，与当前promise中的resolve函数不是一个，运用了闭包原理 handler(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;) &#125;) &#125; function handler(callback) &#123; // 如果处于未完成状态 if (state === 'pending') &#123; callbackList.push(callback) // 往当前callbackList队列push新promise对象 return &#125; // 已成功状态 // 如果新的promise对象的onFulfilled为空，即调用then方法时没有正确传入函数，则直接调用promise的resolve函数，并传入then调用链中上一个promise resolve的值 if (!callback.onFulfilled) &#123; callback.resolve(value) return &#125; // 如果新的promise对象的onFulfilled不为空，则调用then方法传入的回调函数，取得函数的返回值，调用promise的resolve函数，传入回调函数的返回值到调用链的下一个then方法中 const ret = callback.onFulfilled(value) callback.resolve(ret) &#125; function resolve(res) &#123; // then中return new Promise()执行拦截 if (res &amp;&amp; (typeof res === 'object' || typeof res === 'function')) &#123; const then = res.then if (typeof then === 'function') &#123; then.call(res, resolve) // res.then(resolve) return &#125; &#125; setTimeout(() =&gt; &#123; state = 'fulfilled' value = res callbackList.forEach((callback, callbackIndex) =&gt; &#123; handler(callback) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 说明这里主要用两个 demo 来解释一下整个 promise 的执行过程 demo11234567891011121314new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) &#125;, 100) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) 执行过程说明： 此处创建了三个 Promise 对象：一个是自己创建的，另外两个是 then 方法创建的 第一次事件循环 执行 Promise 中的方法，把 setTimeout 的回调添加到下个事件循环的事件队列中，new 操作符隐式返回 this 对象（记为 promise1），promise1 的状态为 pending 执行 promise1 的 then 方法，创建 promise2，执行构造 promise2 传入的回调方法时，handler 函数执行的是 promise1 中的 handler 函数，判断 promise1 的状态，此时 promise1 的状态为 pending，把 promise2 push 到 promise1 的 callbackList 队列中，promise1 的 then 方法返回 promise2，promise2 的状态为 pending 执行 promise2 的 then 方法，创建 promise3，执行构造 promise3 传入的回调方法时，handler 函数执行的是 promise2 中的 handler 函数，判断 promise2 的状态，此时 promise2 的状态为 pending，把 promise3 push 到 promise2 的 callbackList 队列中，promise2 的 then 方法返回 promise3，promise3 的状态为 pending 截止到上诉步骤 3，此时 promise1 的 callbackList 中有 promise2，promise2 的 callbackList 中有 promise3，promise3 的 callbackList 为空 第二次事件循环 promise1 的异步方法执行完成，打印 1，往下个事件循环的时间队列中 push callbackList 执行方法 第三次事件循环 开始执行 promise1 的 callbackList，取出 promise2，执行 handler 函数，传入 promise2，此时 promise1 的状态不为 pending，promise2 的 onFulfilled 不为空，执行 onFulfilled 方法，传入 promise1 的 value 值 2，往下个事件循环队列插入回调函数 res=&gt;{setTimeout(()=&gt;{console.log(res)},100)}，返回 undefined，调用 promise2 的 resolve 方法 往下个事件循环的时间队列中 push promise2 的 callbackList 执行方法 第四次事件循环 因为步骤 6 往事件循环中 push 的函数，还没有到执行时机（设置了 100ms，如果设置为 0 会先执行这个），于是执行队列中的下个函数，也就是 promise2 的 callbackList promise2 的状态变为 fulfilled，取出 promise2 callbackList 中的 promise3，此时 promise2 的状态不为 pending，promise3 的 onFulfilled 不为空，执行 onFulfilled 方法，传入 promise2 的返回值 undefine，输出 undefined 在某一事件循环时 100ms 到达，执行步骤 6 的事件，输出 2 所以输出顺序是 1 undefined 2 demo21234567891011121314151617new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) resolve() &#125;, 100) &#125;) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) 执行过程说明： 1-5. 对应上述 1-5 执行 promise2 的 onFulFilled 时，创建了一个中间 promise（mid promise），构造回调传入的参数是 promise2 的 value 值，同样往下个事件循环的事件队列中 push 了 setTimeout 方法，延迟 100ms，但是这时不是返回 undefined，返回的是 mid promise，调用 promise2 的 resolve 方法传入的是 mid promise，命中了 resolve 中的 promise 判断 promise2 resolve 方法中的 pomise 判断命中，并没有往下个事件循环队列中 push promise2 的 callbackList 执行回调，反而调用了 mid promise 的 then 方法，把 promise2 的 resolve 方法作为回调传入 mid promise 的 then 方法执行，创建 promise4，promise4 被 push 到 mid promise 的 callbackList 中，等待 mid promise 被 resolve 在某一事件循环时，假定为 n 100ms 到达，setTimeout 执行，输出 promise2 的 value 值 2，mid promise 被 resolve，mid promise callbackList 被添加到下一个事件循环执行 n+1 次事件循环 mid promise 的 callbackList 中的 promise4 被拿出来执行，而此时的 promise4 的 fulFilled 方法，其实就是 promise2 的 resolve 方法，于是执行 promise2 的 resolve 方法，往下个事件循环的事件队列中 push promise2 的 callbackList 执行回调 n+2 次事件循环 对应上述 9 所以输出顺序为 1 2 undefined 与原Pomise的不一致行为 1234567891011121314new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) &#125;, 0) &#125;) .then(res =&gt; &#123; console.log(res) &#125;)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"},{"name":"ES6","slug":"编程语言/JavaScript/ES6","permalink":"http://yoursite.com/categories/编程语言/JavaScript/ES6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"JS之引擎","slug":"JS之引擎","date":"2019-03-08T06:28:57.000Z","updated":"2019-03-08T06:37:05.490Z","comments":true,"path":"2019/03/08/JS之引擎.html","link":"","permalink":"http://yoursite.com/2019/03/08/JS之引擎.html","excerpt":"","text":"JS引擎之Shapes&amp;Inline Caches原文链接译文链接 JS引擎之V8如何优化prototype原文链接译文链接","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"引擎","slug":"引擎","permalink":"http://yoursite.com/tags/引擎/"}]},{"title":"JS之类型转换","slug":"JS之类型转换","date":"2019-03-08T06:27:50.000Z","updated":"2019-03-08T06:33:29.361Z","comments":true,"path":"2019/03/08/JS之类型转换.html","link":"","permalink":"http://yoursite.com/2019/03/08/JS之类型转换.html","excerpt":"","text":"JS之类型转换文档JavaScript核心概念：类型转换 运算符优先级运算符优先级表 ==运算符的隐式转换原则ECMAScript® 2019 : 7.2.14 Abstract Equality Comparison 规范描述：The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is the same as Type(y) then Return the result of performing Strict Equality Comparison x === y. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y). If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. Return false. \bToNumberECMAScript® 2019 : 7.1.3ToNumber ToPrimitiveECMAScript® 2019 : 7.1.1ToPrimitive ( input [ , PreferredType ] ) The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type[尝试转换为原始对象]. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. Conversion occurs according to the following algorithm[如果对象能够转换为多个基本类型，则可以使用可选提示PreferredType来支持该类型。根据以下算法进行转换]: Assert: input is an ECMAScript language value. If Type(input) is Object, then If PreferredType is not present, let hint be “default”. Else if PreferredType is hint String, let hint be “string”. Else PreferredType is hint Number, let hint be “number”. Let exoticToPrim be ? GetMethod(input, @@toPrimitive). If exoticToPrim is not undefined, then Let result be ? Call(exoticToPrim, input, « hint »). If Type(result) is not Object, return result. Throw a TypeError exception. If hint is “default”, set hint to “number”. Return ? OrdinaryToPrimitive(input, hint). Return input. 1234567891011121314151617181920212223242526272829303132333435363738// Assert: input is an ECMAScript language value.function ToPrimitive (input, PreferredType) &#123; if (typeof input === 'object') &#123; let hint = '' switch (typeof PreferredType) &#123; case 'undefined': hint = 'default' break case 'string': hint = 'string' break default: hint = 'number' &#125; let exoticToPrim = GetMethod(input, @@toPrimitive) if (exoticToPrim !== undefined) &#123; let result = Call(exoticToPrim, input, &lt;&lt; hint &gt;&gt;) if (typeof result !== 'object') &#123; return result &#125; else &#123; throw TypeError() &#125; &#125; if (hint === 'default') &#123; hint = 'number' &#125; return OrdinaryToPrimitive(input, hint) &#125; return input&#125; GetMethodECMAScript® 2019 : 7.3.9GetMethod ( V, P ) The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value when the value of the property is expected to be a function. The operation is called with arguments V and P where V is the ECMAScript language value, P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true. Let func be ? GetV(V, P). If func is either undefined or null, return undefined. If IsCallable(func) is false, throw a TypeError exception. Return func. 123456789101112131415// Assert: IsPropertyKey(P) is true.function GetMethod (V, P) &#123; let func = GetV(V, P) if (func === undefined || func === null) &#123; return &#125; if (!IsCallable(func)) &#123; throw TypeError() &#125; return func&#125; IsPropertyKeyECMAScript® 2019 : 7.2.7IsPropertyKey ( argument ) The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key. If Type(argument) is String, return true. If Type(argument) is Symbol, return true. Return false. 1234567891011function IsPropertyKey (argument) &#123; switch (typeof argument) &#123; case 'string': case 'symbol': return true break default: return false &#125;&#125; GetVECMAScript® 2019 : 7.3.2GetV ( V, P ) The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value. If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type of the value. The operation is called with arguments V and P where V is the value and P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true. Let O be ? ToObject(V). Return ? O.[Get]. 123456// Assert: IsPropertyKey(P) is true.function GetV (V, P) &#123; let O = ToObject(V) return O.[[Get]](P, V)&#125; ToObjectECMAScript® 2019 : 7.1.13ToObject ( argument ) The abstract operation ToObject converts argument to a value of type Object according to below Table: Argument Type Result Undefined Throw a TypeError exception. Null Throw a TypeError exception. Boolean Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. Number Return a new Number object whose [[NumberData]] internal slot is set to argument. String Return a new String object whose [[StringData]] internal slot is set to argument. Symbol Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. Object Return argument. 12345678910111213141516171819202122function ToObject (argument) &#123; if (argument === undefined || argument === null) &#123; throw TypeError() &#125; switch (typeof argument) &#123; case 'boolean': return new Boolean(argument) break case 'number': return new Number(argument) break case 'string': return new String(argument) break case: 'symbol': return Symbol(argument) default: return argument &#125;&#125; IsCallableECMAScript® 2019 : 7.2.3IsCallable ( argument ) The abstract operation IsCallable determines if argument, which must be an ECMAScript language value, is a callable function with a [[Call]] internal method. If Type(argument) is not Object, return false. If argument has a [[Call]] internal method, return true. Return false. 123456789101112function IsCallable (argument) &#123; if (typeof argument !== 'object') &#123; return false &#125; if (typeof argument.__proto__.call === 'function') &#123; return true &#125; return false&#125; CallECMAScript® 2019 : 7.3.12Call ( F, V [ , argumentsList ] ) The abstract operation Call is used to call the [[Call]] internal method of a function object. The operation is called with arguments F, V, and optionally argumentsList where F is the function object, V is an ECMAScript language value that is the this value of the [[Call]], and argumentsList is the value passed to the corresponding argument of the internal method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps: If argumentsList is not present, set argumentsList to a new empty List. If IsCallable(F) is false, throw a TypeError exception. Return ? F.[Call]. 123456789101112function Call (F, V, ...argumentsList) &#123; if (!argumentsList) &#123; argumentsList = [] &#125; if (IsCallable(F)) &#123; throw TypeError() &#125; return F.call(V, argumentsList)&#125; OrdinaryToPrimitiveECMAScript® 2019 : 7.1.1.1OrdinaryToPrimitive ( O, hint ) When the abstract operation OrdinaryToPrimitive is called with arguments O and hint, the following steps are taken: Assert: Type(O) is Object. Assert: Type(hint) is String and its value is either “string” or “number”. If hint is “string”, then Let methodNames be « “toString”, “valueOf” ». Else, Let methodNames be « “valueOf”, “toString” ». For each name in methodNames in List order, do Let method be ? Get(O, name). If IsCallable(method) is true, then Let result be ? Call(method, O). If Type(result) is not Object, return result. Throw a TypeError exception. 123456789101112131415161718192021222324// Assert: Type(O) is Object// Assert: Type(hint) is String and its value is either \"string\" or \"number\"function OrdinaryToPrimitive (O, hint) &#123; let methodNames = ['valueOf', 'toString'] if (typeof hint === 'string') &#123; methodNames = ['toString', 'valueOf'] &#125; methodNames.forEach((name, nameIndex) =&gt; &#123; let method = Get(O, name) if (IsCallable(method)) &#123; let result = Call(method, O) if (typeof result !== 'object') &#123; return result &#125; &#125; &#125;) throw TypeError()&#125; GetECMAScript® 2019 : 7.3.1Get ( O, P ) The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object. Assert: IsPropertyKey(P) is true. Return ? O.[Get]. 123456// Assert: Type(O) is Object.// Assert: IsPropertyKey(P) is true.function Get (O, P) &#123; return O.[[Get]](P, O)&#125; [[Get]][ECMAScript® 2019 : 9.1.8[Get]] ( P, Receiver ) When the [[Get]] internal method of O is called with property key P and ECMAScript language value Receiver, the following steps are taken: Return ? OrdinaryGet(O, P, Receiver). 1234function [[Get]] (P, Receiver) &#123; return OrdinaryGet(O, P, Receiver)&#125; OrdinaryGetECMAScript® 2019 : 9.1.8.1OrdinaryGet ( O, P, Receiver )) When the abstract operation OrdinaryGet is called with Object O, property key P, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true. Let desc be ? O.[GetOwnProperty]. If desc is undefined, then. Let parent be ? O.[GetPrototypeOf]. If parent is null, return undefined. Return ? parent.[Get]. If IsDataDescriptor(desc) is true, return desc.[[Value]]. Assert: IsAccessorDescriptor(desc) is true. Let getter be desc.[[Get]]. If getter is undefined, return undefined. Return ? Call(getter, Receiver).","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"}],"tags":[{"name":"javascript，类型转换","slug":"javascript，类型转换","permalink":"http://yoursite.com/tags/javascript，类型转换/"}]},{"title":"排序算法","slug":"排序算法","date":"2019-03-08T06:23:21.000Z","updated":"2019-07-04T00:26:40.361Z","comments":true,"path":"2019/03/08/排序算法.html","link":"","permalink":"http://yoursite.com/2019/03/08/排序算法.html","excerpt":"","text":"排序算法 冒泡排序12345678910111213141516171819202122232425/*冒泡排序时间复杂度：O(n2)算法介绍：https://blog.csdn.net/shuaizai88/article/details/73250615*/function bubbleSort (arr) &#123; if (!(arr instanceof Array)) &#123; return [] &#125; for (let i = arr.length - 1; i &gt; 0; i--) &#123; for (let j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; let tempNum = arr[j] arr[j] = arr[j - 1] arr[j - 1] = tempNum &#125; &#125; &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]bubbleSort(arr)console.log(arr) 快速排序基数在左边，为什么要从右边先开始查找？ 答：从代码层面分析，因为最后找到的一个数也就是小标为i的数需要与基数对换，而基数在最左边，说明最后一个数会放到最左边，也就是最后一个数必须必基数小，而从右边开始查找的是比基数小的数。 从右侧开始查找终止查找的可能性： 前一次对调结束，j找到i所在位置，此时i是比基数小的，i下标对应的数与基数对换没有问题 前一次对调结束，j找到最后一个数，这个数比基数小，j停止，i开始查找比基数大的数，走到j的位置，i不小于j，停止，i下标对应的数与基数对换没有问题 从左侧开始查找终止查找的可能性： 前一次对调结束，i找到j所在位置，此时i是比基数大的，i下标对应的数与基数对换出错 前一次对调结束，i找到最后一个数，这个数比基数大，i停止，j开始查找比基数小的数，走到i的位置，i不小于j，停止，i下标对应的数与基数对换出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*快速排序时间复杂度：O(N*logN)算法介绍：http://developer.51cto.com/art/201403/430986.htm*/function quickSort (_left, _right, _arr) &#123; if (!(_arr instanceof Array)) &#123; return &#125; if (_left &gt;= _right) &#123; return &#125; let baseNum = _arr[_left] let i = _left let j = _right while (i !== j) &#123; while (_arr[j] &gt;= baseNum &amp;&amp; i &lt; j) &#123; j-- &#125; while (_arr[i] &lt;= baseNum &amp;&amp; i &lt; j) &#123; i++ &#125; if (i &lt; j) &#123; let tempNum = _arr[i] _arr[i] = _arr[j] _arr[j] = tempNum &#125; &#125; _arr[_left] = _arr[i] _arr[i] = baseNum console.log(_arr) quickSort(_left, i - 1, _arr) quickSort(i + 1, _right, _arr)&#125;let arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]// let arr = [5, 80, 55, 40, 42, 85]quickSort(0, arr.length - 1, arr)console.log(arr) 插入排序123456789101112131415161718192021222324252627282930/*插入排序时间复杂度：最好：O(n) 最坏O(n2)算法介绍：https://www.cnblogs.com/hapjin/p/5517667.html*/function insertSort (arr) &#123; if (!(arr instanceof Array)) &#123; return [] &#125; const arrLen = arr.length for (let i = 1; i &lt; arrLen; i++) &#123; let tempNum = arr[i] for (let j = 0; j &lt; i; j++) &#123; if (arr[i] &lt; arr[j]) &#123; arr.splice(i, 1) arr.splice(j, 0, tempNum) break &#125; &#125; &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]insertSort(arr)console.log(arr) 选择排序123456789101112131415161718192021222324252627282930/*选择排序时间复杂度：O(n2)算法介绍：https://www.cnblogs.com/shen-hua/p/5424059.html*/function selectionSort (arr) &#123; if (!(arr instanceof Array)) &#123; console.error('param type is not array!') return [] &#125; for (let i = 0; i &lt; arr.length; i++) &#123; let minNumIndex = i let tempNum = arr[i] for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minNumIndex]) &#123; minNumIndex = j &#125; &#125; arr[i] = arr[minNumIndex] arr[minNumIndex] = tempNum &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]selectionSort(arr)console.log(arr)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}],"tags":[{"name":"算法，排序","slug":"算法，排序","permalink":"http://yoursite.com/tags/算法，排序/"}]},{"title":"VueRouter之打开新的标签页","slug":"VueRouter之打开新的标签页","date":"2019-03-08T06:20:37.000Z","updated":"2019-03-08T06:21:24.623Z","comments":true,"path":"2019/03/08/VueRouter之打开新的标签页.html","link":"","permalink":"http://yoursite.com/2019/03/08/VueRouter之打开新的标签页.html","excerpt":"","text":"router-link添加target=”_blank”属性 window.open 12const &#123; href &#125; = this.$router.resolve(location, current ?, append ?) // 解析目标位置window.open(href, '_blank')","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"},{"name":"window.open","slug":"window-open","permalink":"http://yoursite.com/tags/window-open/"}]},{"title":"Vue之清空表单","slug":"Vue之清空表单","date":"2019-03-08T06:16:02.000Z","updated":"2019-03-08T06:17:56.726Z","comments":true,"path":"2019/03/08/Vue之清空表单.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之清空表单.html","excerpt":"","text":"简单的的表单如果所有表单控件都处于当前页面，不包含组件，且都是双向绑定的数据，则清空值就行了 复杂的表单如果表单包含组件级别的控件，层级较深，可以使用一种hack的手段，通过v-if重新渲染组件，清空组件内input里的值，选中的复选框等等，同时将页面内的相关数据清空就行了，如图所示：","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"form","slug":"form","permalink":"http://yoursite.com/tags/form/"}]},{"title":"Vue之改变路由页面回到顶部","slug":"Vue之改变路由页面回到顶部","date":"2019-03-08T06:11:30.000Z","updated":"2019-03-08T06:15:11.019Z","comments":true,"path":"2019/03/08/Vue之改变路由页面回到顶部.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之改变路由页面回到顶部.html","excerpt":"","text":"问题描述vue是单页应用，通过改变hash值来实现不同页面之前的跳转，当一个页面滚动到底部时，然后跳转到另一个也面，同样会在页面底部，并不会回到顶部 vue-router scrollBehavior当创建一个router实例时，可以提供一个scrollBehavior方法控制路由跳转时页面滚动条的位置 123456const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // return 期望滚动到哪个的位置 &#125;&#125;) 具体的使用方法点这里，但是该方法只在支持history.pushState的浏览器中可用，移动端不存在问题，pc端IE10+以上，因此对pc端的解决方法进行了探索 vue-router beforeEach&amp;afterEach中回到顶部操作存在的问题123router.afterEach((to, from, next) =&gt; &#123; document.documentElement.scrollTop = 0&#125;) 以上方法在跳转页面时页面会闪烁一下，原因是因为dom的更新操作在触发afterEach的回调函数之后进行，也就是所触发afterEach函数的时候，页面的dom其实还是旧的页面的dom，所以当设置滚动条的位置时，会在旧页面先回到顶部，再更新成新页面的dom，下面是vue-router完整的导航解析流程： 利用定时器利用定时器将更改滚动条位置的操作放入到macrotasks事件队列末尾，即在更新dom操作之后就可以解决页面闪烁的问题了 12345router.afterEach((to, from, next) =&gt; &#123; setTimeout(() =&gt; &#123; document.documentElement.scrollTop = 0 &#125;, 0)&#125;) 还有一个问题是，当刷新当前页面的时候，浏览器会记录当前页面滚动条，并在刷新页面后将滚动条的位置恢复到刷新页面之前，测试了两种浏览器，表现不一致： chrome：先回到页面顶部-&gt;再回到刷新之前位置，导致页面闪烁 firefox：回到页面顶部 为了解决上述问题，需要对刷新页面的时候进行额外处理，不回到页面顶部，可以根据afterEach回调函数的from参数来判断，当刷新页面或第一次进入页面时，from.name为null： 12345router.afterEach((to, from, next) =&gt; &#123; from.name &amp;&amp; setTimeout(() =&gt; &#123; document.documentElement.scrollTop = 0 &#125;, 0)&#125;)","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"}]},{"title":"video标签使用v-show播放失败","slug":"video标签使用v-show播放失败","date":"2019-03-08T06:06:52.000Z","updated":"2019-03-08T06:10:20.423Z","comments":true,"path":"2019/03/08/video标签使用v-show播放失败.html","link":"","permalink":"http://yoursite.com/2019/03/08/video标签使用v-show播放失败.html","excerpt":"","text":"video source src 异步赋值播放失败如图所示，v-show控制video标签是否显示，showVideo初始值为false，模拟接口异步返回视频链接，然后改变视频的src，但此时视频没有成功播放，Network中也没有去加载对应的视频资源 Why?大家都知道v-show控制的css的visibility属性，实际上无论v-show的值是true或者false都会去渲染dom，可见，视频播放失败跟v-show并没有多大的关系，于是我们把v-show去了验证一下： 同样，视频也播放失败，并且Network中也没有视频资源的加载记录，由此可推断，当video中存在source标签的时候，浏览器渲染之后会自动去加载src对应的资源，后续即便地址改变，浏览器也不会再去获取资源 解决方法 src属性添加到video标签上 使用v-if替代v-show，触发dom重排 触发video的load方法","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"video","slug":"video","permalink":"http://yoursite.com/tags/video/"},{"name":"v-show","slug":"v-show","permalink":"http://yoursite.com/tags/v-show/"}]},{"title":"Vue之Dom复用","slug":"Vue之Dom复用","date":"2019-03-08T05:53:19.000Z","updated":"2019-03-08T06:08:24.780Z","comments":true,"path":"2019/03/08/Vue之Dom复用.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之Dom复用.html","excerpt":"","text":"问题描述 如上图所示，页面中通过遍历数组循环出n个组件，并传入msg值在组件中显示，点击删除按钮时，触发父组件的方法，删除该组件，在页面中我们进行如下操作： 在3个输入框中依次输入1，2，3 点击第二个删除按钮 成功删除组件，但最终效果并不是我们所期望的下图中的样子 Why ？Vue组件复用问题，这个问题涉及到Vue的diff算法，这里只做简单概述，如果想要详细了解，请参考文档Vue diff算法原理，Vue为了使得更新dom时更加的有效率，在更新数据后，重新渲染dom时，会对比同层dom节点的类型（标签类型或自定义组件类型）是否相同，如果相同，则直接复用之前的组件，只进行数据的更新，放到这个例子里，说白了，当前剩下的两个输入框组件其实是之前3个中的前2个，因为msg是通过prop传入到子组件的，所以当改变arr数组时，触发dom更新，虽然复用了之前的2个组件，但传入的prop是会改变的，但因为input框是存在于子组件本身，并没有依赖父元素的值，所以input框里的值是不会变的 :key=”index”存在的问题很多人为了规避编辑器的错误提示，会在循环时加上:key=”index”，这并没有改变vue的diff算法，与没加的效果是一样的，所有组件内的值都需要重新渲染一次： 如上图所示，第一次遍历arr时，arr中的3个值1,2,3对应的arrIndex的分别是0，1，2，当删除第二个组件时，arr为[1,3]，重新遍历渲染时，1，3对应的arrIndex分别为0，1，相当于复用了之前arrIndex为0，1的两个组件，也就是跟没加:key=”index”所产生的效果是相同的，这就是为什么加了:key=”arrIndex”还是无法达到我们所期望的效果 :key=”唯一id”这种情况下，可以给arr中的每一项生成一个不可变的唯一id，则删除时，就能根据唯一id去准确的找到其之前所对应的dom了，达到准确复用","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"深入浅出NodeJs（读书笔记）","slug":"深入浅出NodeJs（读书笔记）","date":"2019-03-08T05:36:14.000Z","updated":"2019-03-08T05:49:02.478Z","comments":true,"path":"2019/03/08/深入浅出NodeJs（读书笔记）.html","link":"","permalink":"http://yoursite.com/2019/03/08/深入浅出NodeJs（读书笔记）.html","excerpt":"","text":"第一章 Node简介 在Node中，绝大多数的操作都是以异步的方式进行调用 Node相比于其它大多数后端语言的独特之处：事件驱动、异步、回调函数 Node保持了JS在浏览器中单线程的特点。在Node中，JS与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换带来的性能上的开销。单线程的弱点： 无法利用多核CPU 错误会引起整个应用退出，应用的健壮性值得考验 大量计算占用CPU导致无法继续调用异步I/O Node的应用场景： I/O密集型：从单线程的角度来说，Node处理I/O的能力是值得竖起拇指称赞的。通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集型的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少 CPU密集型：CPU密集型应用给Node带来的挑战主要是：由于JS单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可以同事享受到并行异步I/O的好处，又能充分利用CPU 身为单线程的应用，Node如何能够充分的利用CPU? Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现 通过创建子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU Node使用者的各自倚重点： 前后端编程语言环境统一 Node带来的高性能I/O用于实时应用 并行I/O使得使用者可以更高效的利用分布式环境 并行I/O，有效利用稳定接口提升Web渲染能力 云计算平台提供Node支持 游戏开发领域 工具类应用 第二章 模块机制 在Web1.0时代，对于JS自身而言，它的规范是薄弱的，存在以下缺陷： 没有模块系统 标准库较少 没有标准接口 缺乏包管理系统 CommonJS规范 模块引用：var mathModule = require(‘mathModule’) 模块导出：exports.add = function (x, y) { return x + y } Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，在Node中引入模块，需要经历如下3个步骤： 路径分析 文件定位 编译执行 在Node中模块分为两类： 核心模块：核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的 文件模块：是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢 与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。 模块标识符分析 模块表示符的分类： 核心模块，如https、fs、path等 .或..开始的相对路径文件模块 以/开始的绝对路径文件模块 非路径形式的文件模块，如自定义的connect模块 Node模块加载顺序：核心模块 &gt; 文件模块 &gt; 自定义模块（需要按照module.paths路径一层层向上寻找，直到找到目标文件或系统根目录为止） CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。 模块编译，每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上 12345678910111213// 在Node中，每个文件模块都是一个对象，它的定义如下function Module(id, parent) &#123; this.id = id this.exports = &#123;&#125; this.parent = parent if (parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null this.loaded = false this.children = []&#125; 对于不同的文件扩展名，模块载入的方法也有所不同 .js文件：通过fs模块同步读取文件后编译执行 .node文件：这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件 .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果 其余扩展名文件：它们都被当做.js文件载入 npm install -g是将一个包安装为全局可用的可执行命令 前端模块化 CommonJS：CommonJS用同步的方式加载模块，在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载 AMD：异步模块定义，采用异步的方式加载模块，模块的加载不影响后面语句的执行，依赖前置，提前执行，定义模块时要对其依赖进行声明 CMD：通用模块定义，依赖就近，在需要时进行引入，延迟执行（并不是延迟加载），相对于AMD，更贴近CommonJS规范和Node Modules规范 ES6 Module，与CommonJS模块的差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载” 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 第三章 异步I/O 为什么要异步I/O，这与Node面向网络而设计不无关系，具体到实处，从以下两个方面说起： 用户体验：在浏览器中，JS在单线程上执行，且与UI渲染共用一个线程，这意味着当JS执行的时候，UI的渲染和响应是处于停滞状态的。如果网页需要临时获取一个资源，通过同步的方式获取，这期间UI将停顿，不响应用户的交互行为，可以想象，这样的用户体验将会多差。而采用异步请求，在资源的下载期间，JS和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。前端可以通过异步消除掉UI阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度，例如：两个资源获取耗时为M、N，如果采用同步方式耗时为M+N，异步方式则为Max(M, N)，因此只有后端能够快速响应资源，才能让前端的体验编号。 资源分配：多线程的代价在于创建线程和执行期线程上下文切换的开销较大，另外，在复杂的业务中，多线程编程经常面临着锁和状态同步的问题。单线程的缺点在于性能，同步的编程模型导致的问题是，任意一个略慢的任务都会导致后续执行代码被阻塞，着造成资源不能被更好的利用。操作系统会将CPU的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升影响能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组人物而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间会比较长。因此，Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU。为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中的Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。 从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事 操作系统内核对于I/O只有两种方式： 阻塞I/O：调用之后一定要等到系统内核层面完成所有操作后，调用才结束，造成CPU等待I/O，浪费等待事件，CPU的处理能力不能得到充分利用 非阻塞I/O：调用之后立即返回非阻塞I/O返回之后，CPU的时间片可以用力处理其他事物，此时的性能提升是明显的。但非阻塞I/O也存在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层渴望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询 阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完成完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费 轮询技术： read select poll epoll：该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高 kqueue：该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在 非阻塞I/O对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU幺妹用于遍历文件描述符的状态，要么用于休眠等待事件发生，对于当前线程而言利用率不够，理想的异步I/O是应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务。采用多线程的方式，通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O。 Node是单线程的，这里的单线程仅仅只是JS执行在单线程中罢了。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池 Node的异步I/O 事件循环：在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者：每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件，一个观察者里可能有多个事件，在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事情的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者哪里，事件循环则从观察者那里取出事件并处理。在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。 请求对象：从JS发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理 执行回调：线程池中的I/O操作调用完毕之后，会将结果存储在请求对象（req-&gt;result）属性上，然后通知IOCP，告知当前对象操作以完成。在每次Tick的执行中，它会调用IOCP相关的方法检查线程池中是否有执行完成的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JS中传入的回调函数的目的。事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 非I/O的异步API 定时器：调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒。 process.nextTick()：相当于setTimeout(fn, 0)，而由于时间循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。实际上，process.nextTick()方法的操作相对较为轻量。每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。 setImmediate()：setImmediate()方法与procee.nextTick()方法十分类似，都是将回调函数延迟执行。process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。在具体实现上，process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。之所以这样设计，是为了保证每次每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O调用的情况。 服务器模型： 同步式：对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多 每线程/每请求：为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销。知名服务器Nginx，也摒弃了多线程的方式，采用了和Node相同的事件驱动，不同之处在于Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。 第四章 异步编程 函数式编程 高阶函数：可以把函数作为参数，或是将函数作为返回值的函数 偏函数：通过指定部分参数来产生一个新的定制函数的形式就是偏函数 异步编程优势：Node带来的最大特效莫过于基于事件驱动的非阻塞I/O模型，非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。利用事件循环的方式，JS线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，这个模型的缺点则在于管家无法承担过多的细节性任务，如果承担太多，则会影响到任务的调度，管家忙个不停，小二却得不到活干，结局则是整体效率的降低。换言之，Node是为了解决编程模型中阻塞I/O性能问题的，采用了单线程模型，这导致Node更像一个处理I/O密集型的能手，而CPU密集型则取决于管家的能耐如何。由于事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的CPU时间片。至于是计算密集型，还是I/O密集型，只要计算不影响异步I/O的调度，那就不构成问题。建议对CPU的耗用不要超过10ms，或者将大量的计算分解为诸多的小量计算，通过setImmediate()进行调度。只要合理利用Node的异步模型和V8的高性能，就可以充分发挥CPU和I/O资源的优势。 异步编程的难点： 异常处理：过去我们处理异常时，通常使用类Java的try/catch/final语句块进行异常捕获。但是这对于异步编程不一定适用。第3章提到过，异步I/O的实现主要包含两个阶段：提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用。 12345678910var async = function (callback) &#123; process.nextTick(callback)&#125;// 只能捕获当次事件循环内的异常，对callback执行时抛出的异常无能为力try &#123; async(callback)&#125; catch (e) &#123; // TODO&#125; Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出： 123async(function (err, results) &#123; // TODO&#125;) 在我们自行编写的异步方法上，也需要去遵循这样一些原则： 原则1：必须执行调用者传入的回调函数 原则2：正确传递回异常供调用者判断 函数嵌套过深：对于Node而言，事务中存在多个异步调用的场景比比皆是，函数嵌套过深导致代码难以阅读 阻塞代码：Node中没有sleep()这样的线程沉睡功能，唯独能用于延时操作的只有setTimeout()和setInterval()这两个函数。但是这两个函数并不能阻塞后续代码的执行。所以，有多半开发者会写出下述这样的代码来实现sleep(1000)的效果： 12345var start = new Date()while (new Date() - start &lt; 1000) &#123; // TODO&#125;// 需要阻塞的代码 但是事实是糟糕的，这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于为这段代码服务，导致其余任何请求都会得不到响应。 遇见这样的需求时，在同一规划业务逻辑之后，调用setTimeout()的效果会更好。 多线程编程：JS运行在单线程之上，没有充分利用多核CPU，浏览器采用Web Workers，Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。 异步转同步 异步编程解决方案： 事件发布/订阅模式：Node自身提供events模块，它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的时间监听模式的方法实现。值得一提的是，Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的。下面为两个具体的细节点： 如果对一个事件添加了超过10个侦听器，将会得到一个警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏。调用emitter.setMaxListeners(0)，可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了异常处理，EventEmitter对象对error事件进行了特殊对待。如果允许期间的错误触发了error事件，EventEmitter会检查是否有队error事件添加过侦听器。如果添加了，这个错误将会交由改侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该多error事件做处理。 继承events模块 123456var events = require('events')function Stream() &#123; events.EventEmitter.call(this)&#125;util.inherits(Stream, events.EventEmitter) 利用事件队列解决雪崩问题：所谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。 以下是一条数据库查询语句的调用： 12345var select = function (callback) &#123; db.select('SQL', function (results) &#123; callback(results) &#125;)&#125; 如果站点刚好启动，这时缓存中是不存在数据的，而如果访问量巨大，同一句SQL会被发送到数据库中反复查询，会影响服务的整体性能。一种改进方案是添加一个状态锁，相关代码如下： 123456789101112var status = 'ready'var select = function (callback) &#123; if (status !== 'ready') &#123; return &#125; status = 'pending' db.select('SQL', function (results) &#123; status = 'ready' callback(results) &#125;)&#125; 但是在这种情况下，连续地多次调用select()时，只有第一次调用是生效的，后续的select()是没有数据服务的，这个时候可以引入事件队列，相关代码如下： 123456789101112131415var proxy = new events.EventEmitter()var status = 'ready'var select = function (callback) &#123; proxy.once('selected', callback) if (status !== 'ready') &#123; return &#125; status = 'pending' db.select('SQL', function (results) &#123; proxy.emit('selected', results) status = 'ready' &#125;)&#125; 此处可能因为存在侦听器过多引发警告，需要调用setMaxListeners(0)移除警告，或者设置更大的警告阈值 多异步之间的协作方案 这里我们尝试通过原生代码解决“难点2”中为了最终结果的处理而导致可以并行调用但实际只能串行执行的问题。这里以渲染页面所需要的模板读取、数据读取和本地化资源读取为例简要介绍一下，相关代码如下： 1234567891011121314151617181920var count = 0var results = &#123;&#125;var done = function (key, value) &#123; results[key] = value count++ if (count === 3) &#123; render(results) &#125;&#125;fs.readFile(template_path, 'utf8', function (err, template) &#123; done('template', template)&#125;)db.query(sql, function (err, data) &#123; done('data', data)&#125;)l10n.get(function (err, resources) &#123; done('resources', resources)&#125;) 由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量。这里可以利用偏函数来处理哨兵变量和第三方函数的关系，相关代码如下： 1234567891011121314var after = function (times, callback) &#123; var count = 0 var results = &#123;&#125; return function (key, value) &#123; results[key] = value count++ if (count === times) &#123; callback(results) &#125; &#125;&#125;var done = after(3, render) 上述方案实现了多个事件对应一个侦听器的目的。如果业务继续增长，我们依然可以继续利用发布/订阅方式来完成多对多的方案，相关代码如下： 123456789101112131415var emitter = new events.Emitter()var done = after(times, render)emitter.on('done', done)emitter.on('done', other)fs.readFile(template_path, 'utf8', function (err, template) &#123; emitter.emit('done', 'template', template)&#125;)db.query(sql, function (err, data) &#123; emitter.emit('done', 'data', data)&#125;)l10n.get(function (err, resources) &#123; emitter.emit('done', 'resources', resources)&#125;) 在上面的方法中，有一个令调用者不那么舒服的问题，那就是调用者要去准备这个done()函数，以及在回调函数中需要从结果把数据一个个提取出来，再进行处理。 另一个方案则是来自于笔者自己写的EventProxy模块，相关代码如下： 123456789101112131415var proxy = new EventProxy()proxy.all('template', 'data', 'resources', function (template, data, resource) &#123; //TODO&#125;)fs.readFile(template_path, 'utf8', function (err, template) &#123; proxy.emit('template', template)&#125;)db.query(sql, function (err, data) &#123; proxy.emit('data', data)&#125;)l10n.get(function (err, resources) &#123; proxy.emit('resources', resources)&#125;) Promise/Deferred模式：使用事件的方式，执行流程需要被预先设定。Promise/Deferred模式可以先执行异步调用，延迟传递处理方 12345678910111213// 普通Ajax调用$.get('/api', &#123; success: onSuccess, error: onError, complete: onComplete&#125;)// Promise/Deferred模式$.get('/api') .success(onSuccess) .success(onSuccess1) .error(onError) .complete(onComplete) 这使得即使不调用success()、error()等方法，Ajax也会执行，并且可以处理多个回调 Promise/Deferred模式发布在CommonJS规范中，CommonJS草案目前已经抽象出了Promises/A、Promises/B、Promises/D这样典型的异步Promise/Deferred模型 Promises/A： Promise/A提议对单个异步操作做出了这样的抽象定义： Promise操作只会处在3种状态的一种：未完成态、完成态和失败态 Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化 Promise的状态一旦转化，将不能被更改在API的定义上，一个Promise对象只要具备then()方法即可。对于then()方法，有以下要求： 接受完成态、错误态的回调方法 可选地支持progress事件回调作为第三个方法 then()方法只接受function对象，其余对象将被忽略 then()方法继续返回Promise对象，以实现链式调用then()方法定义如下： 1then(fulfilledHandler, errorHandler, progressHandler) 为了演示Promises/A提议，这里我们尝试通过继承Node的events模块来完成一个简单的实现，相关代码如下： 123456789101112131415161718192021var Promise = function () &#123; EventEmitter.call(this)&#125;util.inherits(Promise, EventEmitter)Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; if (typeof fulfilledHandler === 'function') &#123; // 利用once方法，保证成功回调只执行一次 this.once('success', fulfilledHandler) &#125; if (typeof errorHandler === 'function') &#123; this.once('error', errorHandler) &#125; if (typeof progressHandler === 'function') &#123; this.on('progress', progressHandler) &#125; return this&#125; 这里看到then()方法所做的事情就是将回调函数存放起来。为了完成整个流程，还需要触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred，即延迟对象，实例代码如下： 123456789101112131415161718var Deferred = function () &#123; this.state = 'unfulfilled' this.promise = new Promise()&#125;Deferred.prototype.resolve = function (obj) &#123; this.state = 'fulfilled' this.promise.emit('success', obj)&#125;Deferred.prototype.reject = function (err) &#123; this.state = 'failed' this.promise.emit('error', err)&#125;Deferred.prototype.progress = function (data) &#123; this.promise.emit('progress', data)&#125; Promise中的多异步协作 1234567891011121314151617181920Deferred.prototype.all = function (promises) &#123; let count = promises.length let results = [] const that = this promises.forEach(function (promise, i) &#123; promise.then(function (data) &#123; count-- results[i] = data if (count === 0) &#123; that.resolve(results) &#125; &#125;, function (err) &#123; that.reject(err) &#125;) &#125;) return this.promise&#125; Promise的进阶知识 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 让promise支持链式调用var Deferred = function () &#123; this.promise = new Promise()&#125;// 完成态Deferred.prototype.resolve = function (obj) &#123; var promise = this.promise var handler while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.fulfilled(obj)) &#123; var ret = handler.fulfilled(obj) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 失败态Deferred.prototype.reject = function (obj) &#123; var promise = this.promise var handler while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.error(obj)) &#123; var ret = handler.error(obj) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 生成回调函数Deferred.prototype.callback = function () &#123; var that = this return function (err, file) &#123; if (err) &#123; return that.reject(err) &#125; that.resolve(file) &#125;&#125;var Promise = function () &#123; // 队列用于存储待执行的回调函数 this.queue = [] this.isPromise = true&#125;Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; var handler = &#123;&#125; if (typeof fulfilledHandler === 'function') &#123; handler.fulfilled = fulfilledHandler &#125; if (typeof errorHandler === 'function') &#123; handler.error = errorHandler &#125; this.queue.push(handler) return this&#125;// 验证var readFile1 = function (file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;var readFile2 = function (file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;readFile1('file1.txt', 'utf8') .then(function (file1) &#123; return readFile2(file1.trim(), 'utf8') &#125;) .then(function (file2) &#123; console.log(file2) &#125;) 要让Promise支持链式执行，主要通过以下两个步骤： 将所有回调都存到队列中 Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象promise引用改变为新的Promise对象，并将队列中余下的回调转交给它 将API Promise化 123456789var smooth = function (method) &#123; return function () &#123; var deferred = new Deferred() var args = Array.prototype.slice.call(arguments, 1) args.push(deferred.callback()) method.apply(null, args) return deferred.promise &#125;&#125; 流程控制库： 尾触发与Next 1234567891011121314151617181920212223242526272829303132333435363738function offWork(data, next) &#123; console.log('上班ing。。。') setTimeout(function() &#123; console.log('下班了。。。') next('传给下个任务的数据') &#125;, 1000)&#125;function backHome(data, next) &#123; console.log('上个任务传过来的数据为：' + data) setTimeout(function() &#123; console.log('到家了！！！') next('传给下个任务的数据') &#125;, 1000) console.log('回家ing。。。')&#125;App = &#123; handles: [], use: function(handle) &#123; if (typeof handle == 'function') App.handles.push(handle) &#125;, next: function(data) &#123; var handlelist = App.handles var handle = null var _next = App.next if ((handle = handlelist.shift()) != undefined) &#123; handle.call(App, data, _next) &#125; &#125;, start: function(data) &#123; App.next(data) &#125;&#125;App.use(offWork)App.use(backHome)App.start() async：流程控制模块 无依赖异步的串行执行：async.series(asyncFnArray, callback) 依赖异步的串行执行：async.waterfall(asyncFnArray, callback) 异步的并行执行：async.parallel(asyncFNArray, callback) 自动依赖处理：async.auto(depsArray) Step：流程控制模块 依赖异步的串行执行：this 并行执行任务：this.parallel() 结果分组：this.group() wind：$await使得代码看起来像同步的代码 async/await 流程控制小结：事件发布/订阅模式相对算是一种较为原始的方式，Promise/Deferred模式贡献了一个非常不错的异步任务模型的抽象。而上述的这些异步流程控制方案与Promise/Deferred模式的思路不同，Promise/Deferred的重头在于封装异步的调用部分，流程控制库则显得没有模式，将处理重点放置在回调函数的注入上。从自由度上来讲，async、Step这类流控库相对灵活得多。 异步并发控制：异步并发量过大，会导致服务器崩溃。 bagpipe的解决方案： 通过一个队列来控制并发量 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行 如果活跃调用达到限定值，调用暂时存放在队列中 每个异步调用结束时，从队列中取出新的异步调用执行 async的解决方案：parallelLimit() 第五章 内存控制 V8对内存的使用进行了限制 V8的对象分配：在V8中，所有的JS对象都是通过堆来进行分配的，Node提供了process.memoryUsage()方法查看内存使用量，V8同样限制了堆的使用大小，表层原因是因为V8最初为浏览器设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制。按官方的说话，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JS线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。当然，这个限制也不是不能打开，Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小 V8的垃圾回收机制：V8的垃圾回收策略主要基于分代式垃圾回收机制，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法 V8的内存分代：在V8中，主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，上述的–max-old-space-size和–max-new-space-size分别对应设置老生代和新生代内存的大小，老生代内存在64位系统和32位系统下分别只能使用约1.4GB和约0.7GB的大小，对于新生代内存，它由两个reserved_semispace_size_所构成，按机器位数的不同，reserved_semispace_size_在64位系统和32位系统下分别为16MB和8MB的大小，所以新生代内存的最大值在64位系统和32位系统上分别为32MB和16MB，V8堆内存的最大保留空间为：4 * reserved_semispace_size_ + ax-old-space-size_，因此，默认情况下，V8堆内存的最大值在64位系统上为1464MB，32位系统上则为732MB。 Scavenge算法：在分代的基础上，新生代对中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：将新生代内存堆等分为两个semispace，一个为From，另一个为To，当垃圾回收开始时，会从From空间中拷贝存活的对象到To空间，而非存活对象的空间将会被释放，完成复制后，From空间和To空间的角色发生对换。在一定条件下，需要将存货周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制（25%）。 Mark-Sweep：标记清除，Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 Mark-Compact：标记整理，为了解决Mark-Sweep的内存碎片问题。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。 Mark-Sweep &amp; Mark-Compact两者结合：由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact Incremental Marking：为了避免出现JS应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用程序，对于新生代来说，默认配置得较小，且其中存活对象通常较少，全停顿（stop-the-world）的影响不大。但老生代通常配置的较大，且存活对象较多，全堆垃圾回收的标记、清理、整理等动作造成的停顿会比较可怕，因此，V8引入了增量标记、并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。 V8的垃圾回收机制分为新生代和老生代。 新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。 老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。 高效使用内存 如果变量是全局变量（不通过var声明或定义在global变量上），其引用对象常驻在内存中（老生代中），可通过delete操作来删除引用关系或者将变量重新赋值，在接下来的老生代内存清除和整理过程中，会被回收释放。在V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好 闭包 Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。利用堆外内存可以突破内存限制，例如，Buffer对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。 内存泄漏 通常，造成内存泄漏的原因有如下几个： 缓存 队列消费不及时 作用域未释放 缓存限制策略：采用LRU算法的缓存失效策略 直接将内存作为缓存使用，除了限制缓存的大小外，另外要考虑的事情是，进程之前无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身部存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。它的好处很多，在Node中主要可以解决以下两个问题： 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效 进程之间可以共享缓存 大内存应用： stream模块 Buffer操作 第六章 理解Buffer Buffer对象类似于数组，用于操作字节，它的元素为16进制的两位数，即0到255的数值 Buffer内存分配 采用slab分配机制，slab是一种动态内存管理机制，简单而言，slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态： full：完全分配状态 partial：部分分配状态 empty：没有被分配状态 Node以8KB为界限来区分Buffer是大对象还是小对象，Buffer.poolSize = 8 * 1024，这个8KB的值也就是每个slab的大小值，在JS层面，以它作为单位单元进行内存的分配 真正的内存是在Node的C++层面提供的，JS层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JS到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作 Buffer的转换 字符串转Buffer：new Buffer(str, [encoding])、buf.write(string, [offest], [length], [encoding]) Buffer转字符串：buf.toString([encoding], [start], [end]) Buffer不支持的编码类型：可通过iconv、icon-lite模块进行转换 Buffer的拼接：Buffer在使用场景中，通常是以一段一段的方式传输 12345678910var fs = require('fs')var rs = fs.createReadStream('test.md')var data = ''rs.on('data', function (chunk) &#123; data += chunk // 隐藏了toString()操作，等价于data = data.toString() + chunk.toString()&#125;)rs.on('end', function () &#123; console.log(data)&#125;) 上述代码对于英文，toString()不会造成任何问题，但对于宽字节的中文，却会形成问题，中文字在UTF-8下占3个字节，当这3个字节分部在上述代码中的不同chunk时，会造成这3个字节以乱码的形式呈现， setEncoding()与string_decoder()：可读流可通过readable.setEncoding(encoding)设置编码方式，让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。事实上，在调用setEncoding()时，可读流对象在内部设置了一个decoder对象，StringDecoder在得到编码后，知道宽字节字符在UTF-8编码下是以3个字节的方式存储的，所以当输出时不满足3个字符的条件时，会将剩余字符和后续输出的字符合并，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了，但是它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码 正确拼接Buffer 12345678910111213141516171819202122232425262728293031323334353637383940414243var chunks = []var size = 0res.on('data', function (chunk) &#123; chunks.push(chunk) size += chunk.length&#125;)res.on('end', function () &#123; var buf = Buffer.concat(chunks, size) var str = iconv.decode(buf. 'utf8') console.log(str)&#125;)Buffer.concat = function (list, length) &#123; if (!Array.isArray(list)) &#123; throw new Error('Usage: Buffer.concat(list, [lenght])') &#125; if (list.length === 0) &#123; return new Buffer(0) &#125; if (list.length === 1) &#123; return list[0] &#125; if (typeof length !== 'number') &#123; length = 0 for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i] length += buf.length &#125; &#125; var buffer = new Buffer(length) var pos = 0 for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i] buf.copy(buffer, pos) pos += buf.length &#125; return buffer&#125; Buffer与性能 在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转化为Buffer，以进行二进制数据传输，字符串与Buffer的转换有性能损耗，在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。 在文件的读取时，有一个highWaterMark设置对性能的影响至关重要，主要有两个影响的点： highWaterMark设置对Buffer内存的分配和使用有一定影响，当读取一个相同的大文件时，highWaterMark值越大，读取速度越快 highWaterMark设置过小，可能导致系统调用次数过多 第七章 网络编程 Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客服端。 TCP的服务事件：服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象 服务器事件 listening：在调用server.listen()绑定端口或者Domain Socket后触发，简介写法为server.listen(port, listeningListener)，通过listen()方法的第二个参数传入 connection：每个客户端套接字埒街道服务器端时触发，简洁写法为通过net.createServer()，最后一个参数传递 close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件 error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常 连接事件（socket） data：当一端用write()发送数据时，另一端会触发data事件，事件传递的数据即使write()发送的数据 end：当连接中的任意一端发送了FIN数据时，将会触发该事件 connect：该事件用于客户端，当套接字与服务端连接成功时会被触发 drain：当任意一端调用write()发送数据时，当前这端会触发该事件 error：当异常发生时，触发该事件 timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前连接已经被闲置了另外，由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器： 123456var net = require('net')var server = net.createServer(function (socket) &#123; socket.write('Echo server\\r\\n') socket.pipe(socket)&#125;) 值得注意的是，TCP针对网络中小的数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓存区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送 在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDealy(true)去掉Nagle算法，使得write()可以立即发送数据到网络中 另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件 构建UDP服务：UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即使基于它实现的。 UDP套接字事件 message：当UDP套接字侦听到网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息 listening：当UDP套接字开始侦听时触发该事件 close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可 error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出 构建HTTP服务：在Node中，HTTP服务继承自TCP服务器（net模块），http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接传来的数据，调用二级制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。 HTTP请求 req.method req.url req.httpVersion HTTP响应 设置报文头信息：res.setHeader，可以调用多次进行设置，但是只有调用writeHead后，报头才会写入到连接中，除此之外，http模块会自动帮你设置一些头信息 设置报文体信息：res.write()和res.end()，后者与前者的差别在于res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不再生效。这由协议的特效决定。另外，无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用res.end()结束请求，否则客户端将一直处于等待的状态。 HTTP服务的事件 connection：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。 request：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。 close：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。 checkContinue：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。 connect：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭。 upgrade：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接受到这样的请求时触发该事件。如果不监听该事件，发起请求的连接将会关闭。 clientError：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。 构建HTTP客户端：http.request(options, connect) options参数决定了这个HTTP请求头中的内容，它的选项有如下这些 host：服务器的域名或IP地址，默认为localhost hostname：服务器名称 port：服务器端口，默认为80 localAddress：建立网络连接的本地网卡 socketPath：Domain套接字路径 method：HTTP请求方法，默认为GET path：请求路径，默认为/ headers：请求头对象 auth：Basic认证，这个值将被计算成请求头中的Authorization部分报文体的内容由请求对象的write()和end()方法实现：通过write()方法向连接中写入数据，通过end()方法告知报文结束。它与浏览器中的Ajax调用几近相同，Ajax的实质就是一个异步的网络HTTP请求。 HTTP响应：HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。后续响应报文体以只读流的方式提供。 HTTP代理：为了重用TCP连接，http模块包含了一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务端发起的HTTP请求最多可以创建5个连接。它的实质是一个连接池。调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后猜真正发出。可在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5。 1234567891011var agent = new http.Agent(&#123; maxSockets: 10&#125;)var options = &#123; hostname: '127.0.0.1', port: 1334, path: '/', method: 'GET', agent: agent&#125; 也可以设置agent选项为false值，以多里连接池的管理，使得请求不受并发限制。 Agent对象的sockets和requests属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数，在业务中监视着两个值有助于发现业务状态的繁忙程度。 HTTP客户端事件 response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。 socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事情。 connect：当客户端向服务器端发送CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。 upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。 continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。 构建WebSocket服务 WebSocket服务与Node之间的配合堪称完美，其理由有两条： WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几 WebSocket实现了客户端与服务端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。 WebSocket与传统HTTP有如下好处： 客户端与服务器端只建立一个TCP连接，可以使用更少的连接 WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效 有更轻量级的协议头，减少数据传送量 在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet（彗星）技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或超时后重新发起请求。 WebSocket协议主要分为两个部分：握手和数据传输 WebSocket握手 客户端建立连接时，通过HTTP发起请求报文，如下所示： 123456GET /chat HTTP/1.1HOST: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Sec-WebSocket-Version: 13 与普通的HTTP请求协议略有区别的部分在于如下这些协议头： 12Upgrade: websocketConnection: Upgrade 上述两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验 Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端。这个算法如下所示： 12var crypto = require('crypto')var val = crypto.createHash('sha1').update(key).digest('base64') 另外，下面两个字段指定子协议和版本号： 12Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 服务器端处理完请求后，响应如下报文： 12345HTTP/1.1 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接字连接上应用新协议。剩余的字段分别表示服务器端基于Sec-WebSocket-Key生成的字符串和选中的子协议。客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输。 WebSocket数据传输 在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换 为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦受到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧无需做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。 网络服务与安全 在网景公司的NetScape浏览器推出之初就提出了SSL(Secure Sockets Layer，安全套阶层)。SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为TLS(Transport Layer Security，安全传输层协议) Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，SHA！、MD5等加密算法都在其中有体现。真正用于网络的是另外两个模块，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上。 TLS/SSL 密钥：TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密。 Node在底层采用的是openssl实现TLS/SSL 数字证书：为了确保数据安全，引入了一个第三方：CA(Certificate Authority，数字证书认证中心)。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。 为了得到签名证书，服务器端需要通过自己的私钥生成CSR(Certificate Signing Request，证书签名请求)文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。 通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书。 客户端在发起安全连接前会去获取服务器端的证书，并通过CA的证书验证服务器端的证书的真伪。除了验证真伪外，通常还含有对服务器名称、IP地址等进行验证的过程。 TLS服务：与普通的TCP服务器端和客户端相比，TLS的服务器端和客户端仅仅只在证书的配置上有差别，其余部分基本相同，在Node中，通过tls模块搭建TLS服务。 HTTPS服务：HTTPS服务就是工作在TLS/SSL上的HTTP 第八章 构建Web应用 基础功能 请求方法 12345678910111213141516function (req, res) &#123; switch (req.method) &#123; case 'POST': update(req, res) break case 'DELETE': remove(req, res) break case 'PUT': create(req, res) break case 'GET': default: get(req, res) &#125;&#125; 路径解析：客户端代理（浏览器）会将这个地址解析成报文，将路径和查询部分放在报文第一行。需要注意的是，hash部分会被丢弃，不会存在于报文的任何地方。 根据路径去查找磁盘中的文件，然后将其响应给客户端 123456789101112function (req, res) &#123; const pathname = url.parse(req.url).pathname fs.readFile(path.join(ROOT, pathname), function (err, file) &#123; if (err) &#123; res.writeHead(404) res.end('找不到相关文件。- -') return &#125; res.writeHead(200) res.end(file) &#125;)&#125; 根据路径来选择控制器 123456789101112131415// request url: /controller/action/a/b/cfunction (req, res) &#123; const pathname = url.parse(req.url).pathname const paths = pathname.split('/') const controller = paths[1] || 'index' const action = paths[2] || 'index' const args = path.slice(3) if (handles[controller] &amp;&amp; handles[controller][action]) &#123; handles[controller][action].apply(null, [req, res].concat(args)) &#125; else &#123; rew.writeHead(200) res.end('找不到响应控制器') &#125;&#125; 这样我们的业务部分可以只关心具体的业务实现，如下所示： 12345handles.index = &#123;&#125;handles.index.index = function (req, res, foo, bar) &#123; res.writeHead(200) res.end(foo)&#125; 查询字符串 查询字符串位于路径之后，在地址栏中路径后的?foo=bar&amp;baz=val字符串就是查询字符串。这个字符串会跟随在路径后，形成请求报文首行的第二部分。这部分内容经常需要为业务逻辑所用，Node提供了queryString模块用于处理这部分数据，如下所示： 1234const url = require('url')const querystring = require('querystring')const query = querystring.parse(url.parse(req.url).query)// const query = url.parse(req.url, true).query 要注意的点是，如果查询字符串中的键出现多次，那么它的值会是一个数组 Cookie Cookie的处理分为如下几步： 服务器向客户端发送Cookie 浏览器将Cookie保存 之后每次浏览器都会将Cookie发向服务器端 解析Cookie 1234567891011121314function parseCookie (cookie) &#123; let cookies = &#123;&#125; if (!cookie) &#123; return cookies &#125; let list = cookie.split(';') for (let i = 0; i &lt; list.length; i++) &#123; let pair = list[i].split('=') cookies[pair[0].trim()] = pair[1] &#125; return cookies&#125; 服务器通过Set-Cookie字段往客户端写入Cookie 1Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; 其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项： path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。 Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器是会丢失掉这个Cookie。Expires的值是一个UTC格式的时间字符串，是绝对时间，如果客户端和服务器端的时间不匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间。 HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HTTPOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。 Secure：当Secure为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。Cookie序列化成符合规范的字符串 12345678910111213function serialize (name, val, opt) &#123; var pairs = [name + '=' + encode(val)] opt = opt || &#123;&#125; if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge) if (opt.domain) pairs.push('Domain=' + opt.domain) if (opt.path) pairs.push('Path=' + opt.path) if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString()) if (opt.httpOnly) pairs.push('HttpOnly') if (opt.secure) pairs.push('Secure') return pairs.join('; ')&#125; Cookie的性能影响：由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成带宽的部分浪费。在YSlow的性能优化有规则中有这么一条： 减小Cookie的大小：更严重的情况是，如果在域名的根节点设置Cookie，几乎所有子路径下的请求都会带上这些Cookie，这些Cookie在某些情况下是有用的，但是在有些情况下是完全无用的。其中以静态文件最为典型，静态文件的业务定位几乎不关心状态，Cookie对它而言几乎是无用的，但是一旦有Cookie设置到相同域下，它的请求中就会带上Cookie。好在Cookie设计时限定了它的域，只有域名相同时才会发送。所以YSlow中有另外一条规则用来避免Cookie带来的性能影响。 为静态组件使用不同的域名：简而言之就是，为不需要Cookie的组件换个域名可以实现减少无效Cookie的传输。所以很多网站的静态文件会有特别的域名，使得业务相关的Cookie不再影响静态资源。当然换用额外的域名带来的好处不只这点，还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。但是换用额外域名还是有一定的确定的，那就是将域名转换为IP需要进行DNS查询，多一个域名就多一次DNS查询。YSlow中有这样一条规则： 减少DNS查询：看起来减少DNS查询和使用不同的域名是冲突的两条规则，但是好在现今的浏览器都会进行DNS缓存，以削弱这个副作用的影响 Session 如何将每个客户和服务器中的数据一一对应起来？ 第一种：基于Cookie来实现用户和数据的映射 虽然将所有数据都放在Cookie中不可取，但是将口令放在Cookie中还是可以的。因为口令一旦被篡改，就丢失了映射关系，也无法修改服务器端存在的数据了。并且Session的有效期通常较短，普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。那么口令是如何参数的呢？ 一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomact会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值时唯一且不重复的值，并设定超时时间 第二种：通过查询字符串来实现浏览器端和服务器端数据的对应 它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值得URL，然后形成跳转，让客户端重新发起请求， 有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须再响应时设置Cookie。但是这种方案带来的风险源大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑之后无法生效，相对较为安全。 还有一种比较有趣的处理Session的方式是利用HTTP请求头中的ETag，同样对于更换浏览器和电脑后也是无效的。 Session与内存 Session数据直接存于内存中会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频繁扫描，引起性能问题。 另一个问题则是我们可能为了利用多核CPU而启动了多个进程。用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。 为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解。 采用第三方缓存来存储Session引起的一个问题是会引起网络访问。理论上来说访问网络中的数据要比访问本地磁盘中的数据速度还要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，尽管如此但依然会采用这些高速缓存的理由有以下几条： Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化 高速缓存直接在内存中进行数据存储和访问 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度影响较小 Session与安全 从前文可以知道，尽管我们的数据都放置在后端了，使得它能保障安全，但是无论通过Cookie，还是查询字符串的实现方式，Session的口令依然保存在客户端，这里会存在口令被盗用的情况。如果Web应用的用户十分多，自行设计的随机算法的一些口令值就有理论机会命中有效的口令值。一旦口令被伪造，服务器端的数据也可能间接被利用。 有一种做法是将这个口令通过私钥加密进行签名，使得伪造的成本较高。客户端尽管可以伪造口令值，但是由于不知道私钥值，签名信息很难伪造。如此，我们只要在响应时将口令和签名进行对比，如果签名非法，我们将服务器端的数据立即过期即可。 这样一来，即使攻击者知道口令中.号前的值时服务器端Session的ID值，只要不知道secret私钥的值，就无法伪造签名信息，以此实现对Session的保护。 当然，将口令进行签名是一个很好的解决方案，但是如果攻击者通过某种方式获取了一个真实的口令和签名，他就能实现身份的伪装。一种方案是将客户端的某些独有信息和口令作为原值，然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包括用户IP和用户代理（User Agent）。 缓存 YSlow中提到了几条关于缓存的规则 添加Expires或Cache-Control到报文头中 配置ETags 让Ajax可缓存通常来说，POST、DELETE、PUT这类待行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中 Basic认证：Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段的值由认证方式和加密值构成。在Basic认证中，它会将用户和密码部分组合，然后进行Base64编码，如果用户首次访问该网页，URL地址中页没携带认证内容，那么浏览器会响应一个401未授权的状态码。响应头中的WWW-Authenticate字段告知浏览器采用什么样的认证和加密方式。当认证通过，服务器端响应200状态码之后，浏览器会保存用户名和密码口令，在后续的请求中都携带式Authorization信息。 Basic认证有太多的缺点，它虽然经过Base64加密后在网络中传送，但是这近乎于明文，十分危险，一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它。 为了改进Basic认证，RFC 2069规范提出了摘要访问认证，它加入了服务器端随机数来保护认证过程 数据上传 通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容 123function hasBody (req) &#123; return 'transfer-encoding' in req.headers || 'content-length' in req.headers&#125; 表单数据 12345&lt;form action=\"/upload\" method=\"post\"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; Content-Type: application/x-www-form-urlencode 报文体内容跟查询字符串相同：foo=bar&amp;baz=val 123456var handle = function (req, res) &#123; if (req.headers['content-type'] === 'application/x-www-form-urlencoded') &#123; req.body = querystring.parse(req.rawBody) &#125; todo(req, res)&#125; JSON Content-Type: application/json; charset=utf-8 1234567891011121314151617var mime = function (req) &#123; var str = req.headers['content-type'] || '' return str.split(';')[0]&#125;var handle = function (req, res) &#123; if (mime(req) === 'application/json') &#123; try &#123; req.body = JSON.parse(req.rawBody) &#125; catch (e) &#123; res.writeHead(400) res.end('Invaild JSON') return &#125; &#125; todo(req, res)&#125; XML Content-Type: application/xml; charset=utf-8 123456789101112131415var xml2js = require('xml2js')var handle = function (req, res) &#123; if (mime(req) === 'application/xml') &#123; xml2js.parseString(req.rawBody, function (err, xml) &#123; if (err) &#123; res.writeHead(400) res.end('Invaild XML') return &#125; req.body = xml todo(req, res) &#125;) &#125;&#125; 附件上传 12345&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;label for=\"file\"&gt;Filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 浏览器在遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的如下所示： 12Content-Type: multipart/form-data; boundary=AaB03xContent-Legnth: 18231 它代表本次提交的内容是由多部分构成的，其中的boundary=AaB03x指定的是每部分内容的分界符，AaB03x是随机生成的一段字符串，报文体的内容将通过在它前面添加–进行分科，报文结束时在它前后都加上–表示结束。另外，Content-Length的值必须确保是报文体的长度。 一旦我们知晓报文是如何构成的，那么解析它就变得十分容易。值得注意的一点是，由于是文件上传，那么像普通表单、JSON或XML那样先接受内容再解析的方式将变得不可接受。接收未知的数据量时，我们需要十分谨慎，如下所示： 1234567891011121314151617function (req, res) &#123; if (hasBody(req)) &#123; var done = function () &#123; handle(req, res) &#125; if (mime(req) === 'application/json') &#123; parseJSON(req, done) &#125; else if (mime(req) === 'application/xml') &#123; parseXML(req, done) &#125; else if (mime(req) === 'multipart/form-data') &#123; parseMultipart(req, done) &#125; &#125; else &#123; handle(req, res) &#125;&#125; 这里我们将req这个流对象直接交给对应的解析方法，由解析方法自行处理上传的内容，或接收内容并保存在内存中，或流式处理掉。 这里要介绍的模块是formidable。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示： 1234567891011121314151617var formidable = require('formidable')function parseMultipart (req, res) &#123; if (hasBody(req)) &#123; if (mime(req) === 'multipart/form-data') &#123; var form = new formidable.IncomingForm() form.parse(req, function (err, fields, files) &#123; req.body = fields req.files = files handle(req, res) &#125;) &#125; else &#123; handle(req, res) &#125; &#125;&#125; 数据上传与安全 内存限制 在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。攻击者通过客户端能够十分容易地模拟伪造大量数据，如果攻击者每次提交1MB的内容，那么只要并发请求数量一大，内存就会很快地被吃光。 要解决这个问题主要有两个方案： 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据流式处理在上文的文件上传中已经有所体现，这里介绍一下Connect中采用的上传数据量的限制方式，如下所示： 12345678910111213141516171819202122232425var bytes = 1024function (req, res) &#123; var received = 0 var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null // 如果内容超过长度限制，返回请求实体过长的状态码 if (len &amp;&amp; len &gt; bytes) &#123; res.writeHead(413) res.end() return &#125; // limit req.on('data', function (chunk) &#123; received += chunk.length if (received &gt; bytes) &#123; // 停止接收数据，触发end() req.destroy() &#125; &#125;) handle(req, res)&#125; CSRF CSRF的全称是Cross-Site Request Forgery，中文意思是跨站请求伪造，攻击者引诱某个domain_a的登录用户访domain_b的网站，在domain_b的网站中请求domain_a的资源会把domain_a的Cookie发送到服务器，尽管这个请求时来自domain_b的，但是服务器并不知情，用户也不知情。 路由解析 文件路径型 静态文件：URL的路径与网站目录的路径一致，无须转换。处理过程将请求路径对应的文件发送给客户端即可。 动态文件：Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并传入HTTP请求的上下文。解析器执行脚本，并输出响应报文，达到完成服务的目的。现今大多数的服务器都很智能地根据后缀同时服务动态和静态文件。这种方式在Node中不太常见，主要原因是文件的后缀都是.js，分不清是后端脚本，还是前端脚本，这可不是什么好的设计。而且Node中Web服务器与应用业务脚本是一体的，无须按这种方式实现。 MVC MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种： 控制器（Controller)，一组行为的集合 模型（Model），数据相关的操作和封装 视图（View)，视图的渲染这是目前最为经典的分层模式，大致而言，它的工作模式如下说明： 路由解析，根据URL寻找到对应的控制器和行为 行为调用相关的模型，进行数据操作 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端路由映射方法： 手工映射 优点：手工映射除了需要手工配置路由较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制 缺点：如果项目较大，路由映射的数量也会很多。从前端路径到具体的控制文件，需要查阅才能定位到实际代码的位置 自然映射： 优点：路由按照一种约定的方式自然而然地实现了路由，无须去维护路由映射 缺点：如果URL变动，它的文件也需要发生变动 RESTful REST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看做一个资源，并表现在URL上。 比如一个用户的地址如下所示： 1/users/jacksontian 这个地址代表了一个资源，对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上。过去我们队用户的增删改查或许是如下这样设计URL的： 1234POST /user/add?username=jacksontianGET /user/remove?username=jacksontianPOST /user/update?username=jacksontianGET /user/get?username=jacksontian 操作行为主要体现在行为上，主要使用的请求方法是POST和GET。在RESTful设计中，它是如下这样的： 1234POST /user/jacksontianDELETE /user/jacksontianPUT /user/jacksontianGET /user/jacksontian 它将DELETE和PUT请求方法引入设计中，参与资源的操作和更改资源的状态 在RESTful设计中，资源的具体格式由请求报头中Accept字段和服务器端的支持情况来决定。如果客户端同时接受JSON和XML格式的响应，那么它的Accept字段值是如下这样的： 1Accept: application/json,application/xml 在响应报文中，通过Content-Type告知客户端是什么格式 所以REST的设计就是，通过URL设计资源、请求方法定义资源的操作，通过Accept决定资源的表现形式 （中间件的具体实现请查看8.4）中间件：对于Web应用的各种基础功能，我们通过中间件来完成，每个中间件处理掉相对简单的逻辑，最终汇成强大的基础框架 异常处理 中间件与性能 编写高效的中间件 使用高效的方法。必要时通过jsperf.com测试基准性能。 缓存需要重复计算的结果（需要控制缓存用量） 避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要 合理使用路由 页面渲染 内容响应：内容响应的过程中，响应报头中的Content-*字段十分重要 MIME：浏览器正式通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值。MIME的全称是Multipurpose Internet Mail Extensions。不同的文件类型具有不同的MIME值，为了方便获知文件的MIME值，社区有专有的mime模块可以用来判断文件类型。 附件下载 Content-Disposition: attachment; filename=”filename.ext”；告知客户端将报文数据作为可下载的附件 Content-Disposition: inline；告知客户端将报文数据当做即使浏览的内容 响应JSON 12345res.json = function (json) &#123; res.setHeader('Content-Type', 'application/json') res.writeHead(200) res.end(JSON.stringify(json))&#125; 响应跳转 12345res.redirect = function (url) &#123; res.setHeader('Location', url) res.writeHead(302) res.end('Redirect to' + url)&#125; 视图渲染 BigPipe：将页面分割成多个部分，先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。这个过程中需要前端JS的参与，它负责将后续输出的数据渲染到页面上 第九章 玩转进程 Node存在的问题 如何充分利用多核CPU服务器：如今CPU基本均是多核的，真正的服务器（非VPS）往往还有多个CPU。而单进程单线程的结构只能利用一个核 如何保证进程的健壮性核稳定性：由于Node执行在单线程上，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃 多进程架构 Master-Worker模式：又称为主从模式，在这种模式中进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度和管理工作进程，它是趋向于稳定的。工作进程负责具体的业务助理。 创建子进程 spawn()：启动一个子进程来执行命令 exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它由一个回调函数获知子进程的状况 execFIle()：启动一个子进程来执行科执行文件 fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JS文件模块即可 spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程允许超过设定的时间将会被杀死。 |类型|回调/异常|进程类型|执行类型|可设置超时||spawn()|x|任意|命令|x||exec()|✔️|任意|命令|✔️||execFile()|✔️|任意|可执行文件|✔️||fork()|x|Node|JS文件|x| 这里的可执行文件是指可以直接执行的文件，如果是JS文件通过execFile()运行，它的首行内容必须添加如下代码： 1#!/usr/bin/env node 尽管4种创建子进程的方式有些差别，但事实上后面3种方法都是spawn()的延伸应用 进程间通信 通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息 12345678910111213141516// parent.jsvar cp = require('child_process')var n = cp.fork(__dirname + '/sub.js')n.on('message', function (m) &#123; console.log('Parent got message:', m)&#125;)n.send(&#123; hello: 'world' &#125;)// sub.jsprocess.on('message'， function (m) &#123; console.log('Child got message:', m)&#125;)process.send(&#123; foo: 'bar' &#125;) 进程间通信原理 IPC的全称是Inter-Process Communication，即进程间通信。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术。但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道（named pipe）实现，*nix系统则采用Unix Domain Socket实现。 父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程的连接。 建立连接之后的父子进程就可以自由地通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网络socket的行为比较类似，属于双向通信。在Node中，IPC通道被抽象为Stream对象，在调用send()发送数据（类似于write()）接收到的消息会通过message事件（类似于data）触发给应用层。 只有启动的子进程是Node进程时，子进程才会根据环境变量去连接IPC通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的IPC通道。 句柄传递 通过代理，主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上。这样，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。 为了解决上述这样的问题，Node引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄，如下所示： 1child.send(message, [sendHandle]) 那什么是句柄？句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。 发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。文件描述符浪费的问题可以通过这样的方式轻松解决。 123456789101112131415161718192021222324252627// parent.jsvar cp = require('child_process')var child1 = cp.fork('child.js')var child2 = cp.fork('child.j2')var server = require('net').createServer()server.listen(1337, function () &#123; child.send('server', server) child.send('server', server) // 关掉 server.close()&#125;)// child.jsvar http = require('http')var server = http.createServer(function (req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;) res.end('handled by child, pid is ' + process.id + '\\n')&#125;)process.on('message', function (m, tcp) &#123; if (m === 'server') &#123; tcp.on('connection', function (socket) &#123; server.emit('connection', socket) &#125;) &#125;&#125;) 句柄发送与还原 上文介绍的虽然是句柄发送，但是仔细看看，句柄发送跟我们直接将服务器对象发送给子进程有没有差别？它是否真的将服务器对象发送给了子进程？为什么它可以发送到多个子进程中？发送给子进程为什么父进程中还存在这个对象？ 目前子进程对象send()方法可以发送的句柄类型包括如下几种： net.Socket。TCP套接字。 net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。 net.Native。C++层面的TCP套接字或IPC管道。 dgram.Socket。UDP套接字。 dgram.Native。C++层面的UDP套接字。 send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示： 12345&#123; cmd: 'NODE_HANDLE', type: 'net.Server', msg: message&#125; 发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。 连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cm的值如果以NODE_为前缀，它将响应一个内部事件internalMessage。如果message.cmd的值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。 端口共同监听 在了解了句柄传递背后的原理后，我们继续探究为何通过发送句柄后，多个进程可以监听到相同的端口而不引起EADDRINUSE异常。其答案也很简单，我们独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。 Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用 由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时会失败。但对于send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同的端口不会引起异常。 多个应用监听相同的端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的。 集群稳定之路 问题 性能问题 多个工作进程的存活状态管理 工作进程的平滑重启 配置或者静态数据的动态重新载入 其他细节 进程事件 error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。 exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法杀死的，会得到第二个参数，它表示杀死进程时的信号。 close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。 disconnect：在父进程或子进程中调用disconnect()方法式触发该事件，在调用该方法时将关闭监听IPC通道。 自动重启： 一旦有未捕获的异常出现，工作进程就会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的exit后，将会立即启动新的进程服务，以此保证整个集群中总是有进程在为用户服务的。 自杀信号 上述过程存在的问题是要等到已有的连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，全处在等待退出的状态。但在等到进程完全退出在重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，这回丢掉大部分请求。 为此需要改进这个过程，不能等到工作进程退出后才重启新的工作进程。当然也不能暴力退出进程，因为这样会导致已连接的用户之间断开。于是我们在退出的流程中增加一个自杀（suicide）信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。 这里存在问题的是有可能我们的连接是长连接，不是HTTP服务的这种短连接，等待长连接断开可能需要较久的时间。为此为已有的连接的断开设置一个超时时间是必要的。 进程中如果出现未能捕获的异常，就意味着有那么一段代码在健壮性上是不合格的。为此退出进程前，通过日志记录下问题所在是必须要做的事情，它可以帮我们很好地定位和追踪代码异常出现的位置。 限量重启 通过自杀信号告知主进程可以使得新连接总是有进程服务，但是依然还是有极端的情况。工作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误，会导致工作进程被频繁重启，这种频繁重启不属于我们捕捉未知异常的情况，因为这种短时间内频繁重启已经不符合预期的设置，极有可能是程序编写的错误。 为了消除这种无意义的重启，在满足一定规则的限制下，不应当反复重启。比如在单位时间内规定只能重启多少次，超过限制就触发giveup事件，告知放弃重启工作进程这个重要事件。 负载均衡 Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。 一般而言，这种抢占式策略对大家是公平的，各个进程可以根据自己的繁忙度来进行抢占。但是对于Node而言，需要分清的是它的繁忙是有CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多的请求，形成负载不均衡的情况。 为此Node在V0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其以此分发给工作的进程。分发的策略是在N个工作进程中，每次选择第i=(i + 1) mod n个进程来发送连接。 状态共享 解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如Redis)中，所有工作进程启动时将其读取进内存中。但这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。 实现状态同步的机制有两种： 各个子进程去向第三方进行定时轮询 创建一个通知进程，这个进程设计为值进行轮询和通知，不处理任何业务逻辑。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。 Cluster模块 12345678910var cluster = require('cluster')cluster.setupMaster(&#123; exec: 'workter.js'&#125;)var cpus = require('os').cpus()for (var i = 0; i &lt; cpus.length; i++) &#123; cluster.fork()&#125; 执行上述代码将会得到与前文创建子进程集群的效果相同。就官方的文档而言，它更喜欢如下的形式作为示例： 1234567891011121314151617181920var cluster = require('cluster')var http = require('http')var numCPUs = require('os').cpus().lengthif (cluster.isMaster) &#123; // Fork workers for (var i = 0; i &lt; numCPUs; i++) &#123; cluster.fork() &#125; cluster.on('exit', function (worker, code, signal) &#123; console.log('worker' + worker.process.pid + ' died') &#125;)&#125; else &#123; // Workers can share any TCP connection http.createServer(function (req, res) &#123; res.writeHead(200) res.end('hello world\\n') &#125;).listen(8000)&#125; 在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID，如下所示： 12cluster.isWorker = ('NODE_UNIQUE_ID' in process.env)cluster.isMaster - (cluster.isWorker === false) Cluster工作原理 事实上cluster模块就是child_process和net模块的组合应用。cluster启动时，它会在内部启动TCP服务器，在cluster.fork()子进程时，将这个TCP服务器端socket的文件描述符发送给工作进程。如果进程是通过cluster.fork()复制出来的，那么它的环境变量就存在NODE_UNIQUE_ID，如果进程中存在listen()侦听网络端口的调用，它们将拿到该文件描述符，通过SO_REUSEADDR端口重用，从而实现多个子进程共享端口。对于普通方式启动的进程，则不存在文件描述符传递共享等事情。 在cluster内部隐式创建TCP服务器的方式对使用者来说十分透明，但也正是这种方式使得它无法入直接使用child_process那样灵活。在cluster模块应用中，一个主进程只能管理一组工作进程。 对于自行通过child_process来操作时，则可以更灵活地控制工作进程，甚至控制多组工作进程。其原因在于自行通过child_process操作子进程时，可以隐式地创建多个TCP服务器，使得子进程可以共享多个的服务器端socket。 Cluster事件 fork：复制一个工作进程后触发该事件。 online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。 listening：工作进程中调用listen()（共享了服务端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件 exit：有工作进程退出时触发该事件。 setup：cluster.setupMaster()执行后触发该事件 第十章 测试 单元测试 编写可测试代码有以下几个原则可以遵循 单一职责 接口抽象 层次分离 单元测试介绍 断言 在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标识程序开发者预期的结果——当程序运行到断言的位置时，对应的断言应该为真。若断言不为真，程序会中止运行，并出现错误信息。 assert模块 ok()：判断结果是否为真。 equal()：判断实际值与期望值是否相等。 notEqual()：判断实际值与期望值是否不相等。 deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。 notDeepEqual()：判断实际值与期望值是否不深度相等。 strictEqual()：判断实际值与期望值是否严格相等（相当于===）。 notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==)。 throws()：判断代码块是否抛出异常。 doesNotThrow()：判断代码块是否没有抛出异常。 ifError()：判断实际值是否为一个假值（null、undefined、0、’’、false），如果实际值为真值，将会抛出异常。 测试框架：mocha 测试风格：我们将测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，他们的差别如下： 关注点不同：TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。 表达方式不同：TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯。 123456789101112131415161718192021222324252627// BDDdescribe('Array', function () &#123; // 提供了before、after、beforeEach、afterEach钩子方法 before (function () &#123; // ... &#125;) describe('#indexOf()', function () &#123; it('should return -1 when not present', function () &#123; [1, 2, 3].indexOf(4).should.equal(-1) &#125;) &#125;)&#125;)// TDDsuite('Array', function () &#123; // 提供了setup、teardown钩子方法 setup (function () &#123; // ... &#125;) suite('#indexOf()', function () &#123; test('should return -1 when not present', function () &#123; assert.equal(-1, [1, 2, 3].indexOf(4)) &#125;) &#125;)&#125;) 测试报告 测试代码的文件组织：测试代码存在于test目录中 测试用例 一个测试用例中包含至少一个断言。示例代码如下： 1234567891011describe('#indexOf()', function () &#123; it('should return -1 when not present', function () &#123; [1, 2, 3].indexOf(4).should.equal(-1) &#125;) it('should return index when present', function () &#123; [1, 2, 3].indexOf(1).should.equal(0) [1, 2, 3].indexOf(2).should.equal(1) [1, 2, 3].indexOf(3).should.equal(2) &#125;)&#125;) 测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注。 异步测试 由于Node环境的特殊性，异步调用非常常见，这也带来了异步代码在测试方面的跳转。在其他典型编程语言中，如Java、Ruby、Python，代码大多是同步执行的，所以测试用例基本上只要包含一些断言检查返回值即可。但是在Node中，检查方法的返回值毫无意义，并且不知道回调函数具体何时调用结束，这将导致我们在对异步调用进行测试时，无法调度后续测试用例的执行。 所幸，mocha解决了这个问题。一下为fs模块中readFile的测试用例 123456it('fs.readFile should be ok', function (done) &#123; fs.readFile('file_path', 'utf-8', function (err, data) &#123; should.not.exist(err) done() &#125;)&#125;) 在上述代码中，测试用例方法it()接受两个参数；用例标题和回调函数。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行。 超时设置 mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例。 mocha的默认超时时间为2000毫秒。一般情况下，通过Mocha -t &lt;ms&gt;设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置，示例代码如下： 1234it('should take less than 500ms', function (done) &#123; this.timeout(500) setTimeout(done, 300)&#125;) 也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例： 12345678910describe('a suit of tests', function () &#123; this.timeout(500) it('should take less than 500ms', function (done) &#123; setTimeout(done, 300) &#125;) it('should take less than 500ms as well', function (done) &#123; setTimeout(done, 200) &#125;)&#125;) 测试覆盖率 通过统计每一行代码是否执行来得知测试用例对源码的覆盖率 blanket模块 123456789// 只需在所有测试用例之前通过--require选项引入它即可mocha --require blanket -R html-cov &gt; coverage.html// 在包描述文件(package.json)文件中配置scripts节点，pattern属性用以匹配需要编译的文件\"scripts\": &#123; \"blanket\": &#123; \"pattern\": \"eventproxy/lib\" &#125;&#125; mock 前面提到开发者常常会遗漏掉一些异常案例，其中想当一部分原因在于异常的情况较难实现。大多异常与输入数据并无绝对的关系，比如数据库的异步调用，除了输入异常外，还有可能是网络异常、权限异常等非输入数据相关的情况，这相对难以模拟。 以下面代码为例，文件系统的异常时绝对不容易呈现的，为了测试代码的健壮性而专程调节磁盘上的权限等，成本略高： 1234567exports.getContent = function (filename) &#123; try &#123; return fs.readFileSync(filename, 'utf-8') &#125; catch (e) &#123; return '' &#125;&#125; 为了解决这个问题，我们通过伪造fs.readFileSync()方法抛出错误来触发异常。同时为了保证该测试用例不影响其余用例，我们需要在执行完后还原它。为此，前面提到的before()和after()钩子函数派上了用场，相关代码如下： 12345678910111213141516describe('getContent', function () &#123; var _readFileSync before(function () &#123; _readFileSync = fs.readFileSync fs.readFileSync = function (filename, encoding) &#123; throw new Error('mock readFileSync error') &#125; &#125;) // it() after(function () &#123; fs.readFileSync = _readFileSync &#125;)&#125;) 我们在执行测试用例前将引用替换掉，执行结束后还原它。如果每个测试用例执行前后都要进行设置和还原，就使用beforeEach()和afterEach()这两个钩子函数。 由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk，示例代码如下： 1234567891011121314var fs = require('fs')var muk = require('muk')before(function () &#123; muk(fs. 'readFileSync', function (path, encoding) &#123; throw new Error('mock readFileSync error') &#125;)&#125;)// it()after(function () &#123; muk.restore()&#125;) 值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步 1234567891011// errorfs.readFile = function (filename, encoding, callback) &#123; callback(new Error('mock readFile error'))&#125;// goodfs.readFile = function (filename, encoding, callback) &#123; process.nextTick(function () &#123; callback(new Error('mock readFile error')) &#125;)&#125; 私有方法的测试 对于Node而言，又一个难点会出现在单元测试的过程中，那就是私有方法的测试，这在第2章中介绍过。只有挂载在exports或module.exports上的变量或方法才可以被外部通过require引入访问，其余方法只能在模块内部被调用和访问。 rewrite模块提供了一种巧妙的方式实现对私有方法的访问 1234567891011// 源代码var limit = function (num) &#123; return num &lt; 0 ? 0 : num&#125;// 测试用例it('limit should return success', function () &#123; var lib = rewrite('../lib/index.js') var limit = lib.__get__('limit') litmit(10).should.be.equal(10)&#125;) rewrite的诀窍在于它引入文件时，像require一样对原始文件做了一定的手脚。除了添加(function(exports, require, module, filename, dirname){)和});的头尾包装外，它还注入了部分代码，具体如下所示： 12345678910(function (exports, require, module, __filename, __dirname) &#123; var method = function () &#123;&#125; exports.__set__ = function (name, value) &#123; eval(name ' = ' value.toString()) &#125; exports.__get__ = function (name) &#123; return eval(name) &#125;&#125;) 每一个被rewrite引入的模块都有set()和get()方法。它巧妙利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行。 工程化和自动化 性能测试 基准测试 基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距。 这里介绍benchmark这个模块是如何组织基准测试的，相关代码如下： 12345678910111213141516171819var Benchmark = require('benchmark')var suite = new Benchmark.Suite()var arr = [0, 1, 2, 3, 5, 6]suite.add('nativeMap', function () &#123; return arr.map(callback)&#125;).add('customMap', function () &#123; var ret = [] for (var i = 0; i &lt; arr.length; i++) &#123; ret.push(callback(arr[i])) &#125; return ret&#125;).on('cycle', function (event) &#123; console.log(String(evnet.target))&#125;).on('complete', function () &#123; console.log('Fastest is ' + this.fileter('fastest').pluck('name'))&#125;).run() 它通过suite来组织每组测试，在测试套件中调用add()来添加被测试的代码 执行上述代码，得到的输出结果如下 123nativeMap x 1,227,341 ops/sec ±1.99%(83 runs sampled)customMap x 7,919,649 ops/sec ±0.57%(96 runs sampled)Fastest is customMap 负载测试 压力测试 除了可以对基本的方法进行基准测试外，通常还会对网络接口进行压力测试以判断网络接口的性能，这在第六章演示过。对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力。 最常用的工具是ab、siege、http_load等 基准测试驱动开发 测试数据与业务数据的转换 假设某个页面每天的访问量为100万。根据实际业务情况，主要访问量大致集中在10个小时以内，那么换算公式就是： 1QPS = PV / 10h 100万的业务访问量换算为QPS，约等于27.7，即服务器需要每秒处理27.7个请求才能胜任业务量 第十一章 产品化 项目工程化 目录结构 构建工具 代码审查 部署流程 部署环境 部署操作 性能 动静分离：将动态请求和静态请求分离，使服务器专注在动态服务方面，专业的CDN会将静态文件与用户尽可能靠近，同时能够有更精确和高效的缓存机制。 启用缓存：提升性能其实差不多只有两个途径，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不要的计算，应用场景做多的就是缓存。 多进程架构：通过多进程架构，不仅可以充分利用多核CPU，更是可以建立机制让Node进程更加健壮，，以保障Web应用持续服务。 读写分离：除了动静分离外，另一个较为重要的分离是读写分离，这主要针对数据库而言。就任意数据库而言，读取的速度远远高于写入的速度。而某些数据库在写入时为了保证数据的一致性，会进行锁表操作，这同时会影响到读取的速度。某些系统为了提升性能，通常会进行数据库的读写分离，将数据库进行主从设计，这样读数据操作不再受到写入的影响。 日志 访问日志：一般用来记录每个客户端对应用的访问 异常日志：通常用来记录那些意外产生的异常错误 异常日志通常有完善的分级，Node中提供console对象就简单地实现了这几种划分，具体如下所示： console.log：普通日志 console.info：普通信息 console.warn：警告信息 console.error：错误信息console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。下面为它们的实现代码： 1234567891011Console.prototype.log = function () &#123; this._stdout.write(util.format.apply(this, arguments) + '\\n')&#125;Console.prototype.info = Console.prototype.logConsole.prototype.warn = function () &#123; this._stderr.write(util.format.apply(this, arguments) + '\\n')&#125;Console.prototype.error = Console.prototype.warn console对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象，相关代码如下： 1234var info = fs.createWriteStream(logdir + '/info.log', &#123;flags: 'a', mode: '0666'&#125;)var error = fs.createWriteStream(logdir + '/error.log', &#123;flags: 'a', mode: '0666'&#125;)var logger = new console.Console(info, error) 分别调用它的API，日志内容就能各自写入到对应的文件中，相关代码如下： 12logger.log('Hello world!')logger.error('segment fault') 有了记录信息的日志API后，开发者需要关心的是要小心捕获每一个异常，在第四章中，我们提到异步调用中回调函数里的异常无法被外部捕获的问题，也提到了异步API编写的规范，每个开发者应当将API内部发生的异常作为第一个实参传递给回调函数。对于回调函数产生的异常，则可以不用过问，交给全局的uncaughtException事件去捕获即可。 在逐层次的异步API调用中，异常是该传递给调用方还是立即通过日志记录，这是一个需要注意的问题。就通常的API编写而言，尽量不要隐藏错误，不要通过try/catch块将异常捕获，然后隐藏起来不向外部调用者暴露。这对于底层API的设计而言，尤为重要。事实上，日志通常是服务于业务的。建议异常尽量由上层的调用者捕获记录，底层调用或中间层调用中出现的异常只要正常传递给上层的调用方即可。 日志与数据库 有的开发者对日志可能不太了解，会选择将一些日志写入到数据库中。数据库比日志文件好的地方在于它是结构化数据，可以直接编写SQL语句进行分析，日志文件则需要再加工之后才能分析。但是日志文件与数据库写入在性能上处于两个级别，数据库在写入过程中要经历一系列处理，比如锁表、日志等操作。写日志文件则是直接将数据写到磁盘上。为此，如果有大量的访问，可能会存在写入操作大量排队的状况，数据库的消费速度严重低于生产速度，进而导致内存泄漏等。相比之下，写日志是轻量的方法，将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来。 分割日志：将产生的日志按日期分割 监控报警 应用的监控主要有两类，一种是业务逻辑型的监控，一种是硬件型的监控。监控主要通过定时采样来进行记录。除此之外，还要对监控的信息设置上限，一旦出现大的波动，就需要发出警报提醒开发者。为了较好地供开发者使用，监控到的信息一般还要通过数据可视化的方式反映出来，以便更直观地查看。 监控 日志监控：通过监控异常日志文件的变动，将新增的异常按异常类型和数量反映出来；对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布。此外，从访问日志中也能实现PV和UV的监控。同QPS值一样，通过对PV/UV的监控，可以很好地知道应用的使用者们的习惯、预知访问高峰等。 响应时间：响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长。响应时间可以在Nginx一类的反向代理上监控，也可以通过应用自行产生的访问日志来监控。 进程监控：监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。 磁盘监控：磁盘监控主要是监控磁盘的用量。由于日志频繁写的缘故，磁盘空间渐渐被用光。一旦磁盘不够用，将会引发系统的各种问题。给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了。 内存监控：监控服务器的内存使用状况，可以检查应用中是否存在内存泄漏的状况。如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落。 CPU占用监控：CPU的使用分为用户态、内核态、IOWait等。如果用户态CPU使用率较高，说明服务器上的应用需要大量的CPU开销；如果内核态CPU使用率较高，说明服务器花费大量时间进行进程调度或者系统调用；IOWait使用率则反应的是CPU等待磁盘I/O操作。 CPU load监控：CPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载。CPU load过高说明进程数量过多，这在Node中可能体现在用子进程模块反复启动新的进程。 I/O负载：I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库。 网络监控：虽然网络流量监控的优先级没有上诉项目那么高，但还是需要对流量进行监控并设置上限值。即便应用突然受到用户的青睐，流量暴涨时也能通过数值感知到网站的宣传是否有效。一旦流量超过警戒值，开发者就应当找出流量增长的原因。对于正常增长，应当评估是否该增加硬件设备来为更多用户提供服务。网路流量监控的两个主要指标是流入流量和流出流量。 应用状态监控：除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续地调用应用的反馈接口来检查它的健康状态。最简单的状态反馈就是给监控响应一个时间戳，监控方检查时间戳是否正常即可。健壮一些的状态响应则是将应用的依赖项的状态打印出来，如数据库连接是否正常、缓存是否正常等。 DNS监控：DNS是网络应用的基础，在实际的对外服务的产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控。目前国内有一些免费的DNS监控服务，如DNSPod等，可以通过这些监控服务，监控自己的在线应用。 报警 邮件报警：可以调用nodemailer模块来实现邮件的发送 短信或电话报警： 稳定性 多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性问题。 多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟问题。在容灾方面，机房与机房之间可以互相备份。由于机房与机房之间的网络复杂度再度提升，负载均衡方面需要进一步去统筹规划。 容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务。 异构共存","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"NodeJs","slug":"编程语言/NodeJs","permalink":"http://yoursite.com/categories/编程语言/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://yoursite.com/tags/NodeJs/"},{"name":"深入浅出NodeJs","slug":"深入浅出NodeJs","permalink":"http://yoursite.com/tags/深入浅出NodeJs/"}]},{"title":"TypeScript 语法","slug":"typescript","date":"2019-02-12T02:27:23.000Z","updated":"2019-03-08T09:43:05.935Z","comments":true,"path":"2019/02/12/typescript.html","link":"","permalink":"http://yoursite.com/2019/02/12/typescript.html","excerpt":"","text":"简介TypeScript是什么背景TypeScript是微软开发的一款开源的编程语言，本质上是向JavaScript增加静态类型系统。它是JavaScript的超集，所有现有的JavaScript都可以不加改变就在其中使用。它是为大型软件开发而设计的，最终编译产生JavaScript，所以可以运行在浏览器、Node.js等等的运行时环境。 什么是类型系统下面是摘自《Types And Programming Languages》中的定义： A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute. 第一个重点是Proving the absence of certain program behaviors，所以我们亦可将类型检查器看做一个程序推理工具，可以静态的证明程序成立。 另一个重点是Classifying phrases according to the kinds of values they compute，对词语（比如变量）的值得性质进行分类，比如说TypeScript中的Interface、Class等。 静态类型系统是什么增加静态这个定语，是为了和运行时的类型检查机制加以区分，强调静态类型系统是在编译时进行类型分析。 TypeScript和JavaScript的关系和一些基于JavaScript的激进语言不同（比如CoffeScript），TypeScript的语法设计首先考虑的就是兼容JavaScript，或者说对JavaScript的语法做扩展。基本上是在JavaScript的基础上增加了一些类型标记语法，以实现静态类型分析。把这些类型标注语法去掉之后，仍是一个标准的JavaScript语言。 为什么要使用TypeScript 提高代码质量，降低bug率，隐式类型转换带来大量不可预知的类型错误 静态类型检测，减少编译阶段引起的错误 模块化，es6已支持 让代码更加清晰易读 语法糖()=&gt;，接口，枚举，泛型，方法重载 TypeScript 语法介绍基础类型 布尔值（Boolean） 1let isDone: boolean = false 数字（Number） 1234let decLiteral: number = 6let hexLiteral: number = 0xf00dlet binaryLiteral: number = 0b1010let octalLiteral: number = 0o744 字符串（String） 1let name: string = 'bob' 数组（Array） 12345// 在元素类型后面接上 []，表示由此类型元素组成的一个数组let list: number[] = [1, 2, 3]// 数组泛型，Array&lt;元素类型&gt;let list: Array&lt;number&gt; = [1, 2, 3] 元组（Tuple）：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同 123let x: [string, number]x = ['hello', 10] // OKx = [10, 'hello'] // Error 枚举（Enum） 123enum Color &#123; Red = 2, Green, Blue &#125;let c: Color = Color.Green // 3let colorName: string = Color[2] // 'Red' Any：允许你在编译时可选择地包含或移除类型检查，与Object的区别在于，Object类型的变量只是允许你给它赋任意值，但是却不能够在它上面调用任意的方法 123456let notSure: any = 4notSure.ifItExits() // OKnotSure.toFixed() // OKlet prettySure: Object = 4prettySure.toFixed() // Error Void：声明一个void类型的变量，只能赋值为undefined和null Null和Undefined：默认情况下null和undefined是所有类型的子类型。就是说你可以把null和undefined赋值给number类型的变量。然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自 Never：表示的是那些永不存在的值的类型。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 Object：表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型 1234let o: object = &#123; prop: 0 &#125; // OKlet o1: object = 4 // Error// 注意，object与Object的区别let o1: Object = 4 // OK 类型断言：好比其它语言里的类型转换 12345678// “尖括号”语法let someValue: any = 'this is a string'let strLength: number = (&lt;string&gt;someValue).length// as语法// 当在TypeScript中使用JSX时，只有as语法断言是被允许的let someValue: any = 'this is a string'let strLength: number = (someValue as string).length 变量声明 var、let、const 解构 接口TypeScript的核心原则之一就是对值所具有的结构进行类型检查在。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。相对于其它语言的接口而言，在ts中只会关注值得外形，而不能说某个对象实现了这个接口。 123456789101112interface SquareConfig &#123; width: number height: number // 可选属性的好处：1. 可以对可能存在的属性进行预定义；2. 可以捕获引用了不存在的属性时的错误（例如：color属性拼写错误成clor） color?: string // 只读属性 readonly borderColor: string // 只读数组，把ReadonlyArray类型的变量赋值给普通数组是不被允许的，但是可以用类型断言重写 arr: ReadonlyArray&lt;number&gt; // 字符串索引签名：避免额外的属性检查 [propName: string]: any&#125; 函数类型接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。 123456789interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearchFunc: SearchFuncmySearchFunc = function (src, sub): boolean &#123; let result = src.search(sub) return result &gt; -1&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型。TypeScript支持两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值的子类型。这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 123456789101112class Animal &#123; name: string&#125;class Dog extends Animal &#123; breed: string&#125;// 错误：使用数值型的字符串索引，有时得到的会是Dog类型的数据interface NotOkay &#123; [x: number]: Animal [x: string]: Dog&#125; 类类型与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 123456789101112interface ClockInterface &#123; currentTime: Date setTime(d: Date)&#125;class Clock implements ClockInterface &#123; currentTime: Date setTime(d: Date) &#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123;&#125;&#125; 继承接口和类一样，接口也可以相互继承。 1234567891011121314interface Shape &#123; color: string&#125;interface PenStroke &#123; penWidth: number&#125;interface Square extends Shape, PenStroke &#123; sideLength: number&#125;let square = &lt;Square&gt;&#123;&#125;square.color = 'blue'square.penWidth = 5.0square.sideLength = 10 混合类型因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性 1234567891011121314151617interface Counter &#123; (start: number): string interval: number reset(): void&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123;&#125; counter.interval = 123 counter.reset = function () &#123;&#125; return counter&#125;let c = getCounter()c(10)c.reset()c.interval = 5.0 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其之类所实现。 1234567891011121314151617class Control &#123; private state: any&#125;interface SelectableControl extends Control &#123; select(): void&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;// 错误： “Image”类型缺少“state”属性class Image implements SelectableControl &#123; select() &#123;&#125;&#125; 类继承 子类的构造函数里必须调用super()，且要在访问this的属性之前 子类可以重写基类的函数 1234567891011121314151617181920212223242526272829class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\") super.move(distanceInMeters) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\") super.move(distanceInMeters) &#125;&#125;let sam = new Snake(\"Sammy the Python\")let tom: Animal = new Horse(\"Tommy the Palomino\")sam.move()tom.move(34) 公有，私有与受保护的修饰符 public(默认) private TypeScript使用的是结构性类型系统。当我们比较两种不同的类型时，并不在乎它们从何而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 12345678910111213141516171819class Animal &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;class Rhino extends Animal &#123; constructor(theName: string) &#123; super('Rhino') &#125;&#125;class Employee &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;let animal = new Animal('Goat')let rhino = new Rhino()let employee = new Employee('bob')animal = rhino// 错误：Animal 与 Employee不兼容，私有成员name的定义不是来自同一处animal = employee protected：protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。构造函数也可以被标记成protected，这意味着这个类不能再包含它的类外被实例化，但是能被继承。 1234567891011121314151617181920212223class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的.export default &#123;&#125; readonly修饰符使用readonly关键字可以将属性设置为只读的 12345678910class Octopus &#123; readonly name: string readonly numberOfLegs: number = 8 constructor (theName: string) &#123; this.name = theName &#125;&#125;let dad = new Octopus('Man with the 8 strong legs')dad.name = 'Man with the 3-piece suit' // 错误！name是只读的 参数属性可以使用如下代码替代上述方法： 12345class Octopus &#123; readonly numberOfLegs: number = 8 constructor (readonly name: string) &#123; &#125;&#125; 注意看我们是如何舍弃了theName，仅在构造函数里使用readonly name: string参数来创建和初始化name成员。我们把声明和赋值合并至一处。 参数属性通过给构造函数前面添加一个访问限定符来声明。使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也一样 存取器对于存取器有下面几点需要注意的： 编译器设置为输出ECMAScript 5或更高 只带有get不带有set的存取器自动被推断为readonly 1234567891011121314151617181920212223let passcode = 'secret passcode'class Employee &#123; private _fullName: string get fullName(): string &#123; return this._fullName &#125; set fullName(newName: string): &#123; if (passcode &amp;&amp; passcode === 'secret passcode') &#123; this._fullName = newName &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee()employee.fullName = 'Bob Smith'if (employee.fullName) &#123; alert(employee.fullName)&#125; 静态属性12345class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;&#125;console.log(Grid.origin.x) 抽象类 abstract关键字用于定义抽象类和在抽象类内部定义抽象方法 抽象类作为其它派生类的基类使用，一般不会被实例化 不同于接口，抽象类可以包含成员的实现细节 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 把类当接口使用类的定义会创建两个东西：类的实例类型和一个构造函数。因为类可以创建出类型，所以你能够在允许使用接口的地方使用类 123456789class Point &#123; x: number y: number&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125; 函数为函数定义类型函数的类型由参数类型和返回值类型决定 1234567function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function (x: number, y: number): number &#123; return x + y&#125; 书写完整函数类型123let myAdd: (baseValue: number, increment: number) =&gt; number = function (x: number, y: number): number &#123; return x + y&#125; 可选参数和默认参数 传递给一个函数的参数个数必须与函数期望的参数个数一致 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, too few parameterslet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right 在参数名旁边使用?实现可选参数的功能，可选参数必须跟在必须参数后面 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName;&#125;let result1 = buildName(\"Bob\"); // works correctly nowlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right 带默认值得参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值 12345678function buildName(firstName = \"Will\", lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, too few parameterslet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\"let result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\" 可选参数和末尾的默认参数共享参数类型 123function buildName(firstName: string, lastName?: string) &#123; //. ..&#125; 和 123function buildName(firstName: string, lastName = 'Smith') &#123; //. ..&#125; 共享同样的类型(firstName: string, lastName?: string) =&gt; string 剩余参数通过…操作符来获取剩余参数 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + ' ' + restOfName.join(' ')&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName 重载定义重载时，一定要把最精确的定义放在最前面 123456789101112131415161718192021222324let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 注意，function pickCard(x): any并不是重载列表的一部分，是函数的具体实现。 泛型含义：类型的参数化，就是可以把类型像方法的参数那样传递 1234567// 参数类型与返回值类型相同function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let output = identity&lt;string&gt;('myString')let output = identity('myString') 使用泛型变量使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当做是任意或所有类型 12345function loggingIdentity&lt;T&gt;(arg: T): T &#123; // Error: T doesn't have .length console.log(arg.length) return arg&#125; 泛型类型泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数放在最前面，像函数声明一样： 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity 还可以使用带有调用签名的对象字面量来定义泛型函数 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity1: &#123; &lt;U&gt;(arg: U): U &#125; = identity 这引导我们去写一个泛型接口了 123456789interface GenericIdentityFn &#123; &lt;U&gt;(arg: U): U&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn = identity 或者我们可以把泛型参数当做整个接口的一个参数 123456789interface GenericIdentityFn&lt;U&gt; &#123; (arg: U): U&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity 泛型类泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;()myGenericNumber.zeroValue = 0myGenericNumber.add = function(x, y) &#123; return x + y &#125; 泛型约束如果我们想要限制函数去处理任意带有.length属性的所有类型。只要传入的类型中有这个属性，我们就允许。为此，我们需要累出对于T的约束要求。 为此，我们定义一个接口来描述约束条件。创建一个包含.length属性的接口，使用这个接口和extends关键字来实现约束： 123456789interface Lengthwise &#123; length: number&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; // Now we konw it has .length property, so no more error console.log(arg.length) return arg&#125; 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。 123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\"); // okaygetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.// export default &#123;&#125; 在泛型里使用类类型在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如： 123function create&lt;T&gt;(c: &#123; new(): T &#125;): T &#123; return new c()&#125; 枚举使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。TypeScript支持数字的和基于字符串的枚举。 数字枚举 默认从0开始，往后依次加1 如果给其中一个枚举成员赋值n，这后续的枚举成员从n开始依次加1 123456789101112131415enum Direction &#123; top, bottom = 4, left, right = 10, topLeft, topRight, bottomLeft, bottomRight&#125;console.log(Direction.top) // 0console.log(Direction.left) // 5console.log(Direction.topLeft) // 11console.log(Direction[4]) // 'bottom' 数字枚举可以被混入到计算过的和常量成员（如下所示），简单地说，不带初始化器的枚举，要么被放在第一的位置，要么被放在使用了数字常量或者其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的： 1234enum E &#123; A = getSomeValue(), B, // error! 'A' is not constant-initialized, so 'B' needs an initializer&#125; 字符串枚举在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化 123456enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT'&#125; 异构枚举从技术的角度来说，枚举可以混合字符串和数字成员，除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做 1234enum BooleanLikeHetergeneousEnum &#123; No = 0, Yes = 'YES'&#125; 计算的和常量成员每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量： 它是枚举的第一个成员且没有初始化器，这种情况下它被赋值于0 它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加1 枚举成员使用常量枚举表达式初始化。常量枚举表达式是TypeScript表达式的子集，他可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量和数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符+，-，~其中之一运用在了常量枚举表达式 常量枚举表达式做为二元运算符 +，-，*，/，%，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，|，^的操作对象。若常数枚举表达式求值后为NaN或Inifity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值 联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：”foo”, “bar”） 任何数字字面量（例如：1，100） 应用了一元 - 符号的数字字面量（例如：-1，-100） 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义： 枚举成员成为了类型。例如，我们可以说某些成员只能是枚举成员的值： 1234567891011121314151617181920212223242526272829303132enum ShapeKind &#123; Circle, Square,&#125;interface Circle &#123; kind: ShapeKind.Circle radius: number&#125;interface Square &#123; kind: ShapeKind.Square sideLength: number&#125;let c: Circle = &#123; kind: ShapeKind.Square, // ~~~~~~~~~~~~~~~~ Error! radius: 100,&#125;// 当有成员为非字面量枚举值时enum ColorKind &#123; Red, Green, Yellow = 2 &lt;&lt; 3&#125;interface Green &#123; // 错误：枚举类型“ColorKind”包含具有不是文本的初始值设定项的成员 kind: ColorKind.Green&#125; 枚举类型本身变成了每个枚举成员的联合。通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值得集合。因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。例如： 1234567891011enum E &#123; Foo, Bar&#125;function f(x: E) &#123; if (x !== E.Foo || x !== E.Bar) &#123; // // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'. &#125;&#125; 这个例子里，我们先检查 x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。 然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar 运行时的枚举枚举是在运行时真正存在的对象。例如下面的枚举： 123456789enum E &#123; X, Y, Z&#125;function f(obj: &#123; X: number &#125;) &#123; return obj.X&#125;// Works, since 'E' has a property named 'X' which is a number.f(E) 反向映射从枚举值到枚举名字，但不会为字符串枚举成员生成反向映射，如： 123456789enum NumberEnum &#123; A&#125;enum StringEnum &#123; A = 'a'&#125;console.log(NumberEnum[0]) // 'A'console.log(StringEnum['a']) // undefined const枚举常量枚举有两个特点： 常量枚举只能使用常量枚举表达式。 1234567891011// OKenum NumberEnum &#123; A, B = Math.random()&#125;// Errorconst enum NumberEnum &#123; A, B = Math.random()&#125; 不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。之所以可以这么做是因为，常量枚举不允许包含计算成员。 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 生成后的代码为： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举外部枚举用来描述已经存在的枚举类型的形状 12345declare enum Enum &#123; A = 1, B, C = 2&#125; 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。 类型推论这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的 基础TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子 1let x = 3 变量x的类型为数字。这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最适合的通用类型，如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型。 1234let x = [0, 1, null] // (number)[]let zoo = [new Rhino(), new Elephant(), new Snake()] // (Rhino | Elephant | Snake)[]// 当候选类型不能使用的时候，我们需要明确的指出类型let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()] 上下文类型TypeScript类型推论也可能按照相反的方向进行。这被叫做”按上下文归类“。按上下文归类会发生在表达式的类型与所处的位置相关时。比如： 123window.onmousedown = function (mouseEvent) &#123; console.log(mouseEvent.message) // Error&#125; 如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.message); //&lt;- Now, no error is given&#125;; 上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如： 123function createZoo(): Animal[] &#123; return [new Rhino(), new Elephant(), new Snake()];&#125; 这个例子里，最佳通用类型由4个候选者：Animal，Rhino，Elephant和Snake。当然，Animal会被作为最佳通用类型 类型兼容性TypeScript里的类型兼容性是基于结构子类型的。结构类型是一种值使用其成员来描述类型的方式。它正好与名义（nominal）类型形成对比。（在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子： 123456789interface Named &#123; name: string&#125;class Person &#123; name: string&#125;// OK, because of a structural typinglet p: Named = new Person TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 开始TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有x相同的属性，如果一个y类型的值赋给一个x类型的值，则会递归遍历x的属性是否在y中都存在，如果都存在，则这两者是兼容的，比如 1234567891011interface Named &#123; props: &#123; name: string &#125;&#125;function greet(n: Named) &#123; console.log('Hello, ' + n.props.name)&#125;let y = &#123; props: &#123;name: 'a'&#125; &#125;greet(y) // OK 比较两个函数x(源函数) = y(目标函数) 目标函数的参数必须能在源函数里找到对应类型的参数 源函数的返回值类型必须是目标函数返回值类型的子类型 比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的签名 1234let x = (a: number) =&gt; (&#123; a: 1, b: 2 &#125;)let y = (b: number, s: string) =&gt; (&#123; a: 1 &#125;)y = x // OK 枚举数字枚举类型与数字类型兼容，并且数字类型与数字枚举类型兼容。不同枚举类型之间是不兼容的。比如 12345678enum Status &#123; Ready, Waiting &#125;enum Color &#123; Red, Blue, Green &#125;let st = Status.Readylet a: number = 2st = 2 // OKa = Status.Ready // OKst = Color.Green; // Error 类类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如： 123456interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // OK, because y matches structure of x 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了： 1234567interface NotEmpty&lt;T&gt; &#123; data: T;&#125;let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // Error, because x and y are not compatible 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子。比如： 123456789let identity = function&lt;T&gt;(x: T): T &#123; // ...&#125;let reverse = function&lt;U&gt;(y: U): U &#123; // ...&#125;identity = reverse; // OK, because (x: any) =&gt; any matches (y: any) =&gt; any 高级类型本节主要介绍通过type关键字创建高级类型，若要详细了解此节，请阅读源文档 交叉类型：交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 联合类型：表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以number | string | boolean表示一个值可以是number，string，或boolean。如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 类型保护与区分类型 类型谓词：parameterName is Type typeof类型保护：只有两种形式能被识别： typeof v === “typename”和 typeof v !== “typename”， “typename”必须是 “number”， “string”， “boolean”或 “symbol”。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护 Symbols迭代器和生成器当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。 for…of vs for…in for…of遍历的是值，for…in遍历的是属性 另一个区别是for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。 12345678910let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);pets[\"species\"] = \"mammals\";for (let pet in pets) &#123; console.log(pet); // \"species\"&#125;for (let pet of pets) &#123; console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"&#125; 代码生成 目标为ES5和ES3 当生成目标为ES5或ES3，迭代器只允许在Array类型上使用。 在非数组值上使用for..of语句会得到一个错误，就算这些非数组值已经实现了Symbol.iterator属性。 编译器会生成一个简单的for循环做为for…of循环，比如： 1234let numbers = [1, 2, 3];for (let num of numbers) &#123; console.log(num);&#125; 生成的代码为： 12345var numbers = [1, 2, 3];for (var _i = 0; _i &lt; numbers.length; _i++) &#123; var num = numbers[_i]; console.log(num);&#125; 目标为ECMAScript 2015或更高 当目标为兼容ECMAScript 2015的引擎时，编译器会生成相对于引擎的for..of内置迭代器实现方式 模块同ECMAScript 2015的模块概念 export = 和 import为了支持CommonJS和AMD的exports，TypeScript提供了export = 和import = require()语法 ZipCodeValidator.ts1234567let numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export = ZipCodeValidator; Test.ts123456789101112import zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip();// Show whether each string passed each validatorstrings.forEach(s =&gt; &#123; console.log(`\"$&#123; s &#125;\" - $&#123; validator.isAcceptable(s) ? \"matches\" : \"does not match\" &#125;`);&#125;); 危险信号 文件的顶层声明是export namespace Foo { … }（删除Foo并把所有内容向上层移动一层） 文件只有一个export class 或 export function（考虑使用export default） 多个文件的顶层具有同样的export namespace Foo {（不要以为这些会被合并到一个Foo中！） 命名空间命名空间和模块在TypeScript中，每个文件都代表一个模块，通过import，export，export = 和import = require(…)进行导入和导出，在TypeScript1.5之前称为外部模块。命名空间namespace，在TypeScript1.5之前称为内部模块，是定义在全局空间下的一个JS对象，不存在导入和导出的概念，不同文件相同的命名空间里的变量会被整合到一起，因此需要把所有相同命名空间的文件通过–outFile输出到一个文件中，防止发生运行时错误，使用全局命名空间的时候，不能使用import导入其他模块。当把namespace通过export导出的时候，这个内部模块就变成了外部模块。 命名空间命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过 –outFile结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的&lt;script&gt;标签里。 但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。 模块像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 声明它的依赖。 模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。 模块解析官网原文 声明合并接口合并接口的非函数的成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。 于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口 A与后来的接口 A合并时，后面的接口具有更高的优先级。 如下例所示： 123456789101112interface Cloner &#123; clone(animal: Animal): Animal;&#125;interface Cloner &#123; clone(animal: Sheep): Sheep;&#125;interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat;&#125; 这三个接口合并成一个声明： 123456interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal;&#125; 这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 单一的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。 比如，下面的接口会合并到一起： 1234567891011interface Document &#123; createElement(tagName: any): Element;&#125;interface Document &#123; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement;&#125;interface Document &#123; createElement(tagName: string): HTMLElement; createElement(tagName: \"canvas\"): HTMLCanvasElement;&#125; 合并后的Document将会像下面这样： 1234567interface Document &#123; createElement(tagName: \"canvas\"): HTMLCanvasElement; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement; createElement(tagName: string): HTMLElement; createElement(tagName: any): Element;&#125; 合并命名空间对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里 Animals声明合并示例： 12345678namespace Animals &#123; export class Zebra &#123; &#125;&#125;namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Dog &#123; &#125;&#125; 等同于： 123456namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Zebra &#123; &#125; export class Dog &#123; &#125;&#125; 除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。 12345678910111213namespace Animal &#123; let haveMuscles = true; export function animalsHaveMuscles() &#123; return haveMuscles; &#125;&#125;namespace Animal &#123; export function doAnimalsHaveMuscles() &#123; return haveMuscles; // Error, because haveMuscles is not accessible here &#125;&#125; 命名空间与类和函数和枚举类型合并 合并命名空间和类 123456class Album &#123; label: Album.AlbumLabel;&#125;namespace Album &#123; export class AlbumLabel &#123; &#125;&#125; 生成的代码 1234567class Album &#123;&#125;(function (Album) &#123; class AlbumLabel &#123; &#125; Album.AlbumLabel = AlbumLabel;&#125;)(Album || (Album = &#123;&#125;)); 利用命名空间来添加函数的属性 12345678910function buildLabel(name: string): string &#123; return buildLabel.prefix + name + buildLabel.suffix;&#125;namespace buildLabel &#123; export let suffix = \"\"; export let prefix = \"Hello, \";&#125;console.log(buildLabel(\"Sam Smith\")); 利用命名空间来扩展枚举型： 12345678910111213141516171819202122enum Color &#123; red = 1, green = 2, blue = 4&#125;namespace Color &#123; export function mixColor(colorName: string) &#123; if (colorName == \"yellow\") &#123; return Color.red + Color.green; &#125; else if (colorName == \"white\") &#123; return Color.red + Color.green + Color.blue; &#125; else if (colorName == \"magenta\") &#123; return Color.red + Color.blue; &#125; else if (colorName == \"cyan\") &#123; return Color.green + Color.blue; &#125; &#125;&#125; 非法的合并TypeScript并非允许所有的合并。目前，类不能与其它类或变量合并。 JSX基本用法想要使用JSX必须做两件事 给文件一个.tsx扩展名 启用jsx选项 TypeScript具有三种JSX模式： preserve：在preserver模式下生成代码中会保留JSX以供后续的转换操作使用（比如：Babel），输出文件扩展名为.jsx。 react：会生成React.createElement，在使用前不需要再进行转换操作了，输出文件扩展名为.js。 react-native：相当于preserve，输出文件扩展名为.js。 类型检查 固有元素：环境自带的某些东西（比如，DOM环境里的div或span组件），固有元素使用特殊的接口JSX.IntrinsicElements来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在JSX.IntrinsicElements接口的属性里查找。 例如： 12345678declare namespace JSX &#123; interface IntrinsicElements &#123; foo: any &#125;&#125;let a = &lt;foo /&gt;; // 正确let b = &lt;div /&gt;; // 错误 基于值得元素： 基于值得元素会简单的在它所在的作用域里按标识符查找 装饰器装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 例如，有一个@sealed装饰器，我们会这样定义sealed函数： 123function sealed(target) &#123; // do something with \"target\" ...&#125; 装饰器工厂如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。 我们可以通过下面的方式来写一个装饰器工厂函数： 12345function color(value: string) &#123; // 这是一个装饰器工厂 return function (target) &#123; // 这是装饰器 // do something with \"target\" and \"value\"... &#125;&#125; 装饰器组合多个装饰器可以同时应用到一个声明上，就像下面的示例 1234567// 书写在同一行上@f @g x// 书写在多行上@f@gx 当多个装饰器应用于一个声明上，它们求值方式与复合函数相似。在这个模型下，当复合f和g时，复合的结果(f ∘ g)(x)等同于f(g(x))。 装饰器求值类中不同声明上的装饰器将按以下规定的顺序应用： 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。 参数装饰器应用到构造函数。 类装饰器应用到类。 类装饰器参数： 类的构造函数。 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。 1注意 如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中不会为你做这些。 方法装饰器参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 1注意 如果代码输出目标版本小于ES5，属性描述符将会是undefined。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 1注意 如果代码输出目标版本小于ES5返回值会被忽略。 访问器装饰器1注意 TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。 参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 1注意 如果代码输出目标版本小于ES5，属性描述符将会是undefined。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 1注意 如果代码输出目标版本小于ES5返回值会被忽略。 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 1注意 属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 参数装饰器参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引。 1注意 参数装饰器只能用来监视一个方法的参数是否被传入。 参数装饰器的返回值会被忽略。 Mixins 使用implements关键词，把类当做接口。 为将要mixin进来的属性方法创建出占位属性,告诉编译器这些成员在运行时是可用的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125;class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + \" : \" + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125;applyMixins(SmartObject, [Disposable, Activatable]);let smartObj = new SmartObject();setTimeout(() =&gt; smartObj.interact(), 1000);////////////////////////////////////////// In your runtime library somewhere////////////////////////////////////////function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;); &#125;);&#125; 三斜线指令三斜线指令是包含单个XML标签的单行注释。注释的内容会作为编译器指令使用。 三斜线指令仅可放在包含它的文件的最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。 使用–noResolve编译选项，三斜线引用会被忽略 /// &lt;reference path=”…” /&gt;：用于声明文件间的依赖，告诉编译器在编译过程中要引入的额外的文件。 /// &lt;reference types=”…” /&gt;：用于声明对某个包的依赖，仅当在你需要写一个d.ts文件时才使用这个指令。若要在.ts文件声明一个对@types包的依赖，使用–types命令行选项或在tsconfig.json里指定。 /// &lt;reference no-default-lib=”true” /&gt;：这个指令把一个文件标记成默认库，告诉编译器在编译过程中不要包含这个默认库（比如，lib.d.ts）。 这与在命令行上使用 –noLib相似。还要注意，当传递了–skipDefaultLibCheck时，编译器只会忽略检查带有/// &lt;reference no-default-lib=”true”/&gt;的文件。 /// &lt;amd-module name=”…” /&gt;： 默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如 r.js。 amd-module指令允许给编译器传入一个可选的模块名： amdModule.ts123///&lt;amd-module name='NamedModule'/&gt;export class C &#123;&#125; 这会将NamedModule传入到AMD define函数里： amdModule.js12345678define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) &#123; var C = (function () &#123; function C() &#123; &#125; return C; &#125;)(); exports.C = C;&#125;);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"TypeScript","slug":"编程语言/TypeScript","permalink":"http://yoursite.com/categories/编程语言/TypeScript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]}]}