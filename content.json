{"meta":{"title":"WgCg Blog","subtitle":"Keep Learning and Never Give Up","description":"WgCg、Cong.Wang、WangCong、Vue、Webpack、HTML、CSS、JS","author":"Cong.Wang","url":"http://yoursite.com"},"pages":[{"title":"所有分类","date":"2019-01-26T02:26:44.100Z","updated":"2019-01-26T02:26:44.100Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-01-26T02:33:41.907Z","updated":"2019-01-26T02:33:41.907Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"日程安排","date":"2019-01-26T02:35:23.254Z","updated":"2019-01-26T02:35:23.254Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-01-26T02:31:18.099Z","updated":"2019-01-26T02:31:18.099Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Velocity语法","slug":"Velocity语法","date":"2019-03-12T05:55:09.000Z","updated":"2019-03-12T07:18:12.244Z","comments":true,"path":"2019/03/12/Velocity语法.html","link":"","permalink":"http://yoursite.com/2019/03/12/Velocity语法.html","excerpt":"","text":"Velocity基本语法介绍判断语句1234567#if($condition) ...#elseif($condition) ...#else ...#end 运算符 比较符：== != &gt; &gt;= &lt; &lt;= 逻辑运算符：&amp;&amp; || ! 运算符：+ - * / % 常用判断 判断是否为null #if(( !$condition) &amp;&amp; (“$!condition” == “”) ) 使用NULL工具：#if( $null.isNull($condition) ) 使用#ifnull() 或 #ifnotnull()，要使用这个特性必须在velocity.properties文件中加入： 12userdirective = org.apache.velocity.tools.generic.directive.Ifnulluserdirective = org.apache.velocity.tools.generic.directive.Ifnotnull 判断是否为true：#if( $condition == true ) 判断是否为null或false：#if( !$condition ) 判断是否为空字符串：#if( $condition == “” ) 判断是否为null或者空字符串：#if( “$!condition” === “” ) 判断是否是一个数字：#if( $condition == 123 ) Velocity中的==可以直接比较数值，字符串以及其它对象，如果==两侧的对象是不同的类的对象，在比较前会用toString()转换后再比较。所以当$condition的值为123或”123”时，条件都为真 循环语句123#foreach($val in $arr)...#end $velocityCount和$foreach.count可以获得当前循环次数，初始值为1 $foreach.hasNext用来判断是否存在下一次循环 #break用于用于跳出循环，经测试，在jello框架里无效 当$arr为对象的时候：$val取到的是value，如果需要在遍历对象的过程中，同时取到对象的keys，可以使用entrySet() 或 keySet()方法 1234567#foreach($item in $!obj.entrySet()) $!item.key: $!item.value#end#foreach($key in $!obj.keySet()) $key: $obj.get($key)#end 注意：这种集合的遍历是无序的，即遍历顺序可能不同于$obj中元素定义的顺序 Range Operator1234567#foreach($foo in [1..5]) $foo#end#foreach($bar in [2..-2]) $bar#end 以上输出为： Example1：1 2 3 4 5Example2：2 1 0 -1 -2 Example2，经测试，在jello框架中不能包含负数 字符串$str.charAt(index) 获取指定下标的字符 $str.substring(begin, end) end不填，截取begin到字符串末尾，不改变原值 $str.length() 返回字符串的长度 $str.toUpperCase() 把字符串转换为大写 $str.toLowerCase() 把字符串转换为小写 $str.replace(old, new) 替换字符串中指定的子串 $str.indexOf($substr) 从字符串头部开始检索是否存在某个子串 $str.lastIndexOf($substr) 从字符串尾部开始检索是否存在某个子串 字符串拼接：$str + $str1 或 ${str}oo${str1}： 例如： 12345#set($str = “AA”)#set($str1 = “BB”)#set($str2 = $str + $str1) 则${str}oo${str1}的结果为：AAooBB 字符串转数字： 12345#set( $intString = “9” )#set( $Integer = 0 )$Integer.parseInt($intString) 同理： 12345#set( $doubleString = “12.3” )#set( $Double = 0.0 )$Double.parseDouble( $doubleString ) 数组$arr.size() 返回数组长度 $arr.isEmpty() 判断数组是否为空 $arr.get(index)或$arr[index] 返回数组中指定下标index的值 $arr.set(1, “test”) 设置数组中指定下标的值 $arr.add($param) 增加元素 宏宏的定义：#macro(宏的名称 $参数1 $参数2) 语句体 #end 宏的调用：#macro($参数1 $参数2)//参数之间用空格隔开 例子: 123456789#macro (tablerows $color $somelist) #foreach($something in $somelist) &lt;tr&gt;&lt;td bgColor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt; #end#end 调用： 12345678#set($color = “blue”)#set($arr = [“a”, “b”, “c”, “d”])&lt;table&gt;#tablerows($color $arr)&lt;/table&gt; 参考文档 http://www.blogjava.net/alexwan/archive/2008/06/07/206473.html http://velocity.apache.org/engine/devel/user-guide.html#variables http://wiki.apache.org/velocity/VelocityNullSupport http://wiki.apache.org/velocity/CheckingForNull","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"Velocity","slug":"编程语言/Velocity","permalink":"http://yoursite.com/categories/编程语言/Velocity/"}],"tags":[{"name":"velocity","slug":"velocity","permalink":"http://yoursite.com/tags/velocity/"}]},{"title":"js-继承的5种方式","slug":"js-继承的5种方式","date":"2019-03-11T08:50:40.000Z","updated":"2019-03-11T10:25:56.134Z","comments":true,"path":"2019/03/11/js-继承的5种方式.html","link":"","permalink":"http://yoursite.com/2019/03/11/js-继承的5种方式.html","excerpt":"","text":"原型基础123456789function Animal (name) &#123; this.name = name&#125;Animal.prototype.say = function (something) &#123; console.log(`$&#123; this.name &#125; is say something`)&#125;const animal = new Animal('animal') 往原型上增加属性和方法的原因：如果所有属性和方法都添加在实例上，那么每创建一个实例对象，其都有很多重复的属性和方法，需要耗费大量的内存，且降低了运行效率 构造函数Animal，其原型链为：Animal =&gt; Animal.prototype =&gt; Object的实例 =&gt; null，Animal.prototype.proto.proto === null 实例对象的consturctor属性（实际上这个属性不在实例对象本身上，而是在构造函数的原型上）指向构造函数 prototype对象的isPrototypeOf方法用来判断是否是某个对象的原型 实例对象的hasOwnProperty方法判断某个属性是否是实例对象本身的属性 in操作符用于判断某个属性是否存在于实例对象或其原型上 instanceof用于判断某个对象是否是某个构造函数的实例 animal.proto === A.prototype 构造函数的5种继承方法","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"js","slug":"面试题/js","permalink":"http://yoursite.com/categories/面试题/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"},{"name":"extends","slug":"extends","permalink":"http://yoursite.com/tags/extends/"}]},{"title":"TypeScript笔记","slug":"TypeScript笔记","date":"2019-03-09T07:43:06.000Z","updated":"2019-03-11T08:07:07.188Z","comments":true,"path":"2019/03/09/TypeScript笔记.html","link":"","permalink":"http://yoursite.com/2019/03/09/TypeScript笔记.html","excerpt":"","text":"TypeScript入门教程 null和undefined是所有类型的子类型，也就说null和undefined类型的变量可以赋值给任意类型的变量，而void类型的变量却不行。 在any类型的变量上访问任何属性或者调用任何方法都是允许的，声明一个变量为any后，对它的任何操作，返回的内容的类型都是任意值。 变量如果在声明的时候，未指定其类型，那么它会被识别为any类型。 当TypeScript不确定一个联合类型的变量是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性和方法。 12345function getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 赋值的时候，变量的形状必须与接口的形状保持一致。 接口一旦定义了索引签名，那么确定属性和可选属性的类型都必须是它的类型的子集。 123456interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'. 只读属性的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 1234567891011121314151617interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.// Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 调用函数时，输入多余的（或者少于要求的）参数，是不被允许的，可以使用可选参数。 可选参数后面不允许再出现必须参数了。 TypeScript会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制了。 当发生函数重载的时候，TypeScript会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 123456function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.// Type 'number' is not comparable to type 'boolean'. declare var a 与 var a的区别在于declare并没有对变量a进行声明，在编译结果中会被删除，而var a声明了这个变量。 1234567891011121314decalre var a // 说明在某处已经声明过改变量a = 1 // 对变量重新进行赋值// 上述代码编译结果a = 1// -----------var aa = 1// 上述代码编译结果var aa = 1 只有function、class和interface可以直接默认导出，其它的变量需要先定义出来，再默认导出 1234567export default enum Directions &#123;// ERROR: Expression expected. Up, Down, Left, Right&#125; 当为元组类型的变量添加越界的元素时，它的类型会被限制为元组每个类型的联合类型。 枚举项有两种类型：常数项和计算所得项。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错 1234enum Color &#123;Red = \"red\".length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer. 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。 12345678910declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 上述代码编译为：var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"TypeScript","slug":"编程语言/TypeScript","permalink":"http://yoursite.com/categories/编程语言/TypeScript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"git结合beyond-compare","slug":"git结合beyond-compare","date":"2019-03-08T07:10:44.000Z","updated":"2019-03-08T07:14:00.514Z","comments":true,"path":"2019/03/08/git结合beyond-compare.html","link":"","permalink":"http://yoursite.com/2019/03/08/git结合beyond-compare.html","excerpt":"","text":"beyond compare 无限试用for mac 应用程序 -&gt; beyond cmpare右击显示包内容 -&gt; contents -&gt; macos 在当前目录下新建文件BCompare.sh，把原来的BCompare重命名为BCompare.real 编辑BCompare.sh，输入以下代码: 123#!/bin/bashrm \"/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat\"\"`dirname \"$0\"`\"/BCompare.real $@ 右击BCompare.sh -&gt; 显示简介 -&gt; 删除文件名后缀.sh .gitconfig配置.gitconfig位于user下, shift + comand + . 显示隐藏文件 12345678910111213141516[alias] dift = &quot;difftool --dir-diff --no-symlinks&quot;[diff] tool = bcomp[difftool] prompt = false[difftool &quot;bcomp&quot;] trustExitCode = true cmd = &quot;/usr/local/bin/bcomp&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot;[merge] tool = bcomp[mergetool] prompt = false[mergetool &quot;bcomp&quot;] trustExitCode = true cmd = &quot;/usr/local/bin/bcomp&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; \\&quot;$BASE\\&quot; \\&quot;$MERGED\\&quot; git dift origin/dev：当前分支与远程dev分支进行比较","categories":[{"name":"其它技术","slug":"其它技术","permalink":"http://yoursite.com/categories/其它技术/"},{"name":"git","slug":"其它技术/git","permalink":"http://yoursite.com/categories/其它技术/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"beyond compare","slug":"beyond-compare","permalink":"http://yoursite.com/tags/beyond-compare/"}]},{"title":"Jekins构建结果与本地构建结果Vue版本不同","slug":"Jekins构建结果与本地构建结果Vue版本不同","date":"2019-03-08T07:00:30.000Z","updated":"2019-03-08T07:09:09.434Z","comments":true,"path":"2019/03/08/Jekins构建结果与本地构建结果Vue版本不同.html","link":"","permalink":"http://yoursite.com/2019/03/08/Jekins构建结果与本地构建结果Vue版本不同.html","excerpt":"","text":"背景项目迁移到jenkins，通过jenkins进行构建，部署后发现页面报错，但是本地构建出来代码部署后是正常的，报错如下： 问题排查过程 注释webpack插件UglifyJsPlugin插件，不进行代码压缩 对比本地代码与jenkins构建出来的代码，构建输出目录结构如下： 对比结果 app.js中只存在一些变量名和Path的不一致，不会产生错误 manifest.js完全一致 vendor.js中Vue的版本不一致，jenkins构建出来的Vue版本是2.5.20，本地构建出来的Vue版本是2.5.21，推测是由此产生的错误 用本地构建出的vendor.js替换jenkins构建出的vendor.js，部署到ftp上，发现问题解决了，确认推测是正确的 对比两个Vue版本代码的不同，发现是以下代码影响的： 分析：rendList是v-for的实现方法，在Vue2.5.20中，当入参val属于类型: Array, String, Number, Object（非null）时初始化变量ret为数组并进行相应的处理，然后判断ret变量不为undefined和null时，给ret变量添加属性_isVList为true，然后将ret变量返回，ret的类型可能为undefined, Array，当返回undefined时，对undefined进行一些数组的操作就会发生错误，而控制台所报的错误就是因为取了undefined.length导致的，在Vue2.5.21版本修复了这个Bug，如果ret变量为undefined或null时，初始化ret为[]，这样确保rendList的返回值类型始终为Array 解决方法由上可知，产生改问题的原因如下： 直接原因： Vue2.5.20版本中存在代码漏洞 根本原因：jenkins服务器安装的Vue版本不正确，而为什么jenkins服务器安装的vue版本和本地安装的不一致，需要进一步排查，已经排除是node版本导致的原因 因此，只要把package.json中vue依赖的版本号固定为2.5.21（注意：vue-template-compiler版本需要跟vue版本保持一致），问题就可以解决了，如下图：","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"},{"name":"Webpack","slug":"打包工具/Webpack","permalink":"http://yoursite.com/categories/打包工具/Webpack/"},{"name":"问题积累","slug":"打包工具/Webpack/问题积累","permalink":"http://yoursite.com/categories/打包工具/Webpack/问题积累/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"动态加载模块","slug":"动态加载模块","date":"2019-03-08T06:59:10.000Z","updated":"2019-03-08T07:08:18.598Z","comments":true,"path":"2019/03/08/动态加载模块.html","link":"","permalink":"http://yoursite.com/2019/03/08/动态加载模块.html","excerpt":"","text":"背景项目本地开发通过mockjs进行数据模拟，它是通过重写XMLHttpRequest对象来拦截请求，从而达到纯前端mock，在webpack入口文件main.js中通过require引入mock文件，以下是mock文件和main.js的代码： mock file: main.js: Bug描述上线后，发现在部分android手机和少数ios手机上无法加载出页面 问题排查 通过抓包排除接口&amp;数据问题 页面注入vConsole发现控制台输出脚本错误，无法识别const关键字 在构建出的js中定位const关键字，如下图： 可以得出问题表面原因是因为某些机型浏览器版本较低，无法识别ES6语法 问题分析通过查看构建后的js与分析发现了三个问题： const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？ 为何该const语法没有经过babel转译成ES5语法？ 为何打包出的js没有进行压缩？ 问题一const语句是写在mock文件中，明明在main.js中根据环境去require mock文件了，为何mock文件还被打包进了页面的js中？ webapck构建过程：webpack在构建的时候，会从所有入口文件开始递归查找代码中的require语法和import语法，并生成一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的bundle，而动态require模块webpack也是能够支持的，但会导致所有可能用到的模块都包含在bundle中（详见），如果代码中依赖条件表达式动态require模块，类似上面的main.js那样，又不想把不需要的模块打包到bundle中，需要遵循以下要求： 条件表达式中不允许出现变量 条件表达式不允许执行函数调用 只能进行一些常量的运算，如下： 12345678910111213141516171819// module.js会被打包进bundleif (1 + 1 === 2) &#123; require('./module.js')&#125;// module.js会被打包进bundleif (true) &#123; require('./module.js')&#125;// module.js不会被打包进bundleif (1 &gt; 2) &#123; require('./module.js')&#125;// module.js不会被打包进bundleif (1 !== 1) &#123; require('./module.js')&#125; webapck集成的DefinePlugin插件允许创建一个在编译时可以配置的全局常量（详见） 问题1的原因正是因为违背了上述原则2，调用了字符串的match函数，而我们在webpack配置使用DefinePlugin插件，创建了一个全局常量process.env，从而规避了原则1 12345678910111213// main.jsif (!process.env.NODE_ENV.match(/production|test/)) &#123; require('../mock/index')&#125;// webpack配置&#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env': env &#125;) ]&#125; 因此我们可以把main.js文件中的代码改成以下内容，达到非开发环境不把mock文件打包到bundle中 123if (process.env.NODE_ENV === 'development') &#123; require('../mock/index')&#125; 问题二为何该const语法没有经过babel转译成ES5语法？ 原因是在webpack的配置中，配置了只对src，test目录下的文件执行babel转译（详见），而mock文件不在这些目录下，所以没有进行转译 问题三为何打包出的js没有进行压缩？ 我们对项目进行构建，UglifyJsWebpackPlugin插件会报出如下错误： 错误问题指向的是打包后的const语法，原因是因为UglifyJsWebpackPlugin不支持ES6语法，所以在treeshaking的时候，遇到const语法，就发生错误了，终止了插件的执行，从而也无法执行后续的压缩步骤，但这并不影响其它插件的功能，webpack也无法感知到这个插件在执行过程中出现了错误，所以构建结果仍然是成功的 总结 运用条件表达式动态加载模块，除非条件表达式中不出现变量、函数调用，只进行一些常量的运算，那么条件为false的时候该模块是不会打包进bundle中的，否则无论条件为false还是true，始终会把该模块打包进bundle，只不过在条件为false的情况下不执行代码罢了 可以运用DefinePlugin添加运行时的全局常量 可以通过配置babel-loader的include选项对指定文件夹下的文件进行转译 UglifyJsWebpackPlugin不支持ES6语法 webpack无法感知插件运行过程中出现的错误，需要构建完成对构建的结果进行check，例如通过eslint对dist文件进行检查，是否有非ES5的代码","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"},{"name":"Webpack","slug":"打包工具/Webpack","permalink":"http://yoursite.com/categories/打包工具/Webpack/"},{"name":"问题积累","slug":"打包工具/Webpack/问题积累","permalink":"http://yoursite.com/categories/打包工具/Webpack/问题积累/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"滚动穿透问题","slug":"滚动穿透问题","date":"2019-03-08T06:52:10.000Z","updated":"2019-03-08T06:53:31.953Z","comments":true,"path":"2019/03/08/滚动穿透问题.html","link":"","permalink":"http://yoursite.com/2019/03/08/滚动穿透问题.html","excerpt":"","text":"目的当页面中有弹层时，禁止body的滚动 解决方案 给body或html增加overflow: hidden pc端：可行 ios：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度 android：不可行，仍然会滚动穿透，打开弹层时页面不会滚到顶部，除非body或html高度为屏幕高度 mask增加touchmove.prevent，滚动元素增加prevent.stop pc端：不可行，仍然会滚动穿透 ios：不可行，仍然会滚动穿透 android: 不可行，仍然会滚动穿透 给body增加fixed，打开弹层时记录滚动条位置，弹层消失时滚动到记录位置 pc端：可行 ios：当你从滚动容器滑动到容器之外时，或从底部下拉起控制中心，会导致容器进入短暂的无法滚动状态，等待一段时间后自动恢复，推测是ios的页面回弹效果影响的 android: 可行 12345.modal-open &#123; position: fixed; width: 100%; overflow: hidden;&#125; 12345678910111213141516const ModalHelper = (function (bodyCls) &#123; let scrollTop return &#123; // 弹出之后记录保存滚动位置，并且给body添加.modal-open afterOpen: function () &#123; scrollTop = document.scrollingElement.scrollTop document.body.classList.add(bodyCls) document.body.style.top = -scrollTop + 'px' &#125;, // 关闭时将.modal-open移除并还原之前保存滚动位置 beforeClose: function () &#123; document.body.classList.remove(bodyCls) document.scrollingElement.scrollTop = scrollTop &#125; &#125;;&#125;)('modal-open') 监听滚动容器的touchmove事件，当检测到已经处于最底部，却还意图往下滚动时，阻止默认事件（处于最顶部时同理） pc端：不支持touch事件 ios：可行，解决了页面反弹问题 android: 不可行，阻止默认事件没生效，仍会滚动穿透 12345678910111213141516171819202122232425262728293031323334353637383940// 记录开始滑动的坐标，用于判断滑动方向let startY = 0// 记录滑动状态：0：未开始，1：已开始，2：滑动中let scrollStatus = 0// 以下所有事件均绑定在滚动容器元素上function touchstartHandler (e) &#123; status = 1 startY = e.targetTouches[0].pageY&#125;function touchmoveHandler (e) &#123; if (status !== 1) return status = 2 let t = e.currentTarget let py = e.targetTouches[0].pageY // 内容可视高度 let ch = t.clientHeight // 内容滚动高度 let sh = t.scrollHeight // 当前滚动高度 let st = t.scrollTop // 已经到头部尽头了还要向上滑动，阻止它 if (st === 0 &amp;&amp; startY &lt; py) &#123; e.preventDefault() &#125; // 已经到低部尽头了还要向下滑动，阻止它 if ((st === sh - ch) &amp;&amp; startY &gt; py) &#123; e.preventDefault() &#125;&#125;function touchendHandler (e) &#123; status = 0&#125; 不用自带滚动条，使用transform+overflow:hidden，监听touchmove事件自实现滚动效果 总结针对网页需要适配的端的不同，可采用不同的解决方案： PC端： 上述1、3 移动端：由上可见，单独的任何一种方法都无法完美适配android和ios，因此需要合并上述方法3、4以达到完美适配（Tip：在测试过程中，发现上述方法3在ios下的某些app中弹出弹层时页面会闪动，且页面弹层会消失，拖动页面才出现，如果要适配的app出现此类问题，最好区分android和ios环境分别采用上述3、4的方法，或者采用上述1、4合并（但是要把body或html的高度设置为屏幕的高度））","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"问题积累","slug":"移动端开发/问题积累","permalink":"http://yoursite.com/categories/移动端开发/问题积累/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"滚动穿透","slug":"滚动穿透","permalink":"http://yoursite.com/tags/滚动穿透/"}]},{"title":"input之type=number","slug":"input之type-number","date":"2019-03-08T06:51:56.000Z","updated":"2019-03-11T10:27:03.371Z","comments":true,"path":"2019/03/08/input之type-number.html","link":"","permalink":"http://yoursite.com/2019/03/08/input之type-number.html","excerpt":"","text":"业务需求页面中存在输入框，点击输入框需要弹出数字键盘，且只能输入合法数字 解决方案 自己开发一个键盘组件 input type=”number” input type=”number”存在的问题（只调查了部分机型，不一定完全准确） 机型 键盘类型 表现 输入限制 ios 自带键盘 调起带数字的特殊符号键盘，可以切换成英文键盘 可以输入任何字符，输入的不是合法的数字，则取到的value为空 ios 非自带键盘 调起数字键盘，可以切换成英文键盘 可以输入任何字符，输入的不是合法的数字，则取到的value为空 android 自带键盘 调起纯数字键盘，可以切换成英文键盘 可以输入数字，-、小数点，输入的不是合法的数字时，取到的value为空 android 非自带键盘 调起纯数字键盘，可以切换成英文键盘 可以输入数字，-、小数点和e，输入的不是合法的数字或带有e时，取到的value为空 由上表可知，尽管input设置了type=”number”，但是在不同的机型与输入法下，所弹出的键盘和能输入的字符是不同的，并不能保证用户输入的是合法的数字，所以我们要对用户的输入进行限制。通过监听input事件，在用户进行输入后，进行正则校验替换非法字符，但是设置了type=”number”后，如果用户输入的不是合法的数字，取到的value为空，根本无法进行合法性校验与替换操作，在Android下还好，它已经帮我们限制了英文、符号等非法字符的输入，用户的输入得到了一定的保证，我们可以在input的blur事件中进行最终的合法性校验，并给予用户一定的提示。但是在ios下，用户可以输入任意的字符，也就是说用户输入非法的字符的可能性提高了很多，若同样在blur事件中进行校验与替换操作，给用户带来的体验过差，所以在ios下使用type=”number”并不可行 那么在ios下是否有其它调起纯数字键盘的方法答案是肯定的，以下两种方法可以调起纯数字键盘，但是调起来的数字键盘是不带小数点的，如果需要输入小数的话，这种方法是不可行的 type=”tel” pattern=”[0-9]*” 如果是webview，调用native的事件貌似可以，但需要native人员的支持 思考综上所诉，type设置为number的方法是不可行的，无法实现我们对用户的输入进行实时的控制，但是把type设置为text，每次调起的都是英文键盘，用户还得切换一下键盘，才能愉快的进行输入，这个体验实在是太糟糕了，如果你的页面只有一个输入框，用户或许还能勉为其难的接受，但是如果存在多个，每次用户进行输入都得切换以下，可能砸手机的心态都有了😡，可见，把type设置为text的方法更加不可行 回到我们的需求 弹出数字键盘 限制用户输入 首先要满足弹出数字键盘，就必须设置type=”number”，但是设置了type=”number”之后，该怎么限制用户的输入呢？把type设回text就行了，于是有了以下处理方案： 1234567891011121314151617181920212223&lt;template&gt; &lt;input type=\"number\" :model=\"price\" @focus=\"focusHandler($event)\" @blur=\"blurHandler($event)\"/&gt;&lt;/template&gt;&lt;script&gt; export default &#123; watch: &#123; price: function () &#123; const newPrice = // 正则替换操作 return newPrice &#125; &#125;, methods: &#123; blurHandler (e) &#123; e.target.type = 'number' &#125;, focusHandler (e) &#123; setTimeOut(() =&gt; &#123; e.target.type = 'text' &#125;, 100) &#125; &#125; &#125;&lt;/script&gt; 在输入框获取焦点，弹起了数字键盘后，再把input的type设回text，这样当用户输入的是非数字字符时，也能获取到正常的value值了，然后进行合法性校验和替换，在失去焦点的时候，再把type设回number，以防下次点击的时候弹出非数字键盘，经过测试这种实现方法在ios下操作正常，但是在android下根本无法弹出键盘，于是有了下面的解决方案 最终方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div class=\"demo\"&gt; &lt;input type=\"number\" class=\"demo--input\" v-model=\"realValue\" @focus=\"inputFocusHandler($event)\" @blur=\"inputBlurHandler($event)\" @input=\"inputHandler\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"DemoInput\", props: &#123; &#125;, data() &#123; return &#123; realValue: \"\" &#125; &#125;, computed: &#123; &#125;, created() &#123; &#125;, watch: &#123; realValue: function(newValue) &#123; let realValue = newValue.replace(/[^0-9.]|(^\\.)/g, \"\") if (realValue.charAt(realValue.length - 1) === \".\") &#123; let tempValue = realValue.slice(0, -1) this.realValue = /\\./g.test(tempValue) ? tempValue : realValue return &#125; this.realValue = realValue &#125; &#125;, methods: &#123; validateValue () &#123; const &#123; realValue &#125; = this // 校验输入的是否是数字 if ( realValue !== \"\" &amp;&amp; !/^[0-9]+(\\.[0-9]+)?$/.test(realValue) ) &#123; this.realValue = \"\" alet('请输入正确的数字！') return false &#125; // 去除数字前面多余的0 if ((/\\./g).test(realValue)) &#123; this.realValue = realValue.replace(/^0+\\./, \"0.\") &#125; else &#123; this.realValue = realValue.replace(/^0+/, \"\") &#125; return true &#125;, inputBlurHandler(e) &#123; if (window.APP_TYPE === \"ios\") &#123; e.target.type = \"number\" &#125; this.validateValue() &#125;, inputHandler(e) &#123; // 长度输入限制 if (this.realValue.length &gt; 7) &#123; this.realValue = this.realValue.slice(0, 7) &#125; &#125;, inputFocusHandler(e) &#123; if (window.APP_TYPE === \"ios\") &#123; setTimeout(() =&gt; &#123; e.target.type = \"text\" &#125;, 100) &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; Tip 移动端自定义指令v-focus仍然无法实现点击某个按钮，使input自动获取焦点，在pc端可行","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"http://yoursite.com/categories/移动端开发/"},{"name":"问题积累","slug":"移动端开发/问题积累","permalink":"http://yoursite.com/categories/移动端开发/问题积累/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"input","slug":"input","permalink":"http://yoursite.com/tags/input/"},{"name":"type=\"number\"","slug":"type-number","permalink":"http://yoursite.com/tags/type-number/"}]},{"title":"八种方法实现CSS页面底部固定","slug":"八种方法实现CSS页面底部固定","date":"2019-03-08T06:42:59.000Z","updated":"2019-03-08T06:44:24.595Z","comments":true,"path":"2019/03/08/八种方法实现CSS页面底部固定.html","link":"","permalink":"http://yoursite.com/2019/03/08/八种方法实现CSS页面底部固定.html","excerpt":"","text":"八种方法实现CSS页面底部固定页面布局： 12345&lt;div id=\"wrap\"&gt; &lt;header id=\"header\"&gt;header&lt;/header&gt; &lt;main id=\"main\"&gt;&lt;/main&gt; &lt;footer id=\"footer\"&gt;footer&lt;/footer&gt;&lt;/div&gt; 通用样式： 123456789101112* &#123; margin: 0; padding: 0;&#125;#header &#123; height: 50px; background: #f00;&#125;#footer &#123; height: 100px; background: yellow;&#125; 解决方案： footer高度固定+绝对定位 1234567891011121314html,body &#123; height: 100%;&#125;#wrap &#123; position: relative; min-height: 100%; box-sizing: border-box; padding-bottom: 100px;&#125;#footer &#123; position: absolute; bottom: 0; width: 100%;&#125; 主体区域设置margin负值 1234567891011121314html, body &#123; height: 100%;&#125;#wrap &#123; height: 100%;&#125;#main &#123; box-sizing: border-box; min-height: 100%; padding-top: 50px; padding-bottom: 100px; margin-top: -50px; margin-bottom: -100px;&#125; header, footer设置margin负值 123456789101112131415html, body, #wrap &#123; height: 100%;&#125;#main &#123; box-sizing: border-box; min-height: 100%; padding-top: 50px; padding-bottom: 100px;&#125;#header &#123; margin-bottom: -50px;&#125;#footer &#123; margin-top: -100px;&#125; 通过设置flex，将footer的margin-top设置为auto 12345678#wrap &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;#footer &#123; margin-top: auto;&#125; 通过calc()计算内容的高度 123#main &#123; min-height: calc(100vh - 150px);&#125; 通过设置flexbox，将主体main设置为flex 12345678#wrap &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;#main &#123; flex: 1;&#125; 使用grid布局 123456789#wrap &#123; display: grid; min-height: 100vh; grid-template-rows: auto 1fr auto;&#125;#footer &#123; grid-row-start: 3; grid-row-end: 4;&#125; display: table 12345678#wrap &#123; display: table; min-height: 100vh;&#125;#main &#123; display: table-row; height: 100%;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"CSS","slug":"编程语言/CSS","permalink":"http://yoursite.com/categories/编程语言/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"底部固定","slug":"底部固定","permalink":"http://yoursite.com/tags/底部固定/"}]},{"title":"深入理解CSS：字体度量、line-height和vertical-align","slug":"深入理解CSS：字体度量、line-height和vertical-align","date":"2019-03-08T06:42:32.000Z","updated":"2019-03-08T06:45:58.664Z","comments":true,"path":"2019/03/08/深入理解CSS：字体度量、line-height和vertical-align.html","link":"","permalink":"http://yoursite.com/2019/03/08/深入理解CSS：字体度量、line-height和vertical-align.html","excerpt":"","text":"参考文档原文： Deep dive CSS: font metrics, line-height and vertical-align - Vincent De Oliveira 译文： 深入理解 CSS：字体度量、line-height 和 vertical-align 深入研究CSS字体度量及CSS 盒子 总结概述line-height, vertical-align涉及到IFC(内联格式化上下文) line-height取值可以为数字或px，数字表示相对于font-size的倍数，默认值为normal，normal取值为1-1.2之间 font-size不同字体，设置相同的font-size，其在页面上所占据的高度是不一样的，原因在于字体本身 字体的定义规则： 字母的高度被称为“em”，在数字化字体中 em 是空间的数字化定义总量。em的大小（以下均写为: EM size）通常是 1000 单位，在 TrueType 字体中，EM size 约定是2的幂，通常是1024或2048。 根据其实际使用的单位，字体的度量可以根据一些设置来决定。注意，有些值是em-square之外的值。 在浏览器中，相对单位是用于缩放用来适应所需的 font-size 字体的设置： 一款字体会定义一个em-square：在字体设计中一个字符所在的空间容器（也被称作“EM size”或者“UPM”）），一般被设定为宽高均为1000的相对单位，也可是1024、2048相对单位 字体度量： baseline (基线): 分隔 ascent 和 descent ，默认字符底端沿 baseline 排列，如图中的P，x，Ё(为俄文字符) ascent (上升): 基线的上部分，字符最高处与 ascent 顶端可能有空白，由 font-family 决定 descent (下降): 基线的下部分，字符最低处与 descent 底端可能有空白，由 font-family 决定 xHeight (X 字高): 小写字符 x 的高度，由 font-family 决定 capHeight (顶面高度): 大些字符 P 的高度，由 font-family 决定 lineSpacing (行间距): 在浏览器中一般 lineSpacing = ascent + descent lineHeight （行高）: 默认等于 lineSpacing，受 line-height 设置影响，如果设置 line-height，lineHeight 等于 line-height。 half-leading (半行距): 如果lineHeight &gt; lineSpacing，则lineHeight 与 lineSpacing 之间会产生上下相等的空隙 (lineHeight - lineSpacing) /2 称为半行距（half-leading或 half lead strips）。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"CSS","slug":"编程语言/CSS","permalink":"http://yoursite.com/categories/编程语言/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"字体度量","slug":"字体度量","permalink":"http://yoursite.com/tags/字体度量/"},{"name":"line-height","slug":"line-height","permalink":"http://yoursite.com/tags/line-height/"},{"name":"vertical-align","slug":"vertical-align","permalink":"http://yoursite.com/tags/vertical-align/"}]},{"title":"Promise原理","slug":"Promise原理","date":"2019-03-08T06:29:37.000Z","updated":"2019-03-08T06:39:14.590Z","comments":true,"path":"2019/03/08/Promise原理.html","link":"","permalink":"http://yoursite.com/2019/03/08/Promise原理.html","excerpt":"","text":"Promise 雏形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Promise(fn) &#123; let callbackList = [] let state = 'pending' let value = null this.then = function(onFulfilled) &#123; return new Promise(resolve =&gt; &#123; // 这里的resolve是then函数新创建的promise对应的resolve函数，与当前promise中的resolve函数不是一个，运用了闭包原理 handler(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;) &#125;) &#125; function handler(callback) &#123; // 如果处于未完成状态 if (state === 'pending') &#123; callbackList.push(callback) // 往当前callbackList队列push新promise对象 return &#125; // 已成功状态 // 如果新的promise对象的onFulfilled为空，即调用then方法时没有正确传入函数，则直接调用promise的resolve函数，并传入then调用链中上一个promise resolve的值 if (!callback.onFulfilled) &#123; callback.resolve(value) return &#125; // 如果新的promise对象的onFulfilled不为空，则调用then方法传入的回调函数，取得函数的返回值，调用promise的resolve函数，传入回调函数的返回值到调用链的下一个then方法中 const ret = callback.onFulfilled(value) callback.resolve(ret) &#125; function resolve(res) &#123; // then中return new Promise()执行拦截 if (res &amp;&amp; (typeof res === 'object' || typeof res === 'function')) &#123; const then = res.then if (typeof then === 'function') &#123; then.call(res, resolve) // res.then(resolve) return &#125; &#125; setTimeout(() =&gt; &#123; state = 'fulfilled' value = res callbackList.forEach((callback, callbackIndex) =&gt; &#123; handler(callback) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 说明这里主要用两个 demo 来解释一下整个 promise 的执行过程 demo11234567891011121314new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) &#125;, 100) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) 执行过程说明： 此处创建了三个 Promise 对象：一个是自己创建的，另外两个是 then 方法创建的 第一次事件循环 执行 Promise 中的方法，把 setTimeout 的回调添加到下个事件循环的事件队列中，new 操作符隐式返回 this 对象（记为 promise1），promise1 的状态为 pending 执行 promise1 的 then 方法，创建 promise2，执行构造 promise2 传入的回调方法时，handler 函数执行的是 promise1 中的 handler 函数，判断 promise1 的状态，此时 promise1 的状态为 pending，把 promise2 push 到 promise1 的 callbackList 队列中，promise1 的 then 方法返回 promise2，promise2 的状态为 pending 执行 promise2 的 then 方法，创建 promise3，执行构造 promise3 传入的回调方法时，handler 函数执行的是 promise2 中的 handler 函数，判断 promise2 的状态，此时 promise2 的状态为 pending，把 promise3 push 到 promise2 的 callbackList 队列中，promise2 的 then 方法返回 promise3，promise3 的状态为 pending 截止到上诉步骤 3，此时 promise1 的 callbackList 中有 promise2，promise2 的 callbackList 中有 promise3，promise3 的 callbackList 为空 第二次事件循环 promise1 的异步方法执行完成，打印 1，往下个事件循环的时间队列中 push callbackList 执行方法 第三次事件循环 开始执行 promise1 的 callbackList，取出 promise2，执行 handler 函数，传入 promise2，此时 promise1 的状态不为 pending，promise2 的 onFulfilled 不为空，执行 onFulfilled 方法，传入 promise1 的 value 值 2，往下个事件循环队列插入回调函数 res=&gt;{setTimeout(()=&gt;{console.log(res)},100)}，返回 undefined，调用 promise2 的 resolve 方法 往下个事件循环的时间队列中 push promise2 的 callbackList 执行方法 第四次事件循环 因为步骤 6 往事件循环中 push 的函数，还没有到执行时机（设置了 100ms，如果设置为 0 会先执行这个），于是执行队列中的下个函数，也就是 promise2 的 callbackList promise2 的状态变为 fulfilled，取出 promise2 callbackList 中的 promise3，此时 promise2 的状态不为 pending，promise3 的 onFulfilled 不为空，执行 onFulfilled 方法，传入 promise2 的返回值 undefine，输出 undefined 在某一事件循环时 100ms 到达，执行步骤 6 的事件，输出 2 所以输出顺序是 1 undefined 2 demo21234567891011121314151617new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) resolve() &#125;, 100) &#125;) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) 执行过程说明： 1-5. 对应上述 1-5 执行 promise2 的 onFulFilled 时，创建了一个中间 promise（mid promise），构造回调传入的参数是 promise2 的 value 值，同样往下个事件循环的事件队列中 push 了 setTimeout 方法，延迟 100ms，但是这时不是返回 undefined，返回的是 mid promise，调用 promise2 的 resolve 方法传入的是 mid promise，命中了 resolve 中的 promise 判断 promise2 resolve 方法中的 pomise 判断命中，并没有往下个事件循环队列中 push promise2 的 callbackList 执行回调，反而调用了 mid promise 的 then 方法，把 promise2 的 resolve 方法作为回调传入 mid promise 的 then 方法执行，创建 promise4，promise4 被 push 到 mid promise 的 callbackList 中，等待 mid promise 被 resolve 在某一事件循环时，假定为 n 100ms 到达，setTimeout 执行，输出 promise2 的 value 值 2，mid promise 被 resolve，mid promise callbackList 被添加到下一个事件循环执行 n+1 次事件循环 mid promise 的 callbackList 中的 promise4 被拿出来执行，而此时的 promise4 的 fulFilled 方法，其实就是 promise2 的 resolve 方法，于是执行 promise2 的 resolve 方法，往下个事件循环的事件队列中 push promise2 的 callbackList 执行回调 n+2 次事件循环 对应上述 9 所以输出顺序为 1 2 undefined 与原Pomise的不一致行为 1234567891011121314new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(2) &#125;, 0)&#125;) .then(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(res) &#125;, 0) &#125;) .then(res =&gt; &#123; console.log(res) &#125;)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"JS之引擎","slug":"JS之引擎","date":"2019-03-08T06:28:57.000Z","updated":"2019-03-08T06:37:05.490Z","comments":true,"path":"2019/03/08/JS之引擎.html","link":"","permalink":"http://yoursite.com/2019/03/08/JS之引擎.html","excerpt":"","text":"JS引擎之Shapes&amp;Inline Caches原文链接译文链接 JS引擎之V8如何优化prototype原文链接译文链接","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"引擎","slug":"引擎","permalink":"http://yoursite.com/tags/引擎/"}]},{"title":"JS之类型转换","slug":"JS之类型转换","date":"2019-03-08T06:27:50.000Z","updated":"2019-03-08T06:33:29.361Z","comments":true,"path":"2019/03/08/JS之类型转换.html","link":"","permalink":"http://yoursite.com/2019/03/08/JS之类型转换.html","excerpt":"","text":"JS之类型转换文档JavaScript核心概念：类型转换 运算符优先级运算符优先级表 ==运算符的隐式转换原则ECMAScript® 2019 : 7.2.14 Abstract Equality Comparison 规范描述：The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is the same as Type(y) then Return the result of performing Strict Equality Comparison x === y. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y). If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. Return false. \bToNumberECMAScript® 2019 : 7.1.3ToNumber ToPrimitiveECMAScript® 2019 : 7.1.1ToPrimitive ( input [ , PreferredType ] ) The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type[尝试转换为原始对象]. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. Conversion occurs according to the following algorithm[如果对象能够转换为多个基本类型，则可以使用可选提示PreferredType来支持该类型。根据以下算法进行转换]: Assert: input is an ECMAScript language value. If Type(input) is Object, then If PreferredType is not present, let hint be “default”. Else if PreferredType is hint String, let hint be “string”. Else PreferredType is hint Number, let hint be “number”. Let exoticToPrim be ? GetMethod(input, @@toPrimitive). If exoticToPrim is not undefined, then Let result be ? Call(exoticToPrim, input, « hint »). If Type(result) is not Object, return result. Throw a TypeError exception. If hint is “default”, set hint to “number”. Return ? OrdinaryToPrimitive(input, hint). Return input. 1234567891011121314151617181920212223242526272829303132333435363738// Assert: input is an ECMAScript language value.function ToPrimitive (input, PreferredType) &#123; if (typeof input === 'object') &#123; let hint = '' switch (typeof PreferredType) &#123; case 'undefined': hint = 'default' break case 'string': hint = 'string' break default: hint = 'number' &#125; let exoticToPrim = GetMethod(input, @@toPrimitive) if (exoticToPrim !== undefined) &#123; let result = Call(exoticToPrim, input, &lt;&lt; hint &gt;&gt;) if (typeof result !== 'object') &#123; return result &#125; else &#123; throw TypeError() &#125; &#125; if (hint === 'default') &#123; hint = 'number' &#125; return OrdinaryToPrimitive(input, hint) &#125; return input&#125; GetMethodECMAScript® 2019 : 7.3.9GetMethod ( V, P ) The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value when the value of the property is expected to be a function. The operation is called with arguments V and P where V is the ECMAScript language value, P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true. Let func be ? GetV(V, P). If func is either undefined or null, return undefined. If IsCallable(func) is false, throw a TypeError exception. Return func. 123456789101112131415// Assert: IsPropertyKey(P) is true.function GetMethod (V, P) &#123; let func = GetV(V, P) if (func === undefined || func === null) &#123; return &#125; if (!IsCallable(func)) &#123; throw TypeError() &#125; return func&#125; IsPropertyKeyECMAScript® 2019 : 7.2.7IsPropertyKey ( argument ) The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key. If Type(argument) is String, return true. If Type(argument) is Symbol, return true. Return false. 1234567891011function IsPropertyKey (argument) &#123; switch (typeof argument) &#123; case 'string': case 'symbol': return true break default: return false &#125;&#125; GetVECMAScript® 2019 : 7.3.2GetV ( V, P ) The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value. If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type of the value. The operation is called with arguments V and P where V is the value and P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true. Let O be ? ToObject(V). Return ? O.[Get]. 123456// Assert: IsPropertyKey(P) is true.function GetV (V, P) &#123; let O = ToObject(V) return O.[[Get]](P, V)&#125; ToObjectECMAScript® 2019 : 7.1.13ToObject ( argument ) The abstract operation ToObject converts argument to a value of type Object according to below Table: Argument Type Result Undefined Throw a TypeError exception. Null Throw a TypeError exception. Boolean Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. Number Return a new Number object whose [[NumberData]] internal slot is set to argument. String Return a new String object whose [[StringData]] internal slot is set to argument. Symbol Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. Object Return argument. 12345678910111213141516171819202122function ToObject (argument) &#123; if (argument === undefined || argument === null) &#123; throw TypeError() &#125; switch (typeof argument) &#123; case 'boolean': return new Boolean(argument) break case 'number': return new Number(argument) break case 'string': return new String(argument) break case: 'symbol': return Symbol(argument) default: return argument &#125;&#125; IsCallableECMAScript® 2019 : 7.2.3IsCallable ( argument ) The abstract operation IsCallable determines if argument, which must be an ECMAScript language value, is a callable function with a [[Call]] internal method. If Type(argument) is not Object, return false. If argument has a [[Call]] internal method, return true. Return false. 123456789101112function IsCallable (argument) &#123; if (typeof argument !== 'object') &#123; return false &#125; if (typeof argument.__proto__.call === 'function') &#123; return true &#125; return false&#125; CallECMAScript® 2019 : 7.3.12Call ( F, V [ , argumentsList ] ) The abstract operation Call is used to call the [[Call]] internal method of a function object. The operation is called with arguments F, V, and optionally argumentsList where F is the function object, V is an ECMAScript language value that is the this value of the [[Call]], and argumentsList is the value passed to the corresponding argument of the internal method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps: If argumentsList is not present, set argumentsList to a new empty List. If IsCallable(F) is false, throw a TypeError exception. Return ? F.[Call]. 123456789101112function Call (F, V, ...argumentsList) &#123; if (!argumentsList) &#123; argumentsList = [] &#125; if (IsCallable(F)) &#123; throw TypeError() &#125; return F.call(V, argumentsList)&#125; OrdinaryToPrimitiveECMAScript® 2019 : 7.1.1.1OrdinaryToPrimitive ( O, hint ) When the abstract operation OrdinaryToPrimitive is called with arguments O and hint, the following steps are taken: Assert: Type(O) is Object. Assert: Type(hint) is String and its value is either “string” or “number”. If hint is “string”, then Let methodNames be « “toString”, “valueOf” ». Else, Let methodNames be « “valueOf”, “toString” ». For each name in methodNames in List order, do Let method be ? Get(O, name). If IsCallable(method) is true, then Let result be ? Call(method, O). If Type(result) is not Object, return result. Throw a TypeError exception. 123456789101112131415161718192021222324// Assert: Type(O) is Object// Assert: Type(hint) is String and its value is either \"string\" or \"number\"function OrdinaryToPrimitive (O, hint) &#123; let methodNames = ['valueOf', 'toString'] if (typeof hint === 'string') &#123; methodNames = ['toString', 'valueOf'] &#125; methodNames.forEach((name, nameIndex) =&gt; &#123; let method = Get(O, name) if (IsCallable(method)) &#123; let result = Call(method, O) if (typeof result !== 'object') &#123; return result &#125; &#125; &#125;) throw TypeError()&#125; GetECMAScript® 2019 : 7.3.1Get ( O, P ) The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object. Assert: IsPropertyKey(P) is true. Return ? O.[Get]. 123456// Assert: Type(O) is Object.// Assert: IsPropertyKey(P) is true.function Get (O, P) &#123; return O.[[Get]](P, O)&#125; [[Get]][ECMAScript® 2019 : 9.1.8[Get]] ( P, Receiver ) When the [[Get]] internal method of O is called with property key P and ECMAScript language value Receiver, the following steps are taken: Return ? OrdinaryGet(O, P, Receiver). 1234function [[Get]] (P, Receiver) &#123; return OrdinaryGet(O, P, Receiver)&#125; OrdinaryGetECMAScript® 2019 : 9.1.8.1OrdinaryGet ( O, P, Receiver )) When the abstract operation OrdinaryGet is called with Object O, property key P, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true. Let desc be ? O.[GetOwnProperty]. If desc is undefined, then. Let parent be ? O.[GetPrototypeOf]. If parent is null, return undefined. Return ? parent.[Get]. If IsDataDescriptor(desc) is true, return desc.[[Value]]. Assert: IsAccessorDescriptor(desc) is true. Let getter be desc.[[Get]]. If getter is undefined, return undefined. Return ? Call(getter, Receiver).","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"JavaScript","slug":"编程语言/JavaScript","permalink":"http://yoursite.com/categories/编程语言/JavaScript/"}],"tags":[{"name":"javascript，类型转换","slug":"javascript，类型转换","permalink":"http://yoursite.com/tags/javascript，类型转换/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-03-08T06:23:21.000Z","updated":"2019-03-08T06:25:41.854Z","comments":true,"path":"2019/03/08/插入排序.html","link":"","permalink":"http://yoursite.com/2019/03/08/插入排序.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930/*插入排序时间复杂度：最好：O(n) 最坏O(n2)算法介绍：https://www.cnblogs.com/hapjin/p/5517667.html*/function insertSort (arr) &#123; if (!(arr instanceof Array)) &#123; return [] &#125; const arrLen = arr.length for (let i = 1; i &lt; arrLen; i++) &#123; let tempNum = arr[i] for (let j = 0; j &lt; i; j++) &#123; if (arr[i] &lt; arr[j]) &#123; arr.splice(i, 1) arr.splice(j, 0, tempNum) break &#125; &#125; &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]insertSort(arr)console.log(arr)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}],"tags":[{"name":"算法，排序","slug":"算法，排序","permalink":"http://yoursite.com/tags/算法，排序/"}]},{"title":"快速排序","slug":"快速排序","date":"2019-03-08T06:23:21.000Z","updated":"2019-03-08T06:26:06.601Z","comments":true,"path":"2019/03/08/快速排序.html","link":"","permalink":"http://yoursite.com/2019/03/08/快速排序.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 快速排序时间复杂度：O(N*logN)算法介绍：http://developer.51cto.com/art/201403/430986.htm疑问点：基数在左边，为什么要从右边先开始查找？答：从代码层面分析，因为最后找到的一个数也就是小标为i的数需要与基数对换，而基数在最左边，说明最后一个数会放到最左边，也就是最后一个数必须必基数小，而从右边开始查找的是必基数小的数，终止查找的可能性：从右侧开始查找终止查找的可能性：1. 前一次对调结束，j找到i所在位置，此时i是比基数小的，i下标对应的数与基数对换没有问题2. 前一次对调结束，j找到最后一个数，这个数比基数小，j停止，i开始查找比基数大的数，走到j的位置，i不小于j，停止，i下标对应的数与基数对换没有问题从左侧开始查找终止查找的可能性：1. 前一次对调结束，i找到j所在位置，此时i是比基数大的，i下标对应的数与基数对换出错2. 前一次对调结束，i找到最后一个数，这个数比基数大，i停止，j开始查找比基数小的数，走到i的位置，i不小于j，停止，i下标对应的数与基数对换出错*/function quickSort (_left, _right, _arr) &#123; if (!(_arr instanceof Array)) &#123; return &#125; if (_left &gt;= _right) &#123; return &#125; let baseNum = _arr[_left] let i = _left let j = _right while (i !== j) &#123; while (_arr[j] &gt;= baseNum &amp;&amp; i &lt; j) &#123; j-- &#125; while (_arr[i] &lt;= baseNum &amp;&amp; i &lt; j) &#123; i++ &#125; if (i &lt; j) &#123; let tempNum = _arr[i] _arr[i] = _arr[j] _arr[j] = tempNum &#125; &#125; _arr[_left] = _arr[i] _arr[i] = baseNum console.log(_arr) quickSort(_left, i - 1, _arr) quickSort(i + 1, _right, _arr)&#125;let arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]// let arr = [5, 80, 55, 40, 42, 85]quickSort(0, arr.length - 1, arr)console.log(arr)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}],"tags":[{"name":"算法，排序","slug":"算法，排序","permalink":"http://yoursite.com/tags/算法，排序/"}]},{"title":"选择排序","slug":"选择排序","date":"2019-03-08T06:23:21.000Z","updated":"2019-03-08T06:26:22.696Z","comments":true,"path":"2019/03/08/选择排序.html","link":"","permalink":"http://yoursite.com/2019/03/08/选择排序.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930/* 选择排序时间复杂度：O(n2)算法介绍：https://www.cnblogs.com/shen-hua/p/5424059.html*/function selectionSort (arr) &#123; if (!(arr instanceof Array)) &#123; console.error('param type is not array!') return [] &#125; for (let i = 0; i &lt; arr.length; i++) &#123; let minNumIndex = i let tempNum = arr[i] for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minNumIndex]) &#123; minNumIndex = j &#125; &#125; arr[i] = arr[minNumIndex] arr[minNumIndex] = tempNum &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]selectionSort(arr)console.log(arr)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}],"tags":[{"name":"算法，排序","slug":"算法，排序","permalink":"http://yoursite.com/tags/算法，排序/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2019-03-08T06:23:21.000Z","updated":"2019-03-08T06:25:23.658Z","comments":true,"path":"2019/03/08/冒泡排序.html","link":"","permalink":"http://yoursite.com/2019/03/08/冒泡排序.html","excerpt":"","text":"12345678910111213141516171819202122232425/* 冒泡排序时间复杂度：O(n2)算法介绍：https://blog.csdn.net/shuaizai88/article/details/73250615*/function bubbleSort (arr) &#123; if (!(arr instanceof Array)) &#123; return [] &#125; for (let i = arr.length - 1; i &gt; 0; i--) &#123; for (let j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; let tempNum = arr[j] arr[j] = arr[j - 1] arr[j - 1] = tempNum &#125; &#125; &#125;&#125;let arr = [5, 2, 8, 4, 9, 1]bubbleSort(arr)console.log(arr)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}],"tags":[{"name":"算法，排序","slug":"算法，排序","permalink":"http://yoursite.com/tags/算法，排序/"}]},{"title":"VueRouter之打开新的标签页","slug":"VueRouter之打开新的标签页","date":"2019-03-08T06:20:37.000Z","updated":"2019-03-08T06:21:24.623Z","comments":true,"path":"2019/03/08/VueRouter之打开新的标签页.html","link":"","permalink":"http://yoursite.com/2019/03/08/VueRouter之打开新的标签页.html","excerpt":"","text":"router-link添加target=”_blank”属性 window.open 12const &#123; href &#125; = this.$router.resolve(location, current ?, append ?) // 解析目标位置window.open(href, '_blank')","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"},{"name":"window.open","slug":"window-open","permalink":"http://yoursite.com/tags/window-open/"}]},{"title":"Vue之清空表单","slug":"Vue之清空表单","date":"2019-03-08T06:16:02.000Z","updated":"2019-03-08T06:17:56.726Z","comments":true,"path":"2019/03/08/Vue之清空表单.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之清空表单.html","excerpt":"","text":"简单的的表单如果所有表单控件都处于当前页面，不包含组件，且都是双向绑定的数据，则清空值就行了 复杂的表单如果表单包含组件级别的控件，层级较深，可以使用一种hack的手段，通过v-if重新渲染组件，清空组件内input里的值，选中的复选框等等，同时将页面内的相关数据清空就行了，如图所示：","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"form","slug":"form","permalink":"http://yoursite.com/tags/form/"}]},{"title":"Vue之改变路由页面回到顶部","slug":"Vue之改变路由页面回到顶部","date":"2019-03-08T06:11:30.000Z","updated":"2019-03-08T06:15:11.019Z","comments":true,"path":"2019/03/08/Vue之改变路由页面回到顶部.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之改变路由页面回到顶部.html","excerpt":"","text":"问题描述vue是单页应用，通过改变hash值来实现不同页面之前的跳转，当一个页面滚动到底部时，然后跳转到另一个也面，同样会在页面底部，并不会回到顶部 vue-router scrollBehavior当创建一个router实例时，可以提供一个scrollBehavior方法控制路由跳转时页面滚动条的位置 123456const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // return 期望滚动到哪个的位置 &#125;&#125;) 具体的使用方法点这里，但是该方法只在支持history.pushState的浏览器中可用，移动端不存在问题，pc端IE10+以上，因此对pc端的解决方法进行了探索 vue-router beforeEach&amp;afterEach中回到顶部操作存在的问题123router.afterEach((to, from, next) =&gt; &#123; document.documentElement.scrollTop = 0&#125;) 以上方法在跳转页面时页面会闪烁一下，原因是因为dom的更新操作在触发afterEach的回调函数之后进行，也就是所触发afterEach函数的时候，页面的dom其实还是旧的页面的dom，所以当设置滚动条的位置时，会在旧页面先回到顶部，再更新成新页面的dom，下面是vue-router完整的导航解析流程： 利用定时器利用定时器将更改滚动条位置的操作放入到macrotasks事件队列末尾，即在更新dom操作之后就可以解决页面闪烁的问题了 12345router.afterEach((to, from, next) =&gt; &#123; setTimeout(() =&gt; &#123; document.documentElement.scrollTop = 0 &#125;, 0)&#125;) 还有一个问题是，当刷新当前页面的时候，浏览器会记录当前页面滚动条，并在刷新页面后将滚动条的位置恢复到刷新页面之前，测试了两种浏览器，表现不一致： chrome：先回到页面顶部-&gt;再回到刷新之前位置，导致页面闪烁 firefox：回到页面顶部 为了解决上述问题，需要对刷新页面的时候进行额外处理，不回到页面顶部，可以根据afterEach回调函数的from参数来判断，当刷新页面或第一次进入页面时，from.name为null： 12345router.afterEach((to, from, next) =&gt; &#123; from.name &amp;&amp; setTimeout(() =&gt; &#123; document.documentElement.scrollTop = 0 &#125;, 0)&#125;)","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"}]},{"title":"video标签使用v-show播放失败","slug":"video标签使用v-show播放失败","date":"2019-03-08T06:06:52.000Z","updated":"2019-03-08T06:10:20.423Z","comments":true,"path":"2019/03/08/video标签使用v-show播放失败.html","link":"","permalink":"http://yoursite.com/2019/03/08/video标签使用v-show播放失败.html","excerpt":"","text":"video source src 异步赋值播放失败如图所示，v-show控制video标签是否显示，showVideo初始值为false，模拟接口异步返回视频链接，然后改变视频的src，但此时视频没有成功播放，Network中也没有去加载对应的视频资源 Why?大家都知道v-show控制的css的visibility属性，实际上无论v-show的值是true或者false都会去渲染dom，可见，视频播放失败跟v-show并没有多大的关系，于是我们把v-show去了验证一下： 同样，视频也播放失败，并且Network中也没有视频资源的加载记录，由此可推断，当video中存在source标签的时候，浏览器渲染之后会自动去加载src对应的资源，后续即便地址改变，浏览器也不会再去获取资源 解决方法 src属性添加到video标签上 使用v-if替代v-show，触发dom重排 触发video的load方法","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"video","slug":"video","permalink":"http://yoursite.com/tags/video/"},{"name":"v-show","slug":"v-show","permalink":"http://yoursite.com/tags/v-show/"}]},{"title":"Vue之Dom复用","slug":"Vue之Dom复用","date":"2019-03-08T05:53:19.000Z","updated":"2019-03-08T06:08:24.780Z","comments":true,"path":"2019/03/08/Vue之Dom复用.html","link":"","permalink":"http://yoursite.com/2019/03/08/Vue之Dom复用.html","excerpt":"","text":"问题描述 如上图所示，页面中通过遍历数组循环出n个组件，并传入msg值在组件中显示，点击删除按钮时，触发父组件的方法，删除该组件，在页面中我们进行如下操作： 在3个输入框中依次输入1，2，3 点击第二个删除按钮 成功删除组件，但最终效果并不是我们所期望的下图中的样子 Why ？Vue组件复用问题，这个问题涉及到Vue的diff算法，这里只做简单概述，如果想要详细了解，请参考文档Vue diff算法原理，Vue为了使得更新dom时更加的有效率，在更新数据后，重新渲染dom时，会对比同层dom节点的类型（标签类型或自定义组件类型）是否相同，如果相同，则直接复用之前的组件，只进行数据的更新，放到这个例子里，说白了，当前剩下的两个输入框组件其实是之前3个中的前2个，因为msg是通过prop传入到子组件的，所以当改变arr数组时，触发dom更新，虽然复用了之前的2个组件，但传入的prop是会改变的，但因为input框是存在于子组件本身，并没有依赖父元素的值，所以input框里的值是不会变的 :key=”index”存在的问题很多人为了规避编辑器的错误提示，会在循环时加上:key=”index”，这并没有改变vue的diff算法，与没加的效果是一样的，所有组件内的值都需要重新渲染一次： 如上图所示，第一次遍历arr时，arr中的3个值1,2,3对应的arrIndex的分别是0，1，2，当删除第二个组件时，arr为[1,3]，重新遍历渲染时，1，3对应的arrIndex分别为0，1，相当于复用了之前arrIndex为0，1的两个组件，也就是跟没加:key=”index”所产生的效果是相同的，这就是为什么加了:key=”arrIndex”还是无法达到我们所期望的效果 :key=”唯一id”这种情况下，可以给arr中的每一项生成一个不可变的唯一id，则删除时，就能根据唯一id去准确的找到其之前所对应的dom了，达到准确复用","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"},{"name":"Vue","slug":"框架/Vue","permalink":"http://yoursite.com/categories/框架/Vue/"},{"name":"问题积累","slug":"框架/Vue/问题积累","permalink":"http://yoursite.com/categories/框架/Vue/问题积累/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"深入浅出NodeJs（读书笔记）","slug":"深入浅出NodeJs（读书笔记）","date":"2019-03-08T05:36:14.000Z","updated":"2019-03-08T05:49:02.478Z","comments":true,"path":"2019/03/08/深入浅出NodeJs（读书笔记）.html","link":"","permalink":"http://yoursite.com/2019/03/08/深入浅出NodeJs（读书笔记）.html","excerpt":"","text":"第一章 Node简介 在Node中，绝大多数的操作都是以异步的方式进行调用 Node相比于其它大多数后端语言的独特之处：事件驱动、异步、回调函数 Node保持了JS在浏览器中单线程的特点。在Node中，JS与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换带来的性能上的开销。单线程的弱点： 无法利用多核CPU 错误会引起整个应用退出，应用的健壮性值得考验 大量计算占用CPU导致无法继续调用异步I/O Node的应用场景： I/O密集型：从单线程的角度来说，Node处理I/O的能力是值得竖起拇指称赞的。通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集型的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少 CPU密集型：CPU密集型应用给Node带来的挑战主要是：由于JS单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可以同事享受到并行异步I/O的好处，又能充分利用CPU 身为单线程的应用，Node如何能够充分的利用CPU? Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现 通过创建子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU Node使用者的各自倚重点： 前后端编程语言环境统一 Node带来的高性能I/O用于实时应用 并行I/O使得使用者可以更高效的利用分布式环境 并行I/O，有效利用稳定接口提升Web渲染能力 云计算平台提供Node支持 游戏开发领域 工具类应用 第二章 模块机制 在Web1.0时代，对于JS自身而言，它的规范是薄弱的，存在以下缺陷： 没有模块系统 标准库较少 没有标准接口 缺乏包管理系统 CommonJS规范 模块引用：var mathModule = require(‘mathModule’) 模块导出：exports.add = function (x, y) { return x + y } Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，在Node中引入模块，需要经历如下3个步骤： 路径分析 文件定位 编译执行 在Node中模块分为两类： 核心模块：核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的 文件模块：是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢 与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。 模块标识符分析 模块表示符的分类： 核心模块，如https、fs、path等 .或..开始的相对路径文件模块 以/开始的绝对路径文件模块 非路径形式的文件模块，如自定义的connect模块 Node模块加载顺序：核心模块 &gt; 文件模块 &gt; 自定义模块（需要按照module.paths路径一层层向上寻找，直到找到目标文件或系统根目录为止） CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。 模块编译，每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上 12345678910111213// 在Node中，每个文件模块都是一个对象，它的定义如下function Module(id, parent) &#123; this.id = id this.exports = &#123;&#125; this.parent = parent if (parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null this.loaded = false this.children = []&#125; 对于不同的文件扩展名，模块载入的方法也有所不同 .js文件：通过fs模块同步读取文件后编译执行 .node文件：这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件 .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果 其余扩展名文件：它们都被当做.js文件载入 npm install -g是将一个包安装为全局可用的可执行命令 前端模块化 CommonJS：CommonJS用同步的方式加载模块，在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载 AMD：异步模块定义，采用异步的方式加载模块，模块的加载不影响后面语句的执行，依赖前置，提前执行，定义模块时要对其依赖进行声明 CMD：通用模块定义，依赖就近，在需要时进行引入，延迟执行（并不是延迟加载），相对于AMD，更贴近CommonJS规范和Node Modules规范 ES6 Module，与CommonJS模块的差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载” 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 第三章 异步I/O 为什么要异步I/O，这与Node面向网络而设计不无关系，具体到实处，从以下两个方面说起： 用户体验：在浏览器中，JS在单线程上执行，且与UI渲染共用一个线程，这意味着当JS执行的时候，UI的渲染和响应是处于停滞状态的。如果网页需要临时获取一个资源，通过同步的方式获取，这期间UI将停顿，不响应用户的交互行为，可以想象，这样的用户体验将会多差。而采用异步请求，在资源的下载期间，JS和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。前端可以通过异步消除掉UI阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度，例如：两个资源获取耗时为M、N，如果采用同步方式耗时为M+N，异步方式则为Max(M, N)，因此只有后端能够快速响应资源，才能让前端的体验编号。 资源分配：多线程的代价在于创建线程和执行期线程上下文切换的开销较大，另外，在复杂的业务中，多线程编程经常面临着锁和状态同步的问题。单线程的缺点在于性能，同步的编程模型导致的问题是，任意一个略慢的任务都会导致后续执行代码被阻塞，着造成资源不能被更好的利用。操作系统会将CPU的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升影响能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组人物而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间会比较长。因此，Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU。为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中的Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。 从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事 操作系统内核对于I/O只有两种方式： 阻塞I/O：调用之后一定要等到系统内核层面完成所有操作后，调用才结束，造成CPU等待I/O，浪费等待事件，CPU的处理能力不能得到充分利用 非阻塞I/O：调用之后立即返回非阻塞I/O返回之后，CPU的时间片可以用力处理其他事物，此时的性能提升是明显的。但非阻塞I/O也存在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层渴望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询 阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完成完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费 轮询技术： read select poll epoll：该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高 kqueue：该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在 非阻塞I/O对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU幺妹用于遍历文件描述符的状态，要么用于休眠等待事件发生，对于当前线程而言利用率不够，理想的异步I/O是应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务。采用多线程的方式，通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O。 Node是单线程的，这里的单线程仅仅只是JS执行在单线程中罢了。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池 Node的异步I/O 事件循环：在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者：每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件，一个观察者里可能有多个事件，在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事情的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者哪里，事件循环则从观察者那里取出事件并处理。在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。 请求对象：从JS发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理 执行回调：线程池中的I/O操作调用完毕之后，会将结果存储在请求对象（req-&gt;result）属性上，然后通知IOCP，告知当前对象操作以完成。在每次Tick的执行中，它会调用IOCP相关的方法检查线程池中是否有执行完成的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JS中传入的回调函数的目的。事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 非I/O的异步API 定时器：调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒。 process.nextTick()：相当于setTimeout(fn, 0)，而由于时间循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。实际上，process.nextTick()方法的操作相对较为轻量。每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。 setImmediate()：setImmediate()方法与procee.nextTick()方法十分类似，都是将回调函数延迟执行。process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。在具体实现上，process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。之所以这样设计，是为了保证每次每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O调用的情况。 服务器模型： 同步式：对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多 每线程/每请求：为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销。知名服务器Nginx，也摒弃了多线程的方式，采用了和Node相同的事件驱动，不同之处在于Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。 第四章 异步编程 函数式编程 高阶函数：可以把函数作为参数，或是将函数作为返回值的函数 偏函数：通过指定部分参数来产生一个新的定制函数的形式就是偏函数 异步编程优势：Node带来的最大特效莫过于基于事件驱动的非阻塞I/O模型，非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。利用事件循环的方式，JS线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，这个模型的缺点则在于管家无法承担过多的细节性任务，如果承担太多，则会影响到任务的调度，管家忙个不停，小二却得不到活干，结局则是整体效率的降低。换言之，Node是为了解决编程模型中阻塞I/O性能问题的，采用了单线程模型，这导致Node更像一个处理I/O密集型的能手，而CPU密集型则取决于管家的能耐如何。由于事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的CPU时间片。至于是计算密集型，还是I/O密集型，只要计算不影响异步I/O的调度，那就不构成问题。建议对CPU的耗用不要超过10ms，或者将大量的计算分解为诸多的小量计算，通过setImmediate()进行调度。只要合理利用Node的异步模型和V8的高性能，就可以充分发挥CPU和I/O资源的优势。 异步编程的难点： 异常处理：过去我们处理异常时，通常使用类Java的try/catch/final语句块进行异常捕获。但是这对于异步编程不一定适用。第3章提到过，异步I/O的实现主要包含两个阶段：提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用。 12345678910var async = function (callback) &#123; process.nextTick(callback)&#125;// 只能捕获当次事件循环内的异常，对callback执行时抛出的异常无能为力try &#123; async(callback)&#125; catch (e) &#123; // TODO&#125; Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出： 123async(function (err, results) &#123; // TODO&#125;) 在我们自行编写的异步方法上，也需要去遵循这样一些原则： 原则1：必须执行调用者传入的回调函数 原则2：正确传递回异常供调用者判断 函数嵌套过深：对于Node而言，事务中存在多个异步调用的场景比比皆是，函数嵌套过深导致代码难以阅读 阻塞代码：Node中没有sleep()这样的线程沉睡功能，唯独能用于延时操作的只有setTimeout()和setInterval()这两个函数。但是这两个函数并不能阻塞后续代码的执行。所以，有多半开发者会写出下述这样的代码来实现sleep(1000)的效果： 12345var start = new Date()while (new Date() - start &lt; 1000) &#123; // TODO&#125;// 需要阻塞的代码 但是事实是糟糕的，这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于为这段代码服务，导致其余任何请求都会得不到响应。 遇见这样的需求时，在同一规划业务逻辑之后，调用setTimeout()的效果会更好。 多线程编程：JS运行在单线程之上，没有充分利用多核CPU，浏览器采用Web Workers，Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。 异步转同步 异步编程解决方案： 事件发布/订阅模式：Node自身提供events模块，它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的时间监听模式的方法实现。值得一提的是，Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的。下面为两个具体的细节点： 如果对一个事件添加了超过10个侦听器，将会得到一个警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏。调用emitter.setMaxListeners(0)，可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了异常处理，EventEmitter对象对error事件进行了特殊对待。如果允许期间的错误触发了error事件，EventEmitter会检查是否有队error事件添加过侦听器。如果添加了，这个错误将会交由改侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该多error事件做处理。 继承events模块 123456var events = require('events')function Stream() &#123; events.EventEmitter.call(this)&#125;util.inherits(Stream, events.EventEmitter) 利用事件队列解决雪崩问题：所谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。 以下是一条数据库查询语句的调用： 12345var select = function (callback) &#123; db.select('SQL', function (results) &#123; callback(results) &#125;)&#125; 如果站点刚好启动，这时缓存中是不存在数据的，而如果访问量巨大，同一句SQL会被发送到数据库中反复查询，会影响服务的整体性能。一种改进方案是添加一个状态锁，相关代码如下： 123456789101112var status = 'ready'var select = function (callback) &#123; if (status !== 'ready') &#123; return &#125; status = 'pending' db.select('SQL', function (results) &#123; status = 'ready' callback(results) &#125;)&#125; 但是在这种情况下，连续地多次调用select()时，只有第一次调用是生效的，后续的select()是没有数据服务的，这个时候可以引入事件队列，相关代码如下： 123456789101112131415var proxy = new events.EventEmitter()var status = 'ready'var select = function (callback) &#123; proxy.once('selected', callback) if (status !== 'ready') &#123; return &#125; status = 'pending' db.select('SQL', function (results) &#123; proxy.emit('selected', results) status = 'ready' &#125;)&#125; 此处可能因为存在侦听器过多引发警告，需要调用setMaxListeners(0)移除警告，或者设置更大的警告阈值 多异步之间的协作方案 这里我们尝试通过原生代码解决“难点2”中为了最终结果的处理而导致可以并行调用但实际只能串行执行的问题。这里以渲染页面所需要的模板读取、数据读取和本地化资源读取为例简要介绍一下，相关代码如下： 1234567891011121314151617181920var count = 0var results = &#123;&#125;var done = function (key, value) &#123; results[key] = value count++ if (count === 3) &#123; render(results) &#125;&#125;fs.readFile(template_path, 'utf8', function (err, template) &#123; done('template', template)&#125;)db.query(sql, function (err, data) &#123; done('data', data)&#125;)l10n.get(function (err, resources) &#123; done('resources', resources)&#125;) 由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量。这里可以利用偏函数来处理哨兵变量和第三方函数的关系，相关代码如下： 1234567891011121314var after = function (times, callback) &#123; var count = 0 var results = &#123;&#125; return function (key, value) &#123; results[key] = value count++ if (count === times) &#123; callback(results) &#125; &#125;&#125;var done = after(3, render) 上述方案实现了多个事件对应一个侦听器的目的。如果业务继续增长，我们依然可以继续利用发布/订阅方式来完成多对多的方案，相关代码如下： 123456789101112131415var emitter = new events.Emitter()var done = after(times, render)emitter.on('done', done)emitter.on('done', other)fs.readFile(template_path, 'utf8', function (err, template) &#123; emitter.emit('done', 'template', template)&#125;)db.query(sql, function (err, data) &#123; emitter.emit('done', 'data', data)&#125;)l10n.get(function (err, resources) &#123; emitter.emit('done', 'resources', resources)&#125;) 在上面的方法中，有一个令调用者不那么舒服的问题，那就是调用者要去准备这个done()函数，以及在回调函数中需要从结果把数据一个个提取出来，再进行处理。 另一个方案则是来自于笔者自己写的EventProxy模块，相关代码如下： 123456789101112131415var proxy = new EventProxy()proxy.all('template', 'data', 'resources', function (template, data, resource) &#123; //TODO&#125;)fs.readFile(template_path, 'utf8', function (err, template) &#123; proxy.emit('template', template)&#125;)db.query(sql, function (err, data) &#123; proxy.emit('data', data)&#125;)l10n.get(function (err, resources) &#123; proxy.emit('resources', resources)&#125;) Promise/Deferred模式：使用事件的方式，执行流程需要被预先设定。Promise/Deferred模式可以先执行异步调用，延迟传递处理方 12345678910111213// 普通Ajax调用$.get('/api', &#123; success: onSuccess, error: onError, complete: onComplete&#125;)// Promise/Deferred模式$.get('/api') .success(onSuccess) .success(onSuccess1) .error(onError) .complete(onComplete) 这使得即使不调用success()、error()等方法，Ajax也会执行，并且可以处理多个回调 Promise/Deferred模式发布在CommonJS规范中，CommonJS草案目前已经抽象出了Promises/A、Promises/B、Promises/D这样典型的异步Promise/Deferred模型 Promises/A： Promise/A提议对单个异步操作做出了这样的抽象定义： Promise操作只会处在3种状态的一种：未完成态、完成态和失败态 Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化 Promise的状态一旦转化，将不能被更改在API的定义上，一个Promise对象只要具备then()方法即可。对于then()方法，有以下要求： 接受完成态、错误态的回调方法 可选地支持progress事件回调作为第三个方法 then()方法只接受function对象，其余对象将被忽略 then()方法继续返回Promise对象，以实现链式调用then()方法定义如下： 1then(fulfilledHandler, errorHandler, progressHandler) 为了演示Promises/A提议，这里我们尝试通过继承Node的events模块来完成一个简单的实现，相关代码如下： 123456789101112131415161718192021var Promise = function () &#123; EventEmitter.call(this)&#125;util.inherits(Promise, EventEmitter)Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; if (typeof fulfilledHandler === 'function') &#123; // 利用once方法，保证成功回调只执行一次 this.once('success', fulfilledHandler) &#125; if (typeof errorHandler === 'function') &#123; this.once('error', errorHandler) &#125; if (typeof progressHandler === 'function') &#123; this.on('progress', progressHandler) &#125; return this&#125; 这里看到then()方法所做的事情就是将回调函数存放起来。为了完成整个流程，还需要触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred，即延迟对象，实例代码如下： 123456789101112131415161718var Deferred = function () &#123; this.state = 'unfulfilled' this.promise = new Promise()&#125;Deferred.prototype.resolve = function (obj) &#123; this.state = 'fulfilled' this.promise.emit('success', obj)&#125;Deferred.prototype.reject = function (err) &#123; this.state = 'failed' this.promise.emit('error', err)&#125;Deferred.prototype.progress = function (data) &#123; this.promise.emit('progress', data)&#125; Promise中的多异步协作 1234567891011121314151617181920Deferred.prototype.all = function (promises) &#123; let count = promises.length let results = [] const that = this promises.forEach(function (promise, i) &#123; promise.then(function (data) &#123; count-- results[i] = data if (count === 0) &#123; that.resolve(results) &#125; &#125;, function (err) &#123; that.reject(err) &#125;) &#125;) return this.promise&#125; Promise的进阶知识 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 让promise支持链式调用var Deferred = function () &#123; this.promise = new Promise()&#125;// 完成态Deferred.prototype.resolve = function (obj) &#123; var promise = this.promise var handler while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.fulfilled(obj)) &#123; var ret = handler.fulfilled(obj) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 失败态Deferred.prototype.reject = function (obj) &#123; var promise = this.promise var handler while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.error(obj)) &#123; var ret = handler.error(obj) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 生成回调函数Deferred.prototype.callback = function () &#123; var that = this return function (err, file) &#123; if (err) &#123; return that.reject(err) &#125; that.resolve(file) &#125;&#125;var Promise = function () &#123; // 队列用于存储待执行的回调函数 this.queue = [] this.isPromise = true&#125;Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; var handler = &#123;&#125; if (typeof fulfilledHandler === 'function') &#123; handler.fulfilled = fulfilledHandler &#125; if (typeof errorHandler === 'function') &#123; handler.error = errorHandler &#125; this.queue.push(handler) return this&#125;// 验证var readFile1 = function (file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;var readFile2 = function (file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;readFile1('file1.txt', 'utf8') .then(function (file1) &#123; return readFile2(file1.trim(), 'utf8') &#125;) .then(function (file2) &#123; console.log(file2) &#125;) 要让Promise支持链式执行，主要通过以下两个步骤： 将所有回调都存到队列中 Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象promise引用改变为新的Promise对象，并将队列中余下的回调转交给它 将API Promise化 123456789var smooth = function (method) &#123; return function () &#123; var deferred = new Deferred() var args = Array.prototype.slice.call(arguments, 1) args.push(deferred.callback()) method.apply(null, args) return deferred.promise &#125;&#125; 流程控制库： 尾触发与Next 1234567891011121314151617181920212223242526272829303132333435363738function offWork(data, next) &#123; console.log('上班ing。。。') setTimeout(function() &#123; console.log('下班了。。。') next('传给下个任务的数据') &#125;, 1000)&#125;function backHome(data, next) &#123; console.log('上个任务传过来的数据为：' + data) setTimeout(function() &#123; console.log('到家了！！！') next('传给下个任务的数据') &#125;, 1000) console.log('回家ing。。。')&#125;App = &#123; handles: [], use: function(handle) &#123; if (typeof handle == 'function') App.handles.push(handle) &#125;, next: function(data) &#123; var handlelist = App.handles var handle = null var _next = App.next if ((handle = handlelist.shift()) != undefined) &#123; handle.call(App, data, _next) &#125; &#125;, start: function(data) &#123; App.next(data) &#125;&#125;App.use(offWork)App.use(backHome)App.start() async：流程控制模块 无依赖异步的串行执行：async.series(asyncFnArray, callback) 依赖异步的串行执行：async.waterfall(asyncFnArray, callback) 异步的并行执行：async.parallel(asyncFNArray, callback) 自动依赖处理：async.auto(depsArray) Step：流程控制模块 依赖异步的串行执行：this 并行执行任务：this.parallel() 结果分组：this.group() wind：$await使得代码看起来像同步的代码 async/await 流程控制小结：事件发布/订阅模式相对算是一种较为原始的方式，Promise/Deferred模式贡献了一个非常不错的异步任务模型的抽象。而上述的这些异步流程控制方案与Promise/Deferred模式的思路不同，Promise/Deferred的重头在于封装异步的调用部分，流程控制库则显得没有模式，将处理重点放置在回调函数的注入上。从自由度上来讲，async、Step这类流控库相对灵活得多。 异步并发控制：异步并发量过大，会导致服务器崩溃。 bagpipe的解决方案： 通过一个队列来控制并发量 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行 如果活跃调用达到限定值，调用暂时存放在队列中 每个异步调用结束时，从队列中取出新的异步调用执行 async的解决方案：parallelLimit() 第五章 内存控制 V8对内存的使用进行了限制 V8的对象分配：在V8中，所有的JS对象都是通过堆来进行分配的，Node提供了process.memoryUsage()方法查看内存使用量，V8同样限制了堆的使用大小，表层原因是因为V8最初为浏览器设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制。按官方的说话，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JS线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。当然，这个限制也不是不能打开，Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小 V8的垃圾回收机制：V8的垃圾回收策略主要基于分代式垃圾回收机制，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法 V8的内存分代：在V8中，主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，上述的–max-old-space-size和–max-new-space-size分别对应设置老生代和新生代内存的大小，老生代内存在64位系统和32位系统下分别只能使用约1.4GB和约0.7GB的大小，对于新生代内存，它由两个reserved_semispace_size_所构成，按机器位数的不同，reserved_semispace_size_在64位系统和32位系统下分别为16MB和8MB的大小，所以新生代内存的最大值在64位系统和32位系统上分别为32MB和16MB，V8堆内存的最大保留空间为：4 * reserved_semispace_size_ + ax-old-space-size_，因此，默认情况下，V8堆内存的最大值在64位系统上为1464MB，32位系统上则为732MB。 Scavenge算法：在分代的基础上，新生代对中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：将新生代内存堆等分为两个semispace，一个为From，另一个为To，当垃圾回收开始时，会从From空间中拷贝存活的对象到To空间，而非存活对象的空间将会被释放，完成复制后，From空间和To空间的角色发生对换。在一定条件下，需要将存货周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制（25%）。 Mark-Sweep：标记清除，Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 Mark-Compact：标记整理，为了解决Mark-Sweep的内存碎片问题。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。 Mark-Sweep &amp; Mark-Compact两者结合：由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact Incremental Marking：为了避免出现JS应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用程序，对于新生代来说，默认配置得较小，且其中存活对象通常较少，全停顿（stop-the-world）的影响不大。但老生代通常配置的较大，且存活对象较多，全堆垃圾回收的标记、清理、整理等动作造成的停顿会比较可怕，因此，V8引入了增量标记、并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。 V8的垃圾回收机制分为新生代和老生代。 新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。 老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。 高效使用内存 如果变量是全局变量（不通过var声明或定义在global变量上），其引用对象常驻在内存中（老生代中），可通过delete操作来删除引用关系或者将变量重新赋值，在接下来的老生代内存清除和整理过程中，会被回收释放。在V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好 闭包 Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。利用堆外内存可以突破内存限制，例如，Buffer对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。 内存泄漏 通常，造成内存泄漏的原因有如下几个： 缓存 队列消费不及时 作用域未释放 缓存限制策略：采用LRU算法的缓存失效策略 直接将内存作为缓存使用，除了限制缓存的大小外，另外要考虑的事情是，进程之前无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身部存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。它的好处很多，在Node中主要可以解决以下两个问题： 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效 进程之间可以共享缓存 大内存应用： stream模块 Buffer操作 第六章 理解Buffer Buffer对象类似于数组，用于操作字节，它的元素为16进制的两位数，即0到255的数值 Buffer内存分配 采用slab分配机制，slab是一种动态内存管理机制，简单而言，slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态： full：完全分配状态 partial：部分分配状态 empty：没有被分配状态 Node以8KB为界限来区分Buffer是大对象还是小对象，Buffer.poolSize = 8 * 1024，这个8KB的值也就是每个slab的大小值，在JS层面，以它作为单位单元进行内存的分配 真正的内存是在Node的C++层面提供的，JS层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JS到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作 Buffer的转换 字符串转Buffer：new Buffer(str, [encoding])、buf.write(string, [offest], [length], [encoding]) Buffer转字符串：buf.toString([encoding], [start], [end]) Buffer不支持的编码类型：可通过iconv、icon-lite模块进行转换 Buffer的拼接：Buffer在使用场景中，通常是以一段一段的方式传输 12345678910var fs = require('fs')var rs = fs.createReadStream('test.md')var data = ''rs.on('data', function (chunk) &#123; data += chunk // 隐藏了toString()操作，等价于data = data.toString() + chunk.toString()&#125;)rs.on('end', function () &#123; console.log(data)&#125;) 上述代码对于英文，toString()不会造成任何问题，但对于宽字节的中文，却会形成问题，中文字在UTF-8下占3个字节，当这3个字节分部在上述代码中的不同chunk时，会造成这3个字节以乱码的形式呈现， setEncoding()与string_decoder()：可读流可通过readable.setEncoding(encoding)设置编码方式，让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。事实上，在调用setEncoding()时，可读流对象在内部设置了一个decoder对象，StringDecoder在得到编码后，知道宽字节字符在UTF-8编码下是以3个字节的方式存储的，所以当输出时不满足3个字符的条件时，会将剩余字符和后续输出的字符合并，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了，但是它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码 正确拼接Buffer 12345678910111213141516171819202122232425262728293031323334353637383940414243var chunks = []var size = 0res.on('data', function (chunk) &#123; chunks.push(chunk) size += chunk.length&#125;)res.on('end', function () &#123; var buf = Buffer.concat(chunks, size) var str = iconv.decode(buf. 'utf8') console.log(str)&#125;)Buffer.concat = function (list, length) &#123; if (!Array.isArray(list)) &#123; throw new Error('Usage: Buffer.concat(list, [lenght])') &#125; if (list.length === 0) &#123; return new Buffer(0) &#125; if (list.length === 1) &#123; return list[0] &#125; if (typeof length !== 'number') &#123; length = 0 for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i] length += buf.length &#125; &#125; var buffer = new Buffer(length) var pos = 0 for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i] buf.copy(buffer, pos) pos += buf.length &#125; return buffer&#125; Buffer与性能 在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转化为Buffer，以进行二进制数据传输，字符串与Buffer的转换有性能损耗，在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。 在文件的读取时，有一个highWaterMark设置对性能的影响至关重要，主要有两个影响的点： highWaterMark设置对Buffer内存的分配和使用有一定影响，当读取一个相同的大文件时，highWaterMark值越大，读取速度越快 highWaterMark设置过小，可能导致系统调用次数过多 第七章 网络编程 Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客服端。 TCP的服务事件：服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象 服务器事件 listening：在调用server.listen()绑定端口或者Domain Socket后触发，简介写法为server.listen(port, listeningListener)，通过listen()方法的第二个参数传入 connection：每个客户端套接字埒街道服务器端时触发，简洁写法为通过net.createServer()，最后一个参数传递 close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件 error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常 连接事件（socket） data：当一端用write()发送数据时，另一端会触发data事件，事件传递的数据即使write()发送的数据 end：当连接中的任意一端发送了FIN数据时，将会触发该事件 connect：该事件用于客户端，当套接字与服务端连接成功时会被触发 drain：当任意一端调用write()发送数据时，当前这端会触发该事件 error：当异常发生时，触发该事件 timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前连接已经被闲置了另外，由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器： 123456var net = require('net')var server = net.createServer(function (socket) &#123; socket.write('Echo server\\r\\n') socket.pipe(socket)&#125;) 值得注意的是，TCP针对网络中小的数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓存区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送 在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDealy(true)去掉Nagle算法，使得write()可以立即发送数据到网络中 另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件 构建UDP服务：UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即使基于它实现的。 UDP套接字事件 message：当UDP套接字侦听到网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息 listening：当UDP套接字开始侦听时触发该事件 close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可 error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出 构建HTTP服务：在Node中，HTTP服务继承自TCP服务器（net模块），http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接传来的数据，调用二级制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。 HTTP请求 req.method req.url req.httpVersion HTTP响应 设置报文头信息：res.setHeader，可以调用多次进行设置，但是只有调用writeHead后，报头才会写入到连接中，除此之外，http模块会自动帮你设置一些头信息 设置报文体信息：res.write()和res.end()，后者与前者的差别在于res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不再生效。这由协议的特效决定。另外，无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用res.end()结束请求，否则客户端将一直处于等待的状态。 HTTP服务的事件 connection：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。 request：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。 close：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。 checkContinue：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。 connect：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭。 upgrade：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接受到这样的请求时触发该事件。如果不监听该事件，发起请求的连接将会关闭。 clientError：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。 构建HTTP客户端：http.request(options, connect) options参数决定了这个HTTP请求头中的内容，它的选项有如下这些 host：服务器的域名或IP地址，默认为localhost hostname：服务器名称 port：服务器端口，默认为80 localAddress：建立网络连接的本地网卡 socketPath：Domain套接字路径 method：HTTP请求方法，默认为GET path：请求路径，默认为/ headers：请求头对象 auth：Basic认证，这个值将被计算成请求头中的Authorization部分报文体的内容由请求对象的write()和end()方法实现：通过write()方法向连接中写入数据，通过end()方法告知报文结束。它与浏览器中的Ajax调用几近相同，Ajax的实质就是一个异步的网络HTTP请求。 HTTP响应：HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。后续响应报文体以只读流的方式提供。 HTTP代理：为了重用TCP连接，http模块包含了一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务端发起的HTTP请求最多可以创建5个连接。它的实质是一个连接池。调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后猜真正发出。可在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5。 1234567891011var agent = new http.Agent(&#123; maxSockets: 10&#125;)var options = &#123; hostname: '127.0.0.1', port: 1334, path: '/', method: 'GET', agent: agent&#125; 也可以设置agent选项为false值，以多里连接池的管理，使得请求不受并发限制。 Agent对象的sockets和requests属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数，在业务中监视着两个值有助于发现业务状态的繁忙程度。 HTTP客户端事件 response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。 socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事情。 connect：当客户端向服务器端发送CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。 upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。 continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。 构建WebSocket服务 WebSocket服务与Node之间的配合堪称完美，其理由有两条： WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几 WebSocket实现了客户端与服务端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。 WebSocket与传统HTTP有如下好处： 客户端与服务器端只建立一个TCP连接，可以使用更少的连接 WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效 有更轻量级的协议头，减少数据传送量 在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet（彗星）技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或超时后重新发起请求。 WebSocket协议主要分为两个部分：握手和数据传输 WebSocket握手 客户端建立连接时，通过HTTP发起请求报文，如下所示： 123456GET /chat HTTP/1.1HOST: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Sec-WebSocket-Version: 13 与普通的HTTP请求协议略有区别的部分在于如下这些协议头： 12Upgrade: websocketConnection: Upgrade 上述两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验 Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端。这个算法如下所示： 12var crypto = require('crypto')var val = crypto.createHash('sha1').update(key).digest('base64') 另外，下面两个字段指定子协议和版本号： 12Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 服务器端处理完请求后，响应如下报文： 12345HTTP/1.1 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接字连接上应用新协议。剩余的字段分别表示服务器端基于Sec-WebSocket-Key生成的字符串和选中的子协议。客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输。 WebSocket数据传输 在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换 为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦受到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧无需做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。 网络服务与安全 在网景公司的NetScape浏览器推出之初就提出了SSL(Secure Sockets Layer，安全套阶层)。SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为TLS(Transport Layer Security，安全传输层协议) Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，SHA！、MD5等加密算法都在其中有体现。真正用于网络的是另外两个模块，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上。 TLS/SSL 密钥：TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密。 Node在底层采用的是openssl实现TLS/SSL 数字证书：为了确保数据安全，引入了一个第三方：CA(Certificate Authority，数字证书认证中心)。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。 为了得到签名证书，服务器端需要通过自己的私钥生成CSR(Certificate Signing Request，证书签名请求)文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。 通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书。 客户端在发起安全连接前会去获取服务器端的证书，并通过CA的证书验证服务器端的证书的真伪。除了验证真伪外，通常还含有对服务器名称、IP地址等进行验证的过程。 TLS服务：与普通的TCP服务器端和客户端相比，TLS的服务器端和客户端仅仅只在证书的配置上有差别，其余部分基本相同，在Node中，通过tls模块搭建TLS服务。 HTTPS服务：HTTPS服务就是工作在TLS/SSL上的HTTP 第八章 构建Web应用 基础功能 请求方法 12345678910111213141516function (req, res) &#123; switch (req.method) &#123; case 'POST': update(req, res) break case 'DELETE': remove(req, res) break case 'PUT': create(req, res) break case 'GET': default: get(req, res) &#125;&#125; 路径解析：客户端代理（浏览器）会将这个地址解析成报文，将路径和查询部分放在报文第一行。需要注意的是，hash部分会被丢弃，不会存在于报文的任何地方。 根据路径去查找磁盘中的文件，然后将其响应给客户端 123456789101112function (req, res) &#123; const pathname = url.parse(req.url).pathname fs.readFile(path.join(ROOT, pathname), function (err, file) &#123; if (err) &#123; res.writeHead(404) res.end('找不到相关文件。- -') return &#125; res.writeHead(200) res.end(file) &#125;)&#125; 根据路径来选择控制器 123456789101112131415// request url: /controller/action/a/b/cfunction (req, res) &#123; const pathname = url.parse(req.url).pathname const paths = pathname.split('/') const controller = paths[1] || 'index' const action = paths[2] || 'index' const args = path.slice(3) if (handles[controller] &amp;&amp; handles[controller][action]) &#123; handles[controller][action].apply(null, [req, res].concat(args)) &#125; else &#123; rew.writeHead(200) res.end('找不到响应控制器') &#125;&#125; 这样我们的业务部分可以只关心具体的业务实现，如下所示： 12345handles.index = &#123;&#125;handles.index.index = function (req, res, foo, bar) &#123; res.writeHead(200) res.end(foo)&#125; 查询字符串 查询字符串位于路径之后，在地址栏中路径后的?foo=bar&amp;baz=val字符串就是查询字符串。这个字符串会跟随在路径后，形成请求报文首行的第二部分。这部分内容经常需要为业务逻辑所用，Node提供了queryString模块用于处理这部分数据，如下所示： 1234const url = require('url')const querystring = require('querystring')const query = querystring.parse(url.parse(req.url).query)// const query = url.parse(req.url, true).query 要注意的点是，如果查询字符串中的键出现多次，那么它的值会是一个数组 Cookie Cookie的处理分为如下几步： 服务器向客户端发送Cookie 浏览器将Cookie保存 之后每次浏览器都会将Cookie发向服务器端 解析Cookie 1234567891011121314function parseCookie (cookie) &#123; let cookies = &#123;&#125; if (!cookie) &#123; return cookies &#125; let list = cookie.split(';') for (let i = 0; i &lt; list.length; i++) &#123; let pair = list[i].split('=') cookies[pair[0].trim()] = pair[1] &#125; return cookies&#125; 服务器通过Set-Cookie字段往客户端写入Cookie 1Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; 其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项： path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。 Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器是会丢失掉这个Cookie。Expires的值是一个UTC格式的时间字符串，是绝对时间，如果客户端和服务器端的时间不匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间。 HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HTTPOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。 Secure：当Secure为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。Cookie序列化成符合规范的字符串 12345678910111213function serialize (name, val, opt) &#123; var pairs = [name + '=' + encode(val)] opt = opt || &#123;&#125; if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge) if (opt.domain) pairs.push('Domain=' + opt.domain) if (opt.path) pairs.push('Path=' + opt.path) if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString()) if (opt.httpOnly) pairs.push('HttpOnly') if (opt.secure) pairs.push('Secure') return pairs.join('; ')&#125; Cookie的性能影响：由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成带宽的部分浪费。在YSlow的性能优化有规则中有这么一条： 减小Cookie的大小：更严重的情况是，如果在域名的根节点设置Cookie，几乎所有子路径下的请求都会带上这些Cookie，这些Cookie在某些情况下是有用的，但是在有些情况下是完全无用的。其中以静态文件最为典型，静态文件的业务定位几乎不关心状态，Cookie对它而言几乎是无用的，但是一旦有Cookie设置到相同域下，它的请求中就会带上Cookie。好在Cookie设计时限定了它的域，只有域名相同时才会发送。所以YSlow中有另外一条规则用来避免Cookie带来的性能影响。 为静态组件使用不同的域名：简而言之就是，为不需要Cookie的组件换个域名可以实现减少无效Cookie的传输。所以很多网站的静态文件会有特别的域名，使得业务相关的Cookie不再影响静态资源。当然换用额外的域名带来的好处不只这点，还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。但是换用额外域名还是有一定的确定的，那就是将域名转换为IP需要进行DNS查询，多一个域名就多一次DNS查询。YSlow中有这样一条规则： 减少DNS查询：看起来减少DNS查询和使用不同的域名是冲突的两条规则，但是好在现今的浏览器都会进行DNS缓存，以削弱这个副作用的影响 Session 如何将每个客户和服务器中的数据一一对应起来？ 第一种：基于Cookie来实现用户和数据的映射 虽然将所有数据都放在Cookie中不可取，但是将口令放在Cookie中还是可以的。因为口令一旦被篡改，就丢失了映射关系，也无法修改服务器端存在的数据了。并且Session的有效期通常较短，普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。那么口令是如何参数的呢？ 一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomact会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值时唯一且不重复的值，并设定超时时间 第二种：通过查询字符串来实现浏览器端和服务器端数据的对应 它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值得URL，然后形成跳转，让客户端重新发起请求， 有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须再响应时设置Cookie。但是这种方案带来的风险源大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑之后无法生效，相对较为安全。 还有一种比较有趣的处理Session的方式是利用HTTP请求头中的ETag，同样对于更换浏览器和电脑后也是无效的。 Session与内存 Session数据直接存于内存中会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频繁扫描，引起性能问题。 另一个问题则是我们可能为了利用多核CPU而启动了多个进程。用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。 为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解。 采用第三方缓存来存储Session引起的一个问题是会引起网络访问。理论上来说访问网络中的数据要比访问本地磁盘中的数据速度还要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，尽管如此但依然会采用这些高速缓存的理由有以下几条： Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化 高速缓存直接在内存中进行数据存储和访问 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度影响较小 Session与安全 从前文可以知道，尽管我们的数据都放置在后端了，使得它能保障安全，但是无论通过Cookie，还是查询字符串的实现方式，Session的口令依然保存在客户端，这里会存在口令被盗用的情况。如果Web应用的用户十分多，自行设计的随机算法的一些口令值就有理论机会命中有效的口令值。一旦口令被伪造，服务器端的数据也可能间接被利用。 有一种做法是将这个口令通过私钥加密进行签名，使得伪造的成本较高。客户端尽管可以伪造口令值，但是由于不知道私钥值，签名信息很难伪造。如此，我们只要在响应时将口令和签名进行对比，如果签名非法，我们将服务器端的数据立即过期即可。 这样一来，即使攻击者知道口令中.号前的值时服务器端Session的ID值，只要不知道secret私钥的值，就无法伪造签名信息，以此实现对Session的保护。 当然，将口令进行签名是一个很好的解决方案，但是如果攻击者通过某种方式获取了一个真实的口令和签名，他就能实现身份的伪装。一种方案是将客户端的某些独有信息和口令作为原值，然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包括用户IP和用户代理（User Agent）。 缓存 YSlow中提到了几条关于缓存的规则 添加Expires或Cache-Control到报文头中 配置ETags 让Ajax可缓存通常来说，POST、DELETE、PUT这类待行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中 Basic认证：Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段的值由认证方式和加密值构成。在Basic认证中，它会将用户和密码部分组合，然后进行Base64编码，如果用户首次访问该网页，URL地址中页没携带认证内容，那么浏览器会响应一个401未授权的状态码。响应头中的WWW-Authenticate字段告知浏览器采用什么样的认证和加密方式。当认证通过，服务器端响应200状态码之后，浏览器会保存用户名和密码口令，在后续的请求中都携带式Authorization信息。 Basic认证有太多的缺点，它虽然经过Base64加密后在网络中传送，但是这近乎于明文，十分危险，一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它。 为了改进Basic认证，RFC 2069规范提出了摘要访问认证，它加入了服务器端随机数来保护认证过程 数据上传 通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容 123function hasBody (req) &#123; return 'transfer-encoding' in req.headers || 'content-length' in req.headers&#125; 表单数据 12345&lt;form action=\"/upload\" method=\"post\"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; Content-Type: application/x-www-form-urlencode 报文体内容跟查询字符串相同：foo=bar&amp;baz=val 123456var handle = function (req, res) &#123; if (req.headers['content-type'] === 'application/x-www-form-urlencoded') &#123; req.body = querystring.parse(req.rawBody) &#125; todo(req, res)&#125; JSON Content-Type: application/json; charset=utf-8 1234567891011121314151617var mime = function (req) &#123; var str = req.headers['content-type'] || '' return str.split(';')[0]&#125;var handle = function (req, res) &#123; if (mime(req) === 'application/json') &#123; try &#123; req.body = JSON.parse(req.rawBody) &#125; catch (e) &#123; res.writeHead(400) res.end('Invaild JSON') return &#125; &#125; todo(req, res)&#125; XML Content-Type: application/xml; charset=utf-8 123456789101112131415var xml2js = require('xml2js')var handle = function (req, res) &#123; if (mime(req) === 'application/xml') &#123; xml2js.parseString(req.rawBody, function (err, xml) &#123; if (err) &#123; res.writeHead(400) res.end('Invaild XML') return &#125; req.body = xml todo(req, res) &#125;) &#125;&#125; 附件上传 12345&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;label for=\"file\"&gt;Filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 浏览器在遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的如下所示： 12Content-Type: multipart/form-data; boundary=AaB03xContent-Legnth: 18231 它代表本次提交的内容是由多部分构成的，其中的boundary=AaB03x指定的是每部分内容的分界符，AaB03x是随机生成的一段字符串，报文体的内容将通过在它前面添加–进行分科，报文结束时在它前后都加上–表示结束。另外，Content-Length的值必须确保是报文体的长度。 一旦我们知晓报文是如何构成的，那么解析它就变得十分容易。值得注意的一点是，由于是文件上传，那么像普通表单、JSON或XML那样先接受内容再解析的方式将变得不可接受。接收未知的数据量时，我们需要十分谨慎，如下所示： 1234567891011121314151617function (req, res) &#123; if (hasBody(req)) &#123; var done = function () &#123; handle(req, res) &#125; if (mime(req) === 'application/json') &#123; parseJSON(req, done) &#125; else if (mime(req) === 'application/xml') &#123; parseXML(req, done) &#125; else if (mime(req) === 'multipart/form-data') &#123; parseMultipart(req, done) &#125; &#125; else &#123; handle(req, res) &#125;&#125; 这里我们将req这个流对象直接交给对应的解析方法，由解析方法自行处理上传的内容，或接收内容并保存在内存中，或流式处理掉。 这里要介绍的模块是formidable。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示： 1234567891011121314151617var formidable = require('formidable')function parseMultipart (req, res) &#123; if (hasBody(req)) &#123; if (mime(req) === 'multipart/form-data') &#123; var form = new formidable.IncomingForm() form.parse(req, function (err, fields, files) &#123; req.body = fields req.files = files handle(req, res) &#125;) &#125; else &#123; handle(req, res) &#125; &#125;&#125; 数据上传与安全 内存限制 在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。攻击者通过客户端能够十分容易地模拟伪造大量数据，如果攻击者每次提交1MB的内容，那么只要并发请求数量一大，内存就会很快地被吃光。 要解决这个问题主要有两个方案： 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据流式处理在上文的文件上传中已经有所体现，这里介绍一下Connect中采用的上传数据量的限制方式，如下所示： 12345678910111213141516171819202122232425var bytes = 1024function (req, res) &#123; var received = 0 var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null // 如果内容超过长度限制，返回请求实体过长的状态码 if (len &amp;&amp; len &gt; bytes) &#123; res.writeHead(413) res.end() return &#125; // limit req.on('data', function (chunk) &#123; received += chunk.length if (received &gt; bytes) &#123; // 停止接收数据，触发end() req.destroy() &#125; &#125;) handle(req, res)&#125; CSRF CSRF的全称是Cross-Site Request Forgery，中文意思是跨站请求伪造，攻击者引诱某个domain_a的登录用户访domain_b的网站，在domain_b的网站中请求domain_a的资源会把domain_a的Cookie发送到服务器，尽管这个请求时来自domain_b的，但是服务器并不知情，用户也不知情。 路由解析 文件路径型 静态文件：URL的路径与网站目录的路径一致，无须转换。处理过程将请求路径对应的文件发送给客户端即可。 动态文件：Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并传入HTTP请求的上下文。解析器执行脚本，并输出响应报文，达到完成服务的目的。现今大多数的服务器都很智能地根据后缀同时服务动态和静态文件。这种方式在Node中不太常见，主要原因是文件的后缀都是.js，分不清是后端脚本，还是前端脚本，这可不是什么好的设计。而且Node中Web服务器与应用业务脚本是一体的，无须按这种方式实现。 MVC MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种： 控制器（Controller)，一组行为的集合 模型（Model），数据相关的操作和封装 视图（View)，视图的渲染这是目前最为经典的分层模式，大致而言，它的工作模式如下说明： 路由解析，根据URL寻找到对应的控制器和行为 行为调用相关的模型，进行数据操作 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端路由映射方法： 手工映射 优点：手工映射除了需要手工配置路由较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制 缺点：如果项目较大，路由映射的数量也会很多。从前端路径到具体的控制文件，需要查阅才能定位到实际代码的位置 自然映射： 优点：路由按照一种约定的方式自然而然地实现了路由，无须去维护路由映射 缺点：如果URL变动，它的文件也需要发生变动 RESTful REST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看做一个资源，并表现在URL上。 比如一个用户的地址如下所示： 1/users/jacksontian 这个地址代表了一个资源，对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上。过去我们队用户的增删改查或许是如下这样设计URL的： 1234POST /user/add?username=jacksontianGET /user/remove?username=jacksontianPOST /user/update?username=jacksontianGET /user/get?username=jacksontian 操作行为主要体现在行为上，主要使用的请求方法是POST和GET。在RESTful设计中，它是如下这样的： 1234POST /user/jacksontianDELETE /user/jacksontianPUT /user/jacksontianGET /user/jacksontian 它将DELETE和PUT请求方法引入设计中，参与资源的操作和更改资源的状态 在RESTful设计中，资源的具体格式由请求报头中Accept字段和服务器端的支持情况来决定。如果客户端同时接受JSON和XML格式的响应，那么它的Accept字段值是如下这样的： 1Accept: application/json,application/xml 在响应报文中，通过Content-Type告知客户端是什么格式 所以REST的设计就是，通过URL设计资源、请求方法定义资源的操作，通过Accept决定资源的表现形式 （中间件的具体实现请查看8.4）中间件：对于Web应用的各种基础功能，我们通过中间件来完成，每个中间件处理掉相对简单的逻辑，最终汇成强大的基础框架 异常处理 中间件与性能 编写高效的中间件 使用高效的方法。必要时通过jsperf.com测试基准性能。 缓存需要重复计算的结果（需要控制缓存用量） 避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要 合理使用路由 页面渲染 内容响应：内容响应的过程中，响应报头中的Content-*字段十分重要 MIME：浏览器正式通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值。MIME的全称是Multipurpose Internet Mail Extensions。不同的文件类型具有不同的MIME值，为了方便获知文件的MIME值，社区有专有的mime模块可以用来判断文件类型。 附件下载 Content-Disposition: attachment; filename=”filename.ext”；告知客户端将报文数据作为可下载的附件 Content-Disposition: inline；告知客户端将报文数据当做即使浏览的内容 响应JSON 12345res.json = function (json) &#123; res.setHeader('Content-Type', 'application/json') res.writeHead(200) res.end(JSON.stringify(json))&#125; 响应跳转 12345res.redirect = function (url) &#123; res.setHeader('Location', url) res.writeHead(302) res.end('Redirect to' + url)&#125; 视图渲染 BigPipe：将页面分割成多个部分，先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。这个过程中需要前端JS的参与，它负责将后续输出的数据渲染到页面上 第九章 玩转进程 Node存在的问题 如何充分利用多核CPU服务器：如今CPU基本均是多核的，真正的服务器（非VPS）往往还有多个CPU。而单进程单线程的结构只能利用一个核 如何保证进程的健壮性核稳定性：由于Node执行在单线程上，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃 多进程架构 Master-Worker模式：又称为主从模式，在这种模式中进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度和管理工作进程，它是趋向于稳定的。工作进程负责具体的业务助理。 创建子进程 spawn()：启动一个子进程来执行命令 exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它由一个回调函数获知子进程的状况 execFIle()：启动一个子进程来执行科执行文件 fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JS文件模块即可 spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程允许超过设定的时间将会被杀死。 |类型|回调/异常|进程类型|执行类型|可设置超时||spawn()|x|任意|命令|x||exec()|✔️|任意|命令|✔️||execFile()|✔️|任意|可执行文件|✔️||fork()|x|Node|JS文件|x| 这里的可执行文件是指可以直接执行的文件，如果是JS文件通过execFile()运行，它的首行内容必须添加如下代码： 1#!/usr/bin/env node 尽管4种创建子进程的方式有些差别，但事实上后面3种方法都是spawn()的延伸应用 进程间通信 通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息 12345678910111213141516// parent.jsvar cp = require('child_process')var n = cp.fork(__dirname + '/sub.js')n.on('message', function (m) &#123; console.log('Parent got message:', m)&#125;)n.send(&#123; hello: 'world' &#125;)// sub.jsprocess.on('message'， function (m) &#123; console.log('Child got message:', m)&#125;)process.send(&#123; foo: 'bar' &#125;) 进程间通信原理 IPC的全称是Inter-Process Communication，即进程间通信。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术。但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道（named pipe）实现，*nix系统则采用Unix Domain Socket实现。 父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程的连接。 建立连接之后的父子进程就可以自由地通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网络socket的行为比较类似，属于双向通信。在Node中，IPC通道被抽象为Stream对象，在调用send()发送数据（类似于write()）接收到的消息会通过message事件（类似于data）触发给应用层。 只有启动的子进程是Node进程时，子进程才会根据环境变量去连接IPC通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的IPC通道。 句柄传递 通过代理，主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上。这样，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。 为了解决上述这样的问题，Node引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄，如下所示： 1child.send(message, [sendHandle]) 那什么是句柄？句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。 发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。文件描述符浪费的问题可以通过这样的方式轻松解决。 123456789101112131415161718192021222324252627// parent.jsvar cp = require('child_process')var child1 = cp.fork('child.js')var child2 = cp.fork('child.j2')var server = require('net').createServer()server.listen(1337, function () &#123; child.send('server', server) child.send('server', server) // 关掉 server.close()&#125;)// child.jsvar http = require('http')var server = http.createServer(function (req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;) res.end('handled by child, pid is ' + process.id + '\\n')&#125;)process.on('message', function (m, tcp) &#123; if (m === 'server') &#123; tcp.on('connection', function (socket) &#123; server.emit('connection', socket) &#125;) &#125;&#125;) 句柄发送与还原 上文介绍的虽然是句柄发送，但是仔细看看，句柄发送跟我们直接将服务器对象发送给子进程有没有差别？它是否真的将服务器对象发送给了子进程？为什么它可以发送到多个子进程中？发送给子进程为什么父进程中还存在这个对象？ 目前子进程对象send()方法可以发送的句柄类型包括如下几种： net.Socket。TCP套接字。 net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。 net.Native。C++层面的TCP套接字或IPC管道。 dgram.Socket。UDP套接字。 dgram.Native。C++层面的UDP套接字。 send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示： 12345&#123; cmd: 'NODE_HANDLE', type: 'net.Server', msg: message&#125; 发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。 连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cm的值如果以NODE_为前缀，它将响应一个内部事件internalMessage。如果message.cmd的值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。 端口共同监听 在了解了句柄传递背后的原理后，我们继续探究为何通过发送句柄后，多个进程可以监听到相同的端口而不引起EADDRINUSE异常。其答案也很简单，我们独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。 Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用 由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时会失败。但对于send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同的端口不会引起异常。 多个应用监听相同的端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的。 集群稳定之路 问题 性能问题 多个工作进程的存活状态管理 工作进程的平滑重启 配置或者静态数据的动态重新载入 其他细节 进程事件 error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。 exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法杀死的，会得到第二个参数，它表示杀死进程时的信号。 close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。 disconnect：在父进程或子进程中调用disconnect()方法式触发该事件，在调用该方法时将关闭监听IPC通道。 自动重启： 一旦有未捕获的异常出现，工作进程就会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的exit后，将会立即启动新的进程服务，以此保证整个集群中总是有进程在为用户服务的。 自杀信号 上述过程存在的问题是要等到已有的连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，全处在等待退出的状态。但在等到进程完全退出在重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，这回丢掉大部分请求。 为此需要改进这个过程，不能等到工作进程退出后才重启新的工作进程。当然也不能暴力退出进程，因为这样会导致已连接的用户之间断开。于是我们在退出的流程中增加一个自杀（suicide）信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。 这里存在问题的是有可能我们的连接是长连接，不是HTTP服务的这种短连接，等待长连接断开可能需要较久的时间。为此为已有的连接的断开设置一个超时时间是必要的。 进程中如果出现未能捕获的异常，就意味着有那么一段代码在健壮性上是不合格的。为此退出进程前，通过日志记录下问题所在是必须要做的事情，它可以帮我们很好地定位和追踪代码异常出现的位置。 限量重启 通过自杀信号告知主进程可以使得新连接总是有进程服务，但是依然还是有极端的情况。工作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误，会导致工作进程被频繁重启，这种频繁重启不属于我们捕捉未知异常的情况，因为这种短时间内频繁重启已经不符合预期的设置，极有可能是程序编写的错误。 为了消除这种无意义的重启，在满足一定规则的限制下，不应当反复重启。比如在单位时间内规定只能重启多少次，超过限制就触发giveup事件，告知放弃重启工作进程这个重要事件。 负载均衡 Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。 一般而言，这种抢占式策略对大家是公平的，各个进程可以根据自己的繁忙度来进行抢占。但是对于Node而言，需要分清的是它的繁忙是有CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多的请求，形成负载不均衡的情况。 为此Node在V0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其以此分发给工作的进程。分发的策略是在N个工作进程中，每次选择第i=(i + 1) mod n个进程来发送连接。 状态共享 解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如Redis)中，所有工作进程启动时将其读取进内存中。但这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。 实现状态同步的机制有两种： 各个子进程去向第三方进行定时轮询 创建一个通知进程，这个进程设计为值进行轮询和通知，不处理任何业务逻辑。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。 Cluster模块 12345678910var cluster = require('cluster')cluster.setupMaster(&#123; exec: 'workter.js'&#125;)var cpus = require('os').cpus()for (var i = 0; i &lt; cpus.length; i++) &#123; cluster.fork()&#125; 执行上述代码将会得到与前文创建子进程集群的效果相同。就官方的文档而言，它更喜欢如下的形式作为示例： 1234567891011121314151617181920var cluster = require('cluster')var http = require('http')var numCPUs = require('os').cpus().lengthif (cluster.isMaster) &#123; // Fork workers for (var i = 0; i &lt; numCPUs; i++) &#123; cluster.fork() &#125; cluster.on('exit', function (worker, code, signal) &#123; console.log('worker' + worker.process.pid + ' died') &#125;)&#125; else &#123; // Workers can share any TCP connection http.createServer(function (req, res) &#123; res.writeHead(200) res.end('hello world\\n') &#125;).listen(8000)&#125; 在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID，如下所示： 12cluster.isWorker = ('NODE_UNIQUE_ID' in process.env)cluster.isMaster - (cluster.isWorker === false) Cluster工作原理 事实上cluster模块就是child_process和net模块的组合应用。cluster启动时，它会在内部启动TCP服务器，在cluster.fork()子进程时，将这个TCP服务器端socket的文件描述符发送给工作进程。如果进程是通过cluster.fork()复制出来的，那么它的环境变量就存在NODE_UNIQUE_ID，如果进程中存在listen()侦听网络端口的调用，它们将拿到该文件描述符，通过SO_REUSEADDR端口重用，从而实现多个子进程共享端口。对于普通方式启动的进程，则不存在文件描述符传递共享等事情。 在cluster内部隐式创建TCP服务器的方式对使用者来说十分透明，但也正是这种方式使得它无法入直接使用child_process那样灵活。在cluster模块应用中，一个主进程只能管理一组工作进程。 对于自行通过child_process来操作时，则可以更灵活地控制工作进程，甚至控制多组工作进程。其原因在于自行通过child_process操作子进程时，可以隐式地创建多个TCP服务器，使得子进程可以共享多个的服务器端socket。 Cluster事件 fork：复制一个工作进程后触发该事件。 online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。 listening：工作进程中调用listen()（共享了服务端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件 exit：有工作进程退出时触发该事件。 setup：cluster.setupMaster()执行后触发该事件 第十章 测试 单元测试 编写可测试代码有以下几个原则可以遵循 单一职责 接口抽象 层次分离 单元测试介绍 断言 在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标识程序开发者预期的结果——当程序运行到断言的位置时，对应的断言应该为真。若断言不为真，程序会中止运行，并出现错误信息。 assert模块 ok()：判断结果是否为真。 equal()：判断实际值与期望值是否相等。 notEqual()：判断实际值与期望值是否不相等。 deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。 notDeepEqual()：判断实际值与期望值是否不深度相等。 strictEqual()：判断实际值与期望值是否严格相等（相当于===）。 notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==)。 throws()：判断代码块是否抛出异常。 doesNotThrow()：判断代码块是否没有抛出异常。 ifError()：判断实际值是否为一个假值（null、undefined、0、’’、false），如果实际值为真值，将会抛出异常。 测试框架：mocha 测试风格：我们将测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，他们的差别如下： 关注点不同：TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。 表达方式不同：TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯。 123456789101112131415161718192021222324252627// BDDdescribe('Array', function () &#123; // 提供了before、after、beforeEach、afterEach钩子方法 before (function () &#123; // ... &#125;) describe('#indexOf()', function () &#123; it('should return -1 when not present', function () &#123; [1, 2, 3].indexOf(4).should.equal(-1) &#125;) &#125;)&#125;)// TDDsuite('Array', function () &#123; // 提供了setup、teardown钩子方法 setup (function () &#123; // ... &#125;) suite('#indexOf()', function () &#123; test('should return -1 when not present', function () &#123; assert.equal(-1, [1, 2, 3].indexOf(4)) &#125;) &#125;)&#125;) 测试报告 测试代码的文件组织：测试代码存在于test目录中 测试用例 一个测试用例中包含至少一个断言。示例代码如下： 1234567891011describe('#indexOf()', function () &#123; it('should return -1 when not present', function () &#123; [1, 2, 3].indexOf(4).should.equal(-1) &#125;) it('should return index when present', function () &#123; [1, 2, 3].indexOf(1).should.equal(0) [1, 2, 3].indexOf(2).should.equal(1) [1, 2, 3].indexOf(3).should.equal(2) &#125;)&#125;) 测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注。 异步测试 由于Node环境的特殊性，异步调用非常常见，这也带来了异步代码在测试方面的跳转。在其他典型编程语言中，如Java、Ruby、Python，代码大多是同步执行的，所以测试用例基本上只要包含一些断言检查返回值即可。但是在Node中，检查方法的返回值毫无意义，并且不知道回调函数具体何时调用结束，这将导致我们在对异步调用进行测试时，无法调度后续测试用例的执行。 所幸，mocha解决了这个问题。一下为fs模块中readFile的测试用例 123456it('fs.readFile should be ok', function (done) &#123; fs.readFile('file_path', 'utf-8', function (err, data) &#123; should.not.exist(err) done() &#125;)&#125;) 在上述代码中，测试用例方法it()接受两个参数；用例标题和回调函数。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行。 超时设置 mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例。 mocha的默认超时时间为2000毫秒。一般情况下，通过Mocha -t &lt;ms&gt;设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置，示例代码如下： 1234it('should take less than 500ms', function (done) &#123; this.timeout(500) setTimeout(done, 300)&#125;) 也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例： 12345678910describe('a suit of tests', function () &#123; this.timeout(500) it('should take less than 500ms', function (done) &#123; setTimeout(done, 300) &#125;) it('should take less than 500ms as well', function (done) &#123; setTimeout(done, 200) &#125;)&#125;) 测试覆盖率 通过统计每一行代码是否执行来得知测试用例对源码的覆盖率 blanket模块 123456789// 只需在所有测试用例之前通过--require选项引入它即可mocha --require blanket -R html-cov &gt; coverage.html// 在包描述文件(package.json)文件中配置scripts节点，pattern属性用以匹配需要编译的文件\"scripts\": &#123; \"blanket\": &#123; \"pattern\": \"eventproxy/lib\" &#125;&#125; mock 前面提到开发者常常会遗漏掉一些异常案例，其中想当一部分原因在于异常的情况较难实现。大多异常与输入数据并无绝对的关系，比如数据库的异步调用，除了输入异常外，还有可能是网络异常、权限异常等非输入数据相关的情况，这相对难以模拟。 以下面代码为例，文件系统的异常时绝对不容易呈现的，为了测试代码的健壮性而专程调节磁盘上的权限等，成本略高： 1234567exports.getContent = function (filename) &#123; try &#123; return fs.readFileSync(filename, 'utf-8') &#125; catch (e) &#123; return '' &#125;&#125; 为了解决这个问题，我们通过伪造fs.readFileSync()方法抛出错误来触发异常。同时为了保证该测试用例不影响其余用例，我们需要在执行完后还原它。为此，前面提到的before()和after()钩子函数派上了用场，相关代码如下： 12345678910111213141516describe('getContent', function () &#123; var _readFileSync before(function () &#123; _readFileSync = fs.readFileSync fs.readFileSync = function (filename, encoding) &#123; throw new Error('mock readFileSync error') &#125; &#125;) // it() after(function () &#123; fs.readFileSync = _readFileSync &#125;)&#125;) 我们在执行测试用例前将引用替换掉，执行结束后还原它。如果每个测试用例执行前后都要进行设置和还原，就使用beforeEach()和afterEach()这两个钩子函数。 由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk，示例代码如下： 1234567891011121314var fs = require('fs')var muk = require('muk')before(function () &#123; muk(fs. 'readFileSync', function (path, encoding) &#123; throw new Error('mock readFileSync error') &#125;)&#125;)// it()after(function () &#123; muk.restore()&#125;) 值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步 1234567891011// errorfs.readFile = function (filename, encoding, callback) &#123; callback(new Error('mock readFile error'))&#125;// goodfs.readFile = function (filename, encoding, callback) &#123; process.nextTick(function () &#123; callback(new Error('mock readFile error')) &#125;)&#125; 私有方法的测试 对于Node而言，又一个难点会出现在单元测试的过程中，那就是私有方法的测试，这在第2章中介绍过。只有挂载在exports或module.exports上的变量或方法才可以被外部通过require引入访问，其余方法只能在模块内部被调用和访问。 rewrite模块提供了一种巧妙的方式实现对私有方法的访问 1234567891011// 源代码var limit = function (num) &#123; return num &lt; 0 ? 0 : num&#125;// 测试用例it('limit should return success', function () &#123; var lib = rewrite('../lib/index.js') var limit = lib.__get__('limit') litmit(10).should.be.equal(10)&#125;) rewrite的诀窍在于它引入文件时，像require一样对原始文件做了一定的手脚。除了添加(function(exports, require, module, filename, dirname){)和});的头尾包装外，它还注入了部分代码，具体如下所示： 12345678910(function (exports, require, module, __filename, __dirname) &#123; var method = function () &#123;&#125; exports.__set__ = function (name, value) &#123; eval(name ' = ' value.toString()) &#125; exports.__get__ = function (name) &#123; return eval(name) &#125;&#125;) 每一个被rewrite引入的模块都有set()和get()方法。它巧妙利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行。 工程化和自动化 性能测试 基准测试 基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距。 这里介绍benchmark这个模块是如何组织基准测试的，相关代码如下： 12345678910111213141516171819var Benchmark = require('benchmark')var suite = new Benchmark.Suite()var arr = [0, 1, 2, 3, 5, 6]suite.add('nativeMap', function () &#123; return arr.map(callback)&#125;).add('customMap', function () &#123; var ret = [] for (var i = 0; i &lt; arr.length; i++) &#123; ret.push(callback(arr[i])) &#125; return ret&#125;).on('cycle', function (event) &#123; console.log(String(evnet.target))&#125;).on('complete', function () &#123; console.log('Fastest is ' + this.fileter('fastest').pluck('name'))&#125;).run() 它通过suite来组织每组测试，在测试套件中调用add()来添加被测试的代码 执行上述代码，得到的输出结果如下 123nativeMap x 1,227,341 ops/sec ±1.99%(83 runs sampled)customMap x 7,919,649 ops/sec ±0.57%(96 runs sampled)Fastest is customMap 负载测试 压力测试 除了可以对基本的方法进行基准测试外，通常还会对网络接口进行压力测试以判断网络接口的性能，这在第六章演示过。对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力。 最常用的工具是ab、siege、http_load等 基准测试驱动开发 测试数据与业务数据的转换 假设某个页面每天的访问量为100万。根据实际业务情况，主要访问量大致集中在10个小时以内，那么换算公式就是： 1QPS = PV / 10h 100万的业务访问量换算为QPS，约等于27.7，即服务器需要每秒处理27.7个请求才能胜任业务量 第十一章 产品化 项目工程化 目录结构 构建工具 代码审查 部署流程 部署环境 部署操作 性能 动静分离：将动态请求和静态请求分离，使服务器专注在动态服务方面，专业的CDN会将静态文件与用户尽可能靠近，同时能够有更精确和高效的缓存机制。 启用缓存：提升性能其实差不多只有两个途径，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不要的计算，应用场景做多的就是缓存。 多进程架构：通过多进程架构，不仅可以充分利用多核CPU，更是可以建立机制让Node进程更加健壮，，以保障Web应用持续服务。 读写分离：除了动静分离外，另一个较为重要的分离是读写分离，这主要针对数据库而言。就任意数据库而言，读取的速度远远高于写入的速度。而某些数据库在写入时为了保证数据的一致性，会进行锁表操作，这同时会影响到读取的速度。某些系统为了提升性能，通常会进行数据库的读写分离，将数据库进行主从设计，这样读数据操作不再受到写入的影响。 日志 访问日志：一般用来记录每个客户端对应用的访问 异常日志：通常用来记录那些意外产生的异常错误 异常日志通常有完善的分级，Node中提供console对象就简单地实现了这几种划分，具体如下所示： console.log：普通日志 console.info：普通信息 console.warn：警告信息 console.error：错误信息console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。下面为它们的实现代码： 1234567891011Console.prototype.log = function () &#123; this._stdout.write(util.format.apply(this, arguments) + '\\n')&#125;Console.prototype.info = Console.prototype.logConsole.prototype.warn = function () &#123; this._stderr.write(util.format.apply(this, arguments) + '\\n')&#125;Console.prototype.error = Console.prototype.warn console对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象，相关代码如下： 1234var info = fs.createWriteStream(logdir + '/info.log', &#123;flags: 'a', mode: '0666'&#125;)var error = fs.createWriteStream(logdir + '/error.log', &#123;flags: 'a', mode: '0666'&#125;)var logger = new console.Console(info, error) 分别调用它的API，日志内容就能各自写入到对应的文件中，相关代码如下： 12logger.log('Hello world!')logger.error('segment fault') 有了记录信息的日志API后，开发者需要关心的是要小心捕获每一个异常，在第四章中，我们提到异步调用中回调函数里的异常无法被外部捕获的问题，也提到了异步API编写的规范，每个开发者应当将API内部发生的异常作为第一个实参传递给回调函数。对于回调函数产生的异常，则可以不用过问，交给全局的uncaughtException事件去捕获即可。 在逐层次的异步API调用中，异常是该传递给调用方还是立即通过日志记录，这是一个需要注意的问题。就通常的API编写而言，尽量不要隐藏错误，不要通过try/catch块将异常捕获，然后隐藏起来不向外部调用者暴露。这对于底层API的设计而言，尤为重要。事实上，日志通常是服务于业务的。建议异常尽量由上层的调用者捕获记录，底层调用或中间层调用中出现的异常只要正常传递给上层的调用方即可。 日志与数据库 有的开发者对日志可能不太了解，会选择将一些日志写入到数据库中。数据库比日志文件好的地方在于它是结构化数据，可以直接编写SQL语句进行分析，日志文件则需要再加工之后才能分析。但是日志文件与数据库写入在性能上处于两个级别，数据库在写入过程中要经历一系列处理，比如锁表、日志等操作。写日志文件则是直接将数据写到磁盘上。为此，如果有大量的访问，可能会存在写入操作大量排队的状况，数据库的消费速度严重低于生产速度，进而导致内存泄漏等。相比之下，写日志是轻量的方法，将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来。 分割日志：将产生的日志按日期分割 监控报警 应用的监控主要有两类，一种是业务逻辑型的监控，一种是硬件型的监控。监控主要通过定时采样来进行记录。除此之外，还要对监控的信息设置上限，一旦出现大的波动，就需要发出警报提醒开发者。为了较好地供开发者使用，监控到的信息一般还要通过数据可视化的方式反映出来，以便更直观地查看。 监控 日志监控：通过监控异常日志文件的变动，将新增的异常按异常类型和数量反映出来；对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布。此外，从访问日志中也能实现PV和UV的监控。同QPS值一样，通过对PV/UV的监控，可以很好地知道应用的使用者们的习惯、预知访问高峰等。 响应时间：响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长。响应时间可以在Nginx一类的反向代理上监控，也可以通过应用自行产生的访问日志来监控。 进程监控：监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。 磁盘监控：磁盘监控主要是监控磁盘的用量。由于日志频繁写的缘故，磁盘空间渐渐被用光。一旦磁盘不够用，将会引发系统的各种问题。给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了。 内存监控：监控服务器的内存使用状况，可以检查应用中是否存在内存泄漏的状况。如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落。 CPU占用监控：CPU的使用分为用户态、内核态、IOWait等。如果用户态CPU使用率较高，说明服务器上的应用需要大量的CPU开销；如果内核态CPU使用率较高，说明服务器花费大量时间进行进程调度或者系统调用；IOWait使用率则反应的是CPU等待磁盘I/O操作。 CPU load监控：CPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载。CPU load过高说明进程数量过多，这在Node中可能体现在用子进程模块反复启动新的进程。 I/O负载：I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库。 网络监控：虽然网络流量监控的优先级没有上诉项目那么高，但还是需要对流量进行监控并设置上限值。即便应用突然受到用户的青睐，流量暴涨时也能通过数值感知到网站的宣传是否有效。一旦流量超过警戒值，开发者就应当找出流量增长的原因。对于正常增长，应当评估是否该增加硬件设备来为更多用户提供服务。网路流量监控的两个主要指标是流入流量和流出流量。 应用状态监控：除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续地调用应用的反馈接口来检查它的健康状态。最简单的状态反馈就是给监控响应一个时间戳，监控方检查时间戳是否正常即可。健壮一些的状态响应则是将应用的依赖项的状态打印出来，如数据库连接是否正常、缓存是否正常等。 DNS监控：DNS是网络应用的基础，在实际的对外服务的产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控。目前国内有一些免费的DNS监控服务，如DNSPod等，可以通过这些监控服务，监控自己的在线应用。 报警 邮件报警：可以调用nodemailer模块来实现邮件的发送 短信或电话报警： 稳定性 多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性问题。 多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟问题。在容灾方面，机房与机房之间可以互相备份。由于机房与机房之间的网络复杂度再度提升，负载均衡方面需要进一步去统筹规划。 容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务。 异构共存","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"NodeJs","slug":"编程语言/NodeJs","permalink":"http://yoursite.com/categories/编程语言/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://yoursite.com/tags/NodeJs/"},{"name":"深入浅出NodeJs","slug":"深入浅出NodeJs","permalink":"http://yoursite.com/tags/深入浅出NodeJs/"}]},{"title":"TypeScript 语法","slug":"typescript","date":"2019-02-12T02:27:23.000Z","updated":"2019-03-08T09:43:05.935Z","comments":true,"path":"2019/02/12/typescript.html","link":"","permalink":"http://yoursite.com/2019/02/12/typescript.html","excerpt":"","text":"简介TypeScript是什么背景TypeScript是微软开发的一款开源的编程语言，本质上是向JavaScript增加静态类型系统。它是JavaScript的超集，所有现有的JavaScript都可以不加改变就在其中使用。它是为大型软件开发而设计的，最终编译产生JavaScript，所以可以运行在浏览器、Node.js等等的运行时环境。 什么是类型系统下面是摘自《Types And Programming Languages》中的定义： A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute. 第一个重点是Proving the absence of certain program behaviors，所以我们亦可将类型检查器看做一个程序推理工具，可以静态的证明程序成立。 另一个重点是Classifying phrases according to the kinds of values they compute，对词语（比如变量）的值得性质进行分类，比如说TypeScript中的Interface、Class等。 静态类型系统是什么增加静态这个定语，是为了和运行时的类型检查机制加以区分，强调静态类型系统是在编译时进行类型分析。 TypeScript和JavaScript的关系和一些基于JavaScript的激进语言不同（比如CoffeScript），TypeScript的语法设计首先考虑的就是兼容JavaScript，或者说对JavaScript的语法做扩展。基本上是在JavaScript的基础上增加了一些类型标记语法，以实现静态类型分析。把这些类型标注语法去掉之后，仍是一个标准的JavaScript语言。 为什么要使用TypeScript 提高代码质量，降低bug率，隐式类型转换带来大量不可预知的类型错误 静态类型检测，减少编译阶段引起的错误 模块化，es6已支持 让代码更加清晰易读 语法糖()=&gt;，接口，枚举，泛型，方法重载 TypeScript 语法介绍基础类型 布尔值（Boolean） 1let isDone: boolean = false 数字（Number） 1234let decLiteral: number = 6let hexLiteral: number = 0xf00dlet binaryLiteral: number = 0b1010let octalLiteral: number = 0o744 字符串（String） 1let name: string = 'bob' 数组（Array） 12345// 在元素类型后面接上 []，表示由此类型元素组成的一个数组let list: number[] = [1, 2, 3]// 数组泛型，Array&lt;元素类型&gt;let list: Array&lt;number&gt; = [1, 2, 3] 元组（Tuple）：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同 123let x: [string, number]x = ['hello', 10] // OKx = [10, 'hello'] // Error 枚举（Enum） 123enum Color &#123; Red = 2, Green, Blue &#125;let c: Color = Color.Green // 3let colorName: string = Color[2] // 'Red' Any：允许你在编译时可选择地包含或移除类型检查，与Object的区别在于，Object类型的变量只是允许你给它赋任意值，但是却不能够在它上面调用任意的方法 123456let notSure: any = 4notSure.ifItExits() // OKnotSure.toFixed() // OKlet prettySure: Object = 4prettySure.toFixed() // Error Void：声明一个void类型的变量，只能赋值为undefined和null Null和Undefined：默认情况下null和undefined是所有类型的子类型。就是说你可以把null和undefined赋值给number类型的变量。然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自 Never：表示的是那些永不存在的值的类型。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 Object：表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型 1234let o: object = &#123; prop: 0 &#125; // OKlet o1: object = 4 // Error// 注意，object与Object的区别let o1: Object = 4 // OK 类型断言：好比其它语言里的类型转换 12345678// “尖括号”语法let someValue: any = 'this is a string'let strLength: number = (&lt;string&gt;someValue).length// as语法// 当在TypeScript中使用JSX时，只有as语法断言是被允许的let someValue: any = 'this is a string'let strLength: number = (someValue as string).length 变量声明 var、let、const 解构 接口TypeScript的核心原则之一就是对值所具有的结构进行类型检查在。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。相对于其它语言的接口而言，在ts中只会关注值得外形，而不能说某个对象实现了这个接口。 123456789101112interface SquareConfig &#123; width: number height: number // 可选属性的好处：1. 可以对可能存在的属性进行预定义；2. 可以捕获引用了不存在的属性时的错误（例如：color属性拼写错误成clor） color?: string // 只读属性 readonly borderColor: string // 只读数组，把ReadonlyArray类型的变量赋值给普通数组是不被允许的，但是可以用类型断言重写 arr: ReadonlyArray&lt;number&gt; // 字符串索引签名：避免额外的属性检查 [propName: string]: any&#125; 函数类型接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。 123456789interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearchFunc: SearchFuncmySearchFunc = function (src, sub): boolean &#123; let result = src.search(sub) return result &gt; -1&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型。TypeScript支持两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值的子类型。这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 123456789101112class Animal &#123; name: string&#125;class Dog extends Animal &#123; breed: string&#125;// 错误：使用数值型的字符串索引，有时得到的会是Dog类型的数据interface NotOkay &#123; [x: number]: Animal [x: string]: Dog&#125; 类类型与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 123456789101112interface ClockInterface &#123; currentTime: Date setTime(d: Date)&#125;class Clock implements ClockInterface &#123; currentTime: Date setTime(d: Date) &#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123;&#125;&#125; 继承接口和类一样，接口也可以相互继承。 1234567891011121314interface Shape &#123; color: string&#125;interface PenStroke &#123; penWidth: number&#125;interface Square extends Shape, PenStroke &#123; sideLength: number&#125;let square = &lt;Square&gt;&#123;&#125;square.color = 'blue'square.penWidth = 5.0square.sideLength = 10 混合类型因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性 1234567891011121314151617interface Counter &#123; (start: number): string interval: number reset(): void&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123;&#125; counter.interval = 123 counter.reset = function () &#123;&#125; return counter&#125;let c = getCounter()c(10)c.reset()c.interval = 5.0 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其之类所实现。 1234567891011121314151617class Control &#123; private state: any&#125;interface SelectableControl extends Control &#123; select(): void&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;// 错误： “Image”类型缺少“state”属性class Image implements SelectableControl &#123; select() &#123;&#125;&#125; 类继承 子类的构造函数里必须调用super()，且要在访问this的属性之前 子类可以重写基类的函数 1234567891011121314151617181920212223242526272829class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\") super.move(distanceInMeters) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\") super.move(distanceInMeters) &#125;&#125;let sam = new Snake(\"Sammy the Python\")let tom: Animal = new Horse(\"Tommy the Palomino\")sam.move()tom.move(34) 公有，私有与受保护的修饰符 public(默认) private TypeScript使用的是结构性类型系统。当我们比较两种不同的类型时，并不在乎它们从何而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 12345678910111213141516171819class Animal &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;class Rhino extends Animal &#123; constructor(theName: string) &#123; super('Rhino') &#125;&#125;class Employee &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;let animal = new Animal('Goat')let rhino = new Rhino()let employee = new Employee('bob')animal = rhino// 错误：Animal 与 Employee不兼容，私有成员name的定义不是来自同一处animal = employee protected：protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。构造函数也可以被标记成protected，这意味着这个类不能再包含它的类外被实例化，但是能被继承。 1234567891011121314151617181920212223class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的.export default &#123;&#125; readonly修饰符使用readonly关键字可以将属性设置为只读的 12345678910class Octopus &#123; readonly name: string readonly numberOfLegs: number = 8 constructor (theName: string) &#123; this.name = theName &#125;&#125;let dad = new Octopus('Man with the 8 strong legs')dad.name = 'Man with the 3-piece suit' // 错误！name是只读的 参数属性可以使用如下代码替代上述方法： 12345class Octopus &#123; readonly numberOfLegs: number = 8 constructor (readonly name: string) &#123; &#125;&#125; 注意看我们是如何舍弃了theName，仅在构造函数里使用readonly name: string参数来创建和初始化name成员。我们把声明和赋值合并至一处。 参数属性通过给构造函数前面添加一个访问限定符来声明。使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也一样 存取器对于存取器有下面几点需要注意的： 编译器设置为输出ECMAScript 5或更高 只带有get不带有set的存取器自动被推断为readonly 1234567891011121314151617181920212223let passcode = 'secret passcode'class Employee &#123; private _fullName: string get fullName(): string &#123; return this._fullName &#125; set fullName(newName: string): &#123; if (passcode &amp;&amp; passcode === 'secret passcode') &#123; this._fullName = newName &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee()employee.fullName = 'Bob Smith'if (employee.fullName) &#123; alert(employee.fullName)&#125; 静态属性12345class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;&#125;console.log(Grid.origin.x) 抽象类 abstract关键字用于定义抽象类和在抽象类内部定义抽象方法 抽象类作为其它派生类的基类使用，一般不会被实例化 不同于接口，抽象类可以包含成员的实现细节 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 把类当接口使用类的定义会创建两个东西：类的实例类型和一个构造函数。因为类可以创建出类型，所以你能够在允许使用接口的地方使用类 123456789class Point &#123; x: number y: number&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125; 函数为函数定义类型函数的类型由参数类型和返回值类型决定 1234567function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function (x: number, y: number): number &#123; return x + y&#125; 书写完整函数类型123let myAdd: (baseValue: number, increment: number) =&gt; number = function (x: number, y: number): number &#123; return x + y&#125; 可选参数和默认参数 传递给一个函数的参数个数必须与函数期望的参数个数一致 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, too few parameterslet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right 在参数名旁边使用?实现可选参数的功能，可选参数必须跟在必须参数后面 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName;&#125;let result1 = buildName(\"Bob\"); // works correctly nowlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right 带默认值得参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值 12345678function buildName(firstName = \"Will\", lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, too few parameterslet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\"let result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\" 可选参数和末尾的默认参数共享参数类型 123function buildName(firstName: string, lastName?: string) &#123; //. ..&#125; 和 123function buildName(firstName: string, lastName = 'Smith') &#123; //. ..&#125; 共享同样的类型(firstName: string, lastName?: string) =&gt; string 剩余参数通过…操作符来获取剩余参数 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + ' ' + restOfName.join(' ')&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName 重载定义重载时，一定要把最精确的定义放在最前面 123456789101112131415161718192021222324let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 注意，function pickCard(x): any并不是重载列表的一部分，是函数的具体实现。 泛型含义：类型的参数化，就是可以把类型像方法的参数那样传递 1234567// 参数类型与返回值类型相同function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let output = identity&lt;string&gt;('myString')let output = identity('myString') 使用泛型变量使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当做是任意或所有类型 12345function loggingIdentity&lt;T&gt;(arg: T): T &#123; // Error: T doesn't have .length console.log(arg.length) return arg&#125; 泛型类型泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数放在最前面，像函数声明一样： 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity 还可以使用带有调用签名的对象字面量来定义泛型函数 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity1: &#123; &lt;U&gt;(arg: U): U &#125; = identity 这引导我们去写一个泛型接口了 123456789interface GenericIdentityFn &#123; &lt;U&gt;(arg: U): U&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn = identity 或者我们可以把泛型参数当做整个接口的一个参数 123456789interface GenericIdentityFn&lt;U&gt; &#123; (arg: U): U&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity 泛型类泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;()myGenericNumber.zeroValue = 0myGenericNumber.add = function(x, y) &#123; return x + y &#125; 泛型约束如果我们想要限制函数去处理任意带有.length属性的所有类型。只要传入的类型中有这个属性，我们就允许。为此，我们需要累出对于T的约束要求。 为此，我们定义一个接口来描述约束条件。创建一个包含.length属性的接口，使用这个接口和extends关键字来实现约束： 123456789interface Lengthwise &#123; length: number&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; // Now we konw it has .length property, so no more error console.log(arg.length) return arg&#125; 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。 123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\"); // okaygetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.// export default &#123;&#125; 在泛型里使用类类型在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如： 123function create&lt;T&gt;(c: &#123; new(): T &#125;): T &#123; return new c()&#125; 枚举使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。TypeScript支持数字的和基于字符串的枚举。 数字枚举 默认从0开始，往后依次加1 如果给其中一个枚举成员赋值n，这后续的枚举成员从n开始依次加1 123456789101112131415enum Direction &#123; top, bottom = 4, left, right = 10, topLeft, topRight, bottomLeft, bottomRight&#125;console.log(Direction.top) // 0console.log(Direction.left) // 5console.log(Direction.topLeft) // 11console.log(Direction[4]) // 'bottom' 数字枚举可以被混入到计算过的和常量成员（如下所示），简单地说，不带初始化器的枚举，要么被放在第一的位置，要么被放在使用了数字常量或者其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的： 1234enum E &#123; A = getSomeValue(), B, // error! 'A' is not constant-initialized, so 'B' needs an initializer&#125; 字符串枚举在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化 123456enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT'&#125; 异构枚举从技术的角度来说，枚举可以混合字符串和数字成员，除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做 1234enum BooleanLikeHetergeneousEnum &#123; No = 0, Yes = 'YES'&#125; 计算的和常量成员每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量： 它是枚举的第一个成员且没有初始化器，这种情况下它被赋值于0 它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加1 枚举成员使用常量枚举表达式初始化。常量枚举表达式是TypeScript表达式的子集，他可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量和数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符+，-，~其中之一运用在了常量枚举表达式 常量枚举表达式做为二元运算符 +，-，*，/，%，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，|，^的操作对象。若常数枚举表达式求值后为NaN或Inifity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值 联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：”foo”, “bar”） 任何数字字面量（例如：1，100） 应用了一元 - 符号的数字字面量（例如：-1，-100） 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义： 枚举成员成为了类型。例如，我们可以说某些成员只能是枚举成员的值： 1234567891011121314151617181920212223242526272829303132enum ShapeKind &#123; Circle, Square,&#125;interface Circle &#123; kind: ShapeKind.Circle radius: number&#125;interface Square &#123; kind: ShapeKind.Square sideLength: number&#125;let c: Circle = &#123; kind: ShapeKind.Square, // ~~~~~~~~~~~~~~~~ Error! radius: 100,&#125;// 当有成员为非字面量枚举值时enum ColorKind &#123; Red, Green, Yellow = 2 &lt;&lt; 3&#125;interface Green &#123; // 错误：枚举类型“ColorKind”包含具有不是文本的初始值设定项的成员 kind: ColorKind.Green&#125; 枚举类型本身变成了每个枚举成员的联合。通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值得集合。因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。例如： 1234567891011enum E &#123; Foo, Bar&#125;function f(x: E) &#123; if (x !== E.Foo || x !== E.Bar) &#123; // // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'. &#125;&#125; 这个例子里，我们先检查 x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。 然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar 运行时的枚举枚举是在运行时真正存在的对象。例如下面的枚举： 123456789enum E &#123; X, Y, Z&#125;function f(obj: &#123; X: number &#125;) &#123; return obj.X&#125;// Works, since 'E' has a property named 'X' which is a number.f(E) 反向映射从枚举值到枚举名字，但不会为字符串枚举成员生成反向映射，如： 123456789enum NumberEnum &#123; A&#125;enum StringEnum &#123; A = 'a'&#125;console.log(NumberEnum[0]) // 'A'console.log(StringEnum['a']) // undefined const枚举常量枚举有两个特点： 常量枚举只能使用常量枚举表达式。 1234567891011// OKenum NumberEnum &#123; A, B = Math.random()&#125;// Errorconst enum NumberEnum &#123; A, B = Math.random()&#125; 不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。之所以可以这么做是因为，常量枚举不允许包含计算成员。 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 生成后的代码为： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举外部枚举用来描述已经存在的枚举类型的形状 12345declare enum Enum &#123; A = 1, B, C = 2&#125; 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。 类型推论这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的 基础TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子 1let x = 3 变量x的类型为数字。这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最适合的通用类型，如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型。 1234let x = [0, 1, null] // (number)[]let zoo = [new Rhino(), new Elephant(), new Snake()] // (Rhino | Elephant | Snake)[]// 当候选类型不能使用的时候，我们需要明确的指出类型let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()] 上下文类型TypeScript类型推论也可能按照相反的方向进行。这被叫做”按上下文归类“。按上下文归类会发生在表达式的类型与所处的位置相关时。比如： 123window.onmousedown = function (mouseEvent) &#123; console.log(mouseEvent.message) // Error&#125; 如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.message); //&lt;- Now, no error is given&#125;; 上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如： 123function createZoo(): Animal[] &#123; return [new Rhino(), new Elephant(), new Snake()];&#125; 这个例子里，最佳通用类型由4个候选者：Animal，Rhino，Elephant和Snake。当然，Animal会被作为最佳通用类型 类型兼容性TypeScript里的类型兼容性是基于结构子类型的。结构类型是一种值使用其成员来描述类型的方式。它正好与名义（nominal）类型形成对比。（在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子： 123456789interface Named &#123; name: string&#125;class Person &#123; name: string&#125;// OK, because of a structural typinglet p: Named = new Person TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 开始TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有x相同的属性，如果一个y类型的值赋给一个x类型的值，则会递归遍历x的属性是否在y中都存在，如果都存在，则这两者是兼容的，比如 1234567891011interface Named &#123; props: &#123; name: string &#125;&#125;function greet(n: Named) &#123; console.log('Hello, ' + n.props.name)&#125;let y = &#123; props: &#123;name: 'a'&#125; &#125;greet(y) // OK 比较两个函数x(源函数) = y(目标函数) 目标函数的参数必须能在源函数里找到对应类型的参数 源函数的返回值类型必须是目标函数返回值类型的子类型 比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的签名 1234let x = (a: number) =&gt; (&#123; a: 1, b: 2 &#125;)let y = (b: number, s: string) =&gt; (&#123; a: 1 &#125;)y = x // OK 枚举数字枚举类型与数字类型兼容，并且数字类型与数字枚举类型兼容。不同枚举类型之间是不兼容的。比如 12345678enum Status &#123; Ready, Waiting &#125;enum Color &#123; Red, Blue, Green &#125;let st = Status.Readylet a: number = 2st = 2 // OKa = Status.Ready // OKst = Color.Green; // Error 类类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如： 123456interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // OK, because y matches structure of x 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了： 1234567interface NotEmpty&lt;T&gt; &#123; data: T;&#125;let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // Error, because x and y are not compatible 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子。比如： 123456789let identity = function&lt;T&gt;(x: T): T &#123; // ...&#125;let reverse = function&lt;U&gt;(y: U): U &#123; // ...&#125;identity = reverse; // OK, because (x: any) =&gt; any matches (y: any) =&gt; any 高级类型本节主要介绍通过type关键字创建高级类型，若要详细了解此节，请阅读源文档 交叉类型：交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 联合类型：表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以number | string | boolean表示一个值可以是number，string，或boolean。如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 类型保护与区分类型 类型谓词：parameterName is Type typeof类型保护：只有两种形式能被识别： typeof v === “typename”和 typeof v !== “typename”， “typename”必须是 “number”， “string”， “boolean”或 “symbol”。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护 Symbols迭代器和生成器当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。 for…of vs for…in for…of遍历的是值，for…in遍历的是属性 另一个区别是for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。 12345678910let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);pets[\"species\"] = \"mammals\";for (let pet in pets) &#123; console.log(pet); // \"species\"&#125;for (let pet of pets) &#123; console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"&#125; 代码生成 目标为ES5和ES3 当生成目标为ES5或ES3，迭代器只允许在Array类型上使用。 在非数组值上使用for..of语句会得到一个错误，就算这些非数组值已经实现了Symbol.iterator属性。 编译器会生成一个简单的for循环做为for…of循环，比如： 1234let numbers = [1, 2, 3];for (let num of numbers) &#123; console.log(num);&#125; 生成的代码为： 12345var numbers = [1, 2, 3];for (var _i = 0; _i &lt; numbers.length; _i++) &#123; var num = numbers[_i]; console.log(num);&#125; 目标为ECMAScript 2015或更高 当目标为兼容ECMAScript 2015的引擎时，编译器会生成相对于引擎的for..of内置迭代器实现方式 模块同ECMAScript 2015的模块概念 export = 和 import为了支持CommonJS和AMD的exports，TypeScript提供了export = 和import = require()语法 ZipCodeValidator.ts1234567let numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export = ZipCodeValidator; Test.ts123456789101112import zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip();// Show whether each string passed each validatorstrings.forEach(s =&gt; &#123; console.log(`\"$&#123; s &#125;\" - $&#123; validator.isAcceptable(s) ? \"matches\" : \"does not match\" &#125;`);&#125;); 危险信号 文件的顶层声明是export namespace Foo { … }（删除Foo并把所有内容向上层移动一层） 文件只有一个export class 或 export function（考虑使用export default） 多个文件的顶层具有同样的export namespace Foo {（不要以为这些会被合并到一个Foo中！） 命名空间命名空间和模块在TypeScript中，每个文件都代表一个模块，通过import，export，export = 和import = require(…)进行导入和导出，在TypeScript1.5之前称为外部模块。命名空间namespace，在TypeScript1.5之前称为内部模块，是定义在全局空间下的一个JS对象，不存在导入和导出的概念，不同文件相同的命名空间里的变量会被整合到一起，因此需要把所有相同命名空间的文件通过–outFile输出到一个文件中，防止发生运行时错误，使用全局命名空间的时候，不能使用import导入其他模块。当把namespace通过export导出的时候，这个内部模块就变成了外部模块。 命名空间命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过 –outFile结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的&lt;script&gt;标签里。 但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。 模块像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 声明它的依赖。 模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。 模块解析官网原文 声明合并接口合并接口的非函数的成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。 于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口 A与后来的接口 A合并时，后面的接口具有更高的优先级。 如下例所示： 123456789101112interface Cloner &#123; clone(animal: Animal): Animal;&#125;interface Cloner &#123; clone(animal: Sheep): Sheep;&#125;interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat;&#125; 这三个接口合并成一个声明： 123456interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal;&#125; 这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 单一的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。 比如，下面的接口会合并到一起： 1234567891011interface Document &#123; createElement(tagName: any): Element;&#125;interface Document &#123; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement;&#125;interface Document &#123; createElement(tagName: string): HTMLElement; createElement(tagName: \"canvas\"): HTMLCanvasElement;&#125; 合并后的Document将会像下面这样： 1234567interface Document &#123; createElement(tagName: \"canvas\"): HTMLCanvasElement; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement; createElement(tagName: string): HTMLElement; createElement(tagName: any): Element;&#125; 合并命名空间对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里 Animals声明合并示例： 12345678namespace Animals &#123; export class Zebra &#123; &#125;&#125;namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Dog &#123; &#125;&#125; 等同于： 123456namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Zebra &#123; &#125; export class Dog &#123; &#125;&#125; 除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。 12345678910111213namespace Animal &#123; let haveMuscles = true; export function animalsHaveMuscles() &#123; return haveMuscles; &#125;&#125;namespace Animal &#123; export function doAnimalsHaveMuscles() &#123; return haveMuscles; // Error, because haveMuscles is not accessible here &#125;&#125; 命名空间与类和函数和枚举类型合并 合并命名空间和类 123456class Album &#123; label: Album.AlbumLabel;&#125;namespace Album &#123; export class AlbumLabel &#123; &#125;&#125; 生成的代码 1234567class Album &#123;&#125;(function (Album) &#123; class AlbumLabel &#123; &#125; Album.AlbumLabel = AlbumLabel;&#125;)(Album || (Album = &#123;&#125;)); 利用命名空间来添加函数的属性 12345678910function buildLabel(name: string): string &#123; return buildLabel.prefix + name + buildLabel.suffix;&#125;namespace buildLabel &#123; export let suffix = \"\"; export let prefix = \"Hello, \";&#125;console.log(buildLabel(\"Sam Smith\")); 利用命名空间来扩展枚举型： 12345678910111213141516171819202122enum Color &#123; red = 1, green = 2, blue = 4&#125;namespace Color &#123; export function mixColor(colorName: string) &#123; if (colorName == \"yellow\") &#123; return Color.red + Color.green; &#125; else if (colorName == \"white\") &#123; return Color.red + Color.green + Color.blue; &#125; else if (colorName == \"magenta\") &#123; return Color.red + Color.blue; &#125; else if (colorName == \"cyan\") &#123; return Color.green + Color.blue; &#125; &#125;&#125; 非法的合并TypeScript并非允许所有的合并。目前，类不能与其它类或变量合并。 JSX基本用法想要使用JSX必须做两件事 给文件一个.tsx扩展名 启用jsx选项 TypeScript具有三种JSX模式： preserve：在preserver模式下生成代码中会保留JSX以供后续的转换操作使用（比如：Babel），输出文件扩展名为.jsx。 react：会生成React.createElement，在使用前不需要再进行转换操作了，输出文件扩展名为.js。 react-native：相当于preserve，输出文件扩展名为.js。 类型检查 固有元素：环境自带的某些东西（比如，DOM环境里的div或span组件），固有元素使用特殊的接口JSX.IntrinsicElements来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在JSX.IntrinsicElements接口的属性里查找。 例如： 12345678declare namespace JSX &#123; interface IntrinsicElements &#123; foo: any &#125;&#125;let a = &lt;foo /&gt;; // 正确let b = &lt;div /&gt;; // 错误 基于值得元素： 基于值得元素会简单的在它所在的作用域里按标识符查找 装饰器装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 例如，有一个@sealed装饰器，我们会这样定义sealed函数： 123function sealed(target) &#123; // do something with \"target\" ...&#125; 装饰器工厂如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。 我们可以通过下面的方式来写一个装饰器工厂函数： 12345function color(value: string) &#123; // 这是一个装饰器工厂 return function (target) &#123; // 这是装饰器 // do something with \"target\" and \"value\"... &#125;&#125; 装饰器组合多个装饰器可以同时应用到一个声明上，就像下面的示例 1234567// 书写在同一行上@f @g x// 书写在多行上@f@gx 当多个装饰器应用于一个声明上，它们求值方式与复合函数相似。在这个模型下，当复合f和g时，复合的结果(f ∘ g)(x)等同于f(g(x))。 装饰器求值类中不同声明上的装饰器将按以下规定的顺序应用： 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。 参数装饰器应用到构造函数。 类装饰器应用到类。 类装饰器参数： 类的构造函数。 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。 1注意 如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中不会为你做这些。 方法装饰器参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 1注意 如果代码输出目标版本小于ES5，属性描述符将会是undefined。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 1注意 如果代码输出目标版本小于ES5返回值会被忽略。 访问器装饰器1注意 TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。 参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 1注意 如果代码输出目标版本小于ES5，属性描述符将会是undefined。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 1注意 如果代码输出目标版本小于ES5返回值会被忽略。 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 1注意 属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 参数装饰器参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引。 1注意 参数装饰器只能用来监视一个方法的参数是否被传入。 参数装饰器的返回值会被忽略。 Mixins 使用implements关键词，把类当做接口。 为将要mixin进来的属性方法创建出占位属性,告诉编译器这些成员在运行时是可用的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125;class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + \" : \" + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125;applyMixins(SmartObject, [Disposable, Activatable]);let smartObj = new SmartObject();setTimeout(() =&gt; smartObj.interact(), 1000);////////////////////////////////////////// In your runtime library somewhere////////////////////////////////////////function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;); &#125;);&#125; 三斜线指令三斜线指令是包含单个XML标签的单行注释。注释的内容会作为编译器指令使用。 三斜线指令仅可放在包含它的文件的最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。 使用–noResolve编译选项，三斜线引用会被忽略 /// &lt;reference path=”…” /&gt;：用于声明文件间的依赖，告诉编译器在编译过程中要引入的额外的文件。 /// &lt;reference types=”…” /&gt;：用于声明对某个包的依赖，仅当在你需要写一个d.ts文件时才使用这个指令。若要在.ts文件声明一个对@types包的依赖，使用–types命令行选项或在tsconfig.json里指定。 /// &lt;reference no-default-lib=”true” /&gt;：这个指令把一个文件标记成默认库，告诉编译器在编译过程中不要包含这个默认库（比如，lib.d.ts）。 这与在命令行上使用 –noLib相似。还要注意，当传递了–skipDefaultLibCheck时，编译器只会忽略检查带有/// &lt;reference no-default-lib=”true”/&gt;的文件。 /// &lt;amd-module name=”…” /&gt;： 默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如 r.js。 amd-module指令允许给编译器传入一个可选的模块名： amdModule.ts123///&lt;amd-module name='NamedModule'/&gt;export class C &#123;&#125; 这会将NamedModule传入到AMD define函数里： amdModule.js12345678define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) &#123; var C = (function () &#123; function C() &#123; &#125; return C; &#125;)(); exports.C = C;&#125;);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"TypeScript","slug":"编程语言/TypeScript","permalink":"http://yoursite.com/categories/编程语言/TypeScript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-25T06:49:11.465Z","updated":"2019-02-12T02:21:46.025Z","comments":true,"path":"2019/01/25/hello-world.html","link":"","permalink":"http://yoursite.com/2019/01/25/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"others","slug":"others","permalink":"http://yoursite.com/categories/others/"}],"tags":[]}]}